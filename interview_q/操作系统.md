# 问题集锦

---

#### 1、请你讲述一下互斥锁(mutex)机制，以及互斥锁和读写锁的区别

****参考回答：****

##### (1) 互斥锁和读写锁区别

互斥锁：`mutex`，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。

读写锁：`rwlock`，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者(一旦有写者，则后续读者必须等待，唤醒时优先考虑写者)。适用于读取数据的频率远远大于写数据的频率的场合。
读写锁：rwlock，分为读锁和写锁.处于读操作时，可以允许多个线程同时获得读操作.但是同一时刻只能有一个线程可以获得写锁.其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒.注意：写锁会阻塞其它读写锁.当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者(一旦有写者，则后续读者必须等待，唤醒时优先考虑写者)。适用于读取数据的频率远远大于写数据的频率的场合.

>总结互斥锁和读写锁的区别
>
>1)读写锁区分读者和写者，而互斥锁不区分
>
>2)互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。

##### (2) Linux的4种锁机制

**互斥锁：**`mutex`，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

**读写锁：**`rwlock`，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者(一旦有写者，则后续读者必须等待，唤醒时优先考虑写者)。适用于读取数据的频率远远大于写数据的频率的场合。

**自旋锁：**`spinlock`，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源

**RCU：** 即 `read-copy-update`，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据 `update` 成新的数据。使用 `RCU` 时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。

---

#### 2、请回答一下进程和线程的区别

**参考回答：**

（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。

（2）进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）

（3）进程是资源分配的最小单位，线程是CPU调度的最小单位。

（4）系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、`I/O`设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。

（5）通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。

（6）进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。

（7）进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。

（8）进程适应于多核、多机分布；线程适用于多核。

---

#### 3、请你回答一下软链接和硬链接区别

**参考回答：**

为了解决文件共享问题，`Linux` 引入了软链接和硬链接。除了为 `Linux` 解决文件共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。若1个 `inode` 号对应多个文件名，则为硬链接，即硬链接就是同一个文件使用了不同的别名，使用 `ln` 创建。若文件用户数据块中存放的内容是另一个文件的路径名指向，则该文件是软连接。软连接是一个普通文件，有自己独立的 `inode`，但是其数据块内容比较特殊。

---

#### 4、请你回答一下静态变量什么时候初始化

**参考回答：**

静态变量存储在虚拟地址空间的数据段和 `bss` 段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。

---

#### 5、请你说一说用户态和内核态区别

**参考回答：**

用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。

---

#### 6、死循环+来连接时新建线程的方法效率有点低，怎么改进？

**参考回答：**

提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术。

---

#### 7、请你说一说多线程的同步，锁的机制

**参考回答：**

同步的时候用一个互斥量，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程将会被阻塞直到当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥量加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。

---

#### 8、两个进程访问临界区资源，会不会出现都获得自旋锁的情况？

**参考回答：**

单核cpu，并且开了抢占可以造成这种情况。

---

#### 9、请你说一说死锁产生的必要条件？

**参考回答：**

（1）互斥条件：一个资源每次只能被一个进程使用。

（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3）不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。

（4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

---

#### 10、请你说一说内存溢出和内存泄漏

**参考回答：**

（1）内存溢出

指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误

内存溢出原因：

a.内存中加载的数据量过于庞大，如一次从数据库取出过多数据
b.集合类中有对对象的引用，使用完后未清空，使得不能回收
c.代码中存在死循环或循环产生过多重复的对象实体
d.使用的第三方软件中的BUG启动参数内存值设定的过小

（2）内存泄漏

内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的分类：

a.堆内存泄漏（Heap leak）。对内存指的是程序运行中根据需要分配通过malloc，realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的free或者delete删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。

b.系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如Bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

c.没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

---

#### 11、进程和线程的区别，你都使用什么线程模型

**参考回答：**

（1）进程和线程区别

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存
。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
- 进程是资源分配的最小单位，线程是CPU调度的最小单位。
- 系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。
- 通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。
- 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。
- 进程间不会相互影响；线程一个线程挂掉将导致整个进程挂掉。
- 进程适应于多核、多机分布；线程适用于多核。

（2）常用线程模型

- Future模型
该模型通常在使用的时候需要结合Callable接口配合使用。
Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。
Callable是类似于Runnable的接口，其中call方法类似于run方法，所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。两者的方法体都是线程执行体。

- fork&join模型
该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。
这里模拟一个摘苹果的场景：有100棵苹果树，每棵苹果树有10个苹果，现在要把他们摘下来。为了节约时间，规定每个线程最多只能摘10棵苹树以便于节约时间。各个线程摘完之后汇总计算总苹果树。

- actor模型
actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。

- 生产者消费者模型
生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。

- master-worker模型
master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。
