> **剑指offer 10-I.斐波那契数列**：写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：  
> 　　　　　F(0) = 0,   F(1) = 1  
>　　　　　F(N) = F(N - 1) + F(N - 2), 其中 N > 1.  
>
>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。  
>示例 1：  
>　　输入：n = 2  
>　　输出：1  
>示例 2：  
>　　输入：n = 5  
>　　输出：5  
>提示：0 <= n <= 100  

[评论精选](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/)描述得比较全面，直接复制如下。
- 递归法：
  - 原理： 把 f(n) 问题的计算拆分成 f(n−1) 和 f(n-2) 两个子问题的计算，并递归，以 f(0) 和 f(1) 为终止条件。
  - 缺点： 大量重复的递归计算，例如 f(n) 和 f(n−1) 两者向下递归需要 各自计算 f(n - 2) 的值。这里因为递归法中重复计算太多了，所以改进的方向也就很明确：避免重复计算。  
```
f(5) = 　　　　　f(4) 　　　 　　 + 　　　　　　　f(3)
　　　　   f(3) 　+　 f(2)　 　　 +　    f(2)  　 +　 f(1)
　　　f(2) + f(1) + f(1) + f(0)  +  f(1) + f(0)  +    1

```

- 记忆化递归法（《算法笔记》P426）：
  - 原理：在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。
  - 缺点：记忆化存储需要使用 O(N) 的额外空间。
- 动态规划法：
  - 原理：直接利用公式（状态转移方程）循环迭代计算。
  - 缺点：每次查询都要从头开始计算。
  - 时间复杂度 O(N) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1)。
  - 空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。
```
class Solution {
public:
    int fib(int n) {
        if(n == 0 || n == 1)//合并
            return n;

        unsigned int sum, b = 0, a = 1;
        for(int i = 2; i<=n; i++)
        {
            sum = (a + b) % 1000000007;
            b = a;
            a = sum;
        }
        return sum;

        /*评论区看的，附上
        int b = 0, a = 1;
        for (int i = 1; i < n; i++) {
            a = a + b;
            b = a - b;
            a %= 1000000007;
            }
        return a;*/
    }
};
```