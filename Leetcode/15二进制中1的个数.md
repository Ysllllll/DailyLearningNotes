>**剑指offer 15.二进制中1的个数**：请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>示例 1：
>　输入：00000000000000000000000000001011
>　输出：3
>　解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
>示例 2：
>　输入：00000000000000000000000010000000
>　输出：1
>　解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
>示例 3：
>　输入：11111111111111111111111111111101
>　输出：31
>　解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
>提示：输入必须是长度为 32 的 二进制串 。
>[注意：本题与主站 191 题相同](https://leetcode-cn.com/problems/number-of-1-bits/)

一共有4种解法，前两种在对负数计数时存在问题，后续两种能够解决负数的计数问题，参考如下。

- 这道题比较简单，最直接的写法：

  ```C++
  class Solution {
  public:
      int hammingWeight(uint32_t n) {
          int res = 0;
          while(n)
          {
              res = res + n % 2;
              n = n / 2;
          }
          return res;
      }
  };
  ```
  
  上面的代码中，可以将除法运算`n = n / 2;`修改为位移运算`n = n>>1`，因为通常来说除法的效率要比位移运算低得多，所以在实际编程中应尽可能地用位移运算替代乘除法。

- 按位与的写法：
  
  ```C++
  class Solution {
  public:
      int hammingWeight(uint32_t n) {
          int res = 0;
          while(n)
          {
              if(n & 1) res++;
              n = n>>1;
          }
          return res;
      }
  };
  ```

前面的两段代码还存在一个问题：如果输入一个负数，比如0x8000 0000，其二进制形式如下：

```shell
0x8000 0000:  1000 0000 0000 0000 0000 0000 0000 0000
```

若将该负数右移一位，我们将会得到：

```shell
0xC000 0000:  1100 0000 0000 0000 0000 0000 0000 0000
```

这是因为移位前是一个负数，仍然要保证移位后是一个负数，因此移位后的最高位会设为1。如果一直移下去后果可想而知，程序将陷入死循环。为了避免死循环我们可以反向移位。

- 死循环修复版

  ```C++
  class Solution {
  public:
      int hammingWeight(uint32_t n) {
          int res = 0;
          unsigned int flag = 1;
          while(flag)
          {
              if(n & flag) res++;
              flag = flag<<1;
          }
          return res;
      }
  };
  ```

- 最终的解法，规律如下：
  设 `n = 1100`。
  有 `n - 1 = 1100 - 1 = 1011`。
  有 `(n - 1) & n = 1011 & 1100 = 1000`。
  可以发现`(n - 1)&n`即是将二进制表示中最末的那个1（不是最低位）变为0。

  ```C++
  class Solution {
  public:
      int hammingWeight(uint32_t n) {
          int res = 0;

          while(n)
          {
              n = (n - 1) & n;
              res++;
          }
          return res;
      }
  };

  ```

**相关题目：**
>
> 1. 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。
> 2. 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到 n。比如10的二进制表示为1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101。我们可以分为两步解决这个问题：第一步求这两个数的异或；第二步统计异或结果中1的位数。

**举一反三：**
> 把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0。很多二进制的问题都可以用这种思路解决。
