
<a id="TopicSummary"></a>

> **题目汇总**
>
> - <font size=4>**栈—先进后出**</font>
> 队列实现栈，数组实现栈，链表实现栈
>
>   - **[Leetcode 1114. 按序打印](https://leetcode-cn.com/problems/print-in-order/)** [速览题解](#1114)<a id="l1114"></a>
>     - 简评：理解多线程中可能出现的三种情况：**竞态条件、死锁、资源不足**。其中为了防止出现并发竞态，需要一种具有两种功能的机制：1.对关键部分的访问控制；2.通知阻塞线程。学习几种同步方法：使用信号量、条件变量、互斥锁
>   - **[Leetcode 1116. 打印零与奇偶数](https://leetcode-cn.com/problems/print-zero-even-odd/)** [速览题解](#1116)<a id="l1116"></a>
>     - 简评：理解多线程中可能出现的三种情况：**竞态条件、死锁、资源不足**。其中为了防止出现并发竞态，需要一种具有两种功能的机制：1.对关键部分的访问控制；2.通知阻塞线程。学习几种同步方法：使用信号量、条件变量、互斥锁

<a id="1114"></a>

### [1114. 按序打印](#l1114)

```C++{.line-numbers}
// 第一种方法
// 类型 std::atomic<bool> x;
// 操作 std::atomic_init()  
//      x.load()
//      x.store()
//      std::this_thread::yield();
class Foo {
public:
    std::atomic<bool> firstReady;
    std::atomic<bool> secondReady;
    Foo() {
        std::atomic_init(&this->firstReady, false);
        std::atomic_init(&this->secondReady, false);
    }

    void first(function<void()> printFirst) {
        
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        firstReady.store(true);
    }

    void second(function<void()> printSecond) {
        while(!firstReady.load())
            std::this_thread::yield();
        
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        secondReady.store(true);
    }

    void third(function<void()> printThird) {
        while(!secondReady.load())
            std::this_thread::yield();
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};

// 类型 sem_t
// 操作 sem_init()
//      sem_wait();
//      sem_post();
//      sem_destory();
#include <semaphore.h>
class Foo {
public:
    sem_t firstJobDone;
    sem_t secondJobDone;

    Foo() {
        sem_init(&firstJobDone, 0, 0);
        sem_init(&secondJobDone, 0, 0);
    }

    void first(function<void()> printFirst) {
        
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        sem_post(&firstJobDone);
    }

    void second(function<void()> printSecond) {
        sem_wait(&firstJobDone);
        
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        sem_post(&secondJobDone);
    }

    void third(function<void()> printThird) {
        sem_wait(&secondJobDone);
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};

// 类型 mutex
// 操作 lock()
//      unlock();
class Foo {
public:
    std::mutex m2, m3;

    Foo() {
        m2.lock();
        m3.lock();
    }

    void first(function<void()> printFirst) {
        
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        m2.unlock();
    }

    void second(function<void()> printSecond) {
        m2.lock();
        
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        m3.unlock();
    }

    void third(function<void()> printThird) {
        m3.lock();
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};

// 类型 promise
// 操作 set_value();
//      get_future();
class Foo {
public:
    std::promise<void> p1;
    std::promise<void> p2;

    Foo() {
    }

    void first(function<void()> printFirst) {
        // printFirst() outputs "first". Do not change or remove this line.
        printFirst();
        p1.set_value();
    }

    void second(function<void()> printSecond) {
        p1.get_future().wait();
        // printSecond() outputs "second". Do not change or remove this line.
        printSecond();
        p2.set_value();
    }

    void third(function<void()> printThird) {
       p2.get_future().wait();
        // printThird() outputs "third". Do not change or remove this line.
        printThird();
    }
};

// 使用条件变量 + wait
class Foo {
public:
    Foo():x(0) {
    }

    void first(function<void()> printFirst) {
        printFirst();
        x = 1;
        a.notify_one();
    }

    void second(function<void()> printSecond) {
        while(x < 1){
            unique_lock<mutex> lck(mtx);
            a.wait(lck);
        }
        printSecond();
        x = 2;
        b.notify_one();
    }

    void third(function<void()> printThird) {
        while(x<2){
            unique_lock<mutex> lck(mtx);
            b.wait(lck);
        }
        printThird();
    }
private:
    atomic_int x;
    mutex mtx;
    condition_variable a,b;
};

class Foo {
    condition_variable cv;
    mutex mtx;
    int k = 0;
public:
    void first(function<void()> printFirst) {
        printFirst();
        k = 1;
        cv.notify_all();    // 通知其他所有在等待唤醒队列中的线程
    }

    void second(function<void()> printSecond) {
        unique_lock<mutex> lock(mtx);   // lock mtx
        cv.wait(lock, [this](){ return k == 1; });  // unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行
        printSecond();
        k = 2;
        cv.notify_one();    // 随机通知一个（unspecified）在等待唤醒队列中的线程
    }

    void third(function<void()> printThird) {
        unique_lock<mutex> lock(mtx);   // lock mtx
        cv.wait(lock, [this](){ return k == 2; });  // unlock mtx，并阻塞等待唤醒通知，需要满足 k == 2 才能继续运行
        printThird();
    }
};
```

<a id="1116"></a>

### [1116. 打印零与奇偶数](#l1116)

```C++{.line-numbers}
// 使用条件变量
class ZeroEvenOdd {
private:
    int n;
    mutex mtx;
    condition_variable cv;
    int index;

public:
    ZeroEvenOdd(int n) {
        this->n = n;
        index = 0;
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        while(index < n * 2 - 1)
        {
            unique_lock<mutex> lck{mtx};
            cv.wait(lck, [this](){return index % 2 == 0;});
            printNumber(0);
            index++;
            cv.notify_all();
        }
        
    }

    void even(function<void(int)> printNumber) {
        for(int i = 2; i <= n; i += 2)
        {
            unique_lock<mutex> lck{mtx};
            cv.wait(lck, [this](){return index % 2 == 1 && (index + 1) / 2 % 2 == 0;});
            printNumber(i);
            index++;
            cv.notify_all();
        }
    }

    void odd(function<void(int)> printNumber) {
        for(int i = 1; i <= n; i += 2)
        {
            unique_lock<mutex> lck{mtx};
            cv.wait(lck, [this](){return index % 2 == 1 && (index + 1) / 2 % 2 == 1;});
            printNumber(i);
            index++;
            cv.notify_all();
        }
    }
};

// 使用信号量
#include<semaphore.h>
class ZeroEvenOdd {
private:
    int n;
    sem_t printOdd, printEven, numDone;
public:
    ZeroEvenOdd(int n) {
        this->n = n;
        sem_init(&printOdd, 0, 0);
        sem_init(&printEven, 0, 0);
        sem_init(&numDone, 0, 1);
    }

    // printNumber(x) outputs "x", where x is an integer.
    void zero(function<void(int)> printNumber) {
        for(int i = 1; i <= n; i ++)
        {
            sem_wait(&numDone);
            printNumber(0);
            if(i % 2 == 0)
            {
                sem_post(&printEven);
            }
            else
            {
                sem_post(&printOdd);
            }
        }
    }

    void even(function<void(int)> printNumber) {
        for(int i = 2; i <= n; i += 2)
        {
            sem_wait(&printEven);
            printNumber(i);
            sem_post(&numDone);
        }
    }

    void odd(function<void(int)> printNumber) {
        for (int i = 1; i <= n; i += 2) {
            sem_wait(&printOdd);
            printNumber(i);
            sem_post(&numDone);
        }
    }
};
```
