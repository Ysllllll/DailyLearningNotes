## 动态规划题目特点

- 计数型
  - 有多少中方式走到右下角
  - 有多少中方法选出 k 个数使得和为 sum
- 求最大最小值
  - 从左上角走到右下角路径的最大数字和
  - 最长上升子序列长度
- 求存在性
  - 取石子游戏，先手是否必胜
  - 能不能选出 k 个数使得和是 sum

<a id="base"></a>

## [基础系列](#base-solution)

[关于动态规划，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486381&idx=1&sn=b8b913edabdab1208bf677b9578442e7&scene=21#wechat_redirect)
[动态规划：斐波那契数](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486389&idx=1&sn=c04a762fa0d83aad2ef8738aa659523b&scene=21#wechat_redirect)
[动态规划：爬楼梯](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486421&idx=2&sn=2257ee9d1a7a46ba3e53acf965aa38d6&scene=21#wechat_redirect)
[动态规划：使用最小花费爬楼梯](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486432&idx=1&sn=5f449828e7fbe769540742e91b3fe13c&scene=21#wechat_redirect)
[本周小结！（动态规划系列一）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486446&idx=2&sn=ca6e87ecba6d0fb5c634d1007cece5ac&scene=21#wechat_redirect)
[动态规划：不同路径](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486478&idx=1&sn=17403b8995e6bf2a46a6800803f6aabd&scene=21#wechat_redirect)
[动态规划：不同路径还不够，要有障碍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486510&idx=2&sn=3b410fa6a9ad7cd763a7cd0f4928dfa7&scene=21#wechat_redirect)
[动态规划：整数拆分，你要怎么拆？](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486520&idx=1&sn=736878a6770a638d0cea0011bed187bd&scene=21#wechat_redirect)
[动态规划：不同的二叉搜索树](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486532&idx=1&sn=9c3d605f6bf81027f9f39d1c45b8c4a6&scene=21#wechat_redirect)
[本周小结！（动态规划系列二）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486564&idx=2&sn=89ebcf9fa23ef9935ebfe1d5824b9dc2&scene=21#wechat_redirect)

<a id="01package"></a>

## [01 背包问题系列](#01package-solution)

[动态规划：关于 01 背包问题，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486598&idx=1&sn=dd7d0530dd7a5caef7ce70cc3d6eee3f&scene=21#wechat_redirect)
[动态规划：关于 01 背包问题，你该了解这些！（滚动数组）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486624&idx=2&sn=96e8c6344dc25f57462b675b55ccd6e7&scene=21#wechat_redirect)
[动态规划：分割等和子集可以用 01 背包！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486632&idx=1&sn=4bb229e3f3f5774ac684c0127c88c984&scene=21#wechat_redirect)
[动态规划：最后一块石头的重量 II](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486644&idx=1&sn=548c90df36b47d67290b5667c7cec3d3&scene=21#wechat_redirect)
[本周小结！（动态规划系列三）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486683&idx=2&sn=db28c1e34214a65b92cf2bd70d88ff3c&scene=21#wechat_redirect)
[动态规划：目标和！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486709&idx=1&sn=75f1f43d96dbd1c5c3e281b8963e3c50&scene=21#wechat_redirect)
[动态规划：一和零！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486739&idx=2&sn=e226eacf67df9b6c784264f954ae42bf&scene=21#wechat_redirect)

<a id="complate-package"></a>

## [完全背包问题系列](#complate-package-solution)

[动态规划：关于完全背包，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486748&idx=1&sn=dca9f65b75a75c50c502ae8aba279877&scene=21#wechat_redirect)
[动态规划：给你一些零钱，你要怎么凑？](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486757&idx=1&sn=36f5eb60bfe4d8993cf3b3def5645a34&scene=21#wechat_redirect)
[本周小结！（动态规划系列四）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486780&idx=2&sn=fdde680deb4ae6b9b3f1f08893039a73&scene=21#wechat_redirect)
[动态规划：Carl 称它为排列总和！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486826&idx=2&sn=80de2ae278bfd0c906d51fd012d37565&scene=21#wechat_redirect)
[动态规划：以前我没得选，现在我选择再爬一次！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486833&idx=1&sn=beda10fdf8f53e8596dd3ad56ff751d5&scene=21#wechat_redirect)
[动态规划：给我个机会，我再兑换一次零钱](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486848&idx=1&sn=fec1c0c36789f4929a9067910afd600b&scene=21#wechat_redirect)
[动态规划：一样的套路，再求一次完全平方数](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486872&idx=2&sn=01a3b81edafd125812d8860e89a6407f&scene=21#wechat_redirect)
[本周小结！（动态规划系列五）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486884&idx=1&sn=27552812d5194c7ce8eafceedc5cc222&scene=21#wechat_redirect)
[动态规划：单词拆分](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486916&idx=2&sn=739861fa954827bff3591459da514443&scene=21#wechat_redirect)
[动态规划：关于多重背包，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486924&idx=1&sn=261b70e810ffc27c197b9b353678b87c&scene=21#wechat_redirect)
[听说背包问题很难？这篇总结篇来拯救你了](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486998&idx=1&sn=d0c7ea872aabe0d27986922089edd298&scene=21#wechat_redirect)

其它参数资料：[0-1 背包问题](https://www.jianshu.com/p/a66d5ce49df5)、[动态规划之 01 背包问题（最易理解的讲解）](https://blog.csdn.net/mu399/article/details/7722810?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.baidujs)

<a id="raid-homes-and-plunder-houses"></a>

## [打家劫舍系列](#raid-homes-and-plunder-houses-solution)

[动态规划：开始打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487032&idx=2&sn=51fe9348fabe8bc56c69358e790baf43&scene=21#wechat_redirect)
[动态规划：继续打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487055&idx=2&sn=9db1e211ebc4b9b066ff699f77534c76&scene=21#wechat_redirect)
[动态规划：还要打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487067&idx=1&sn=bd543182c421b100c1d5db5b699666f3&scene=21#wechat_redirect)

<a id="shares"></a>

## [股票系列](#shares-solution)

[动态规划：买卖股票的最佳时机](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487087&idx=2&sn=bb070ba67efbc375b704f229604652f8&scene=21#wechat_redirect)
[动态规划：本周我们都讲了这些（系列六）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487099&idx=1&sn=0215d476bbf9344e86973df907eda4c9&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 II](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487224&idx=1&sn=a6ad54c3ff36c501a35e8423405f2724&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 III](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487244&idx=2&sn=d4cefe597a0d5500adec6bff944c4bf5&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 IV](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487253&idx=1&sn=662e863724c4c8588b79669db553f9ec&scene=21#wechat_redirect)
[动态规划：最佳买卖股票时机含冷冻期](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487286&idx=2&sn=4e129dbd298d907ad434a86ec25fed88&scene=21#wechat_redirect)
[动态规划：本周我们都讲了这些（系列七）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487314&idx=2&sn=15e34495a269fa42fba6e0cc26c4cba1&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机含手续费](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487353&idx=2&sn=fba963ef370c60328b39a620ece4e2a6&scene=21#wechat_redirect)

<a id="subsequence"></a>

## [子序列系列](#subsequence-solution)

[动态规划：最长递增子序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487371&idx=2&sn=f57561d52e2322279e2c349a24757faa&scene=21#wechat_redirect)
[动态规划：最长连续递增序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487388&idx=2&sn=87d091d532b2e2f57ad7c1eb0b56b30b&scene=21#wechat_redirect)
[动态规划：最长重复子数组](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487499&idx=2&sn=560d5e6a411c562439e908316eb41a38&scene=21#wechat_redirect)
[动态规划：最长公共子序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487526&idx=2&sn=0932bd5f65fdb4d3633df573c93cf7f1&scene=21#wechat_redirect)
[动态规划：本周我们都讲了这些（系列八）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487578&idx=2&sn=e55050f9ea4ac5b3eaba4454860e3a1f&scene=21#wechat_redirect)
[动态规划：不相交的线](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487692&idx=2&sn=f1690ba7dbeed45fcc1fd88b7480668f&scene=21#wechat_redirect)
[动态规划：最大子序和](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487717&idx=2&sn=a54cdba5fde5d43a3fe7344064182873&scene=21#wechat_redirect)
[动态规划：判断子序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487764&idx=2&sn=05e440c85c4b33753d4f93707cd7a6f9&scene=21#wechat_redirect)

<a id="TopicSummary"></a>

> **题目汇总**
>
> <a id="base-solution"></a>
>
> - [**基础系列**](#base)
>
>   - **[Leetcode 509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/submissions/)** [速览题解](#509)
>   - **[Leetcode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)** [速览题解](#70)
>     > 简评：这道题还有一个升级版，如果我能够走 1 步、2 步、3 步、...、m 步，那请问我有多少种走法。这样问的一个思路就是，我将楼梯看成一个字符串，然后对这个字符串进行切割，切成多个子字符串，然后要保证子字符串的最大长度是 m。其实就是排列组合。另外这道题也表明了 **dp 数组的初始化不要为了初始化而初始化，如果某一个 dp[i] 没有意义，我们不初始化它就是了**
>   - **[Leetcode 746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)** [速览题解](#746)
>     > 简评：这道题是在第 70 题的基础之上而来的，这种类型的就存在一种规律，需要总结归纳。有两种看待角度，每一种角度的初始化应该注意
>   - **[Leetcode 62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)** [速览题解](#62)
>     > 简评：考虑一下空间复杂度和时间复杂度。这道题还可以用数学公式做，一共要走 m+n-2 步，其中要横向走 m-1 步，纵向走 n-1 步，那么就是一个组合问题，但是组合公式得记一下
>   - **[Leetcode 63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)** [速览题解](#63)
>     > 简评：这道题最主要的盲点是初始化时，遇到障碍物后，后面的结点都无法到达，此时对应的 dp[i]为 0。这道题可以用一维的 dp 来做以节省空间复杂度，但是得注意处理
>   - **[Leetcode 343. 整数拆分](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)** [速览题解](#343)
>     类似题目：**[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)** [速览题解](#343)
>     > 简评：这道题的数学方法很快，但是需要掌握其证明的过程，也就是**为什么要把 x 分成相等的 n 份才可能获得最大值**，在得到这个结论后，又是如何求的**每一份为多少时获得的乘积最大**，[参考 Leetcode 官方的讲解](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)。
>   - **[Leetcode 96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)** [速览题解](#96)
>
>     > 简评：注意是二叉**搜索树**，所以其实头结点的选取方式决定了左右结点的数量。这道题的数学原理是：**卡塔兰数**，关于这个原理的应用还有许多，可以查一下
>
>     <a id="01package-solution"></a>
>
> - [**01 背包问题系列**](#01package)：下面几个问题都是 01 背包的应用
>
>   - [背包问题代码](#01package-origin)
>     > 简评：一维背包遍历顺序只有一种，二维背包的遍历顺序有两种
>   - 类型一：背包最多能装多少
>
>     - **[Leetcode 416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/)** [速览题解](#416)
>       > 简评：这是一道 01 背包的应用，要学会从应用情景中分析出背后的原理。专业的术语叫做：**约化**，约化即是将一个问题转换为另外一类问题。另外这道题可以用**位运算**来做，参考[位运算解析](https://link.zhihu.com/?target=https%3A//github.com/ShusenTang/LeetCode/blob/master/solutions/416.%2520Partition%2520Equal%2520Subset%2520Sum.md)
>     - **[Leetcode 1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/submissions/)** [速览题解](#1049)
>       > 简评：这道题也可以使用**位运算**来做，但是原理没有理解到
>
>   - 类型二：背包装满有几种方法
>
>     - **[Leetcode 494. 目标和](https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode/)** [速览题解](#494)
>
>       > 简评：**dp[i]的含义是刚好填满 j 这么大的背包**，有几种方法，如果有一个物品体积为 3，背包为 4，此时 dp[3]为 1，而 dp[4]应该为 0。此外的公式推导一定要理解，同时还有枚举法，可以了解下
>
>     - **[Leetcode 474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)** [速览题解](#474)
>     - **[Leetcode 879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)** [速览题解](#879)
>
>     <a id="complate-package-solution"></a>
>
> - [**完全背包问题系列**](#complate-package)：下面几个问题都是完全背包的应用
>
>   - [完全背包问题代码](#complate-package-origin)
>
>     > 简评：一维背包遍历顺序有两种，二维背包的遍历顺序也有两种
>
>   - **[Leetcode 518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)** [速览题解](#518)
>     > 简评：这道题是完全背包的应用，注意完全背包中遍历顺序的问题。**这是组合问题**
>   - **[Leetcode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/submissions/)** [速览题解](#70)
>     > 简评：这道题可以用完全背包来解决。**这是排列问题**
>   - **[Leetcode 322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/submissions/)** [速览题解](#322)
>     > 简评：这道题还可以用广度优先搜索来做。**组合、排列均可**，即**本题外层 for 遍历背包，里层 for 遍历物品，还是外层 for 遍历物品，内层 for 遍历背包，都是可以的！**
>   - **[Leetcode 279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)** [速览题解](#279)
>     > 简评：**本题外层 for 遍历背包，里层 for 遍历物品，还是外层 for 遍历物品，内层 for 遍历背包，都是可以的！**
>   - **[Leetcode 139. 单词拆分](https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/)** [速览题解](#139)
>
> <a id="raid-homes-and-plunder-houses-solution"></a>
>
> - [**打家劫舍系列**](#raid-homes-and-plunder-houses)
>
>   - **[Leetcode 198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)** [速览题解](#198)
>   - **[Leetcode 213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/submissions/)** [速览题解](#213)
>     > 简评：最后一个房子会影响到第一个房子的选择，违反了动态规划的无后效性，所以要拆分为两部分来看。通过这个题学习下如何处理成环的问题
>   - **[Leetcode 337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)** [速览题解](#337)
>     > 简评：这道题是第一道树形 DP，但是 dp 的时间复杂度和空间复杂度都没有记忆化递归来的好
>
>   <a id="shares-solution"></a>
>
> - [**股票系列**](#shares)
>
>   - [股票问题系列通解](https://leetcode-cn.com/circle/article/qiAgHn/)，该篇文章是股票问题的一个归纳
>
>   - **[Leetcode 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)** [速览题解](#121)
>     > 简评：这道题最简单的状态转移关系是：**前 i 天的最大收益 = max{前 i-1 天的最大收益，第 i 天的价格-前 i-1 天中的最小价格}**。但是看 Carl 的说法这是贪心，不算是动态规划。
>     > 关于动态规划的思路可以[参考 Leetcode 评论区](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-zu-1v0i/)。
>     > 另外**关于 dp[i][0]的推导公式** ：对于 dp[i][0] 有个很迷惑的想法，为什么他的递推公式不是 max(dp[i-1][0], dp[i-1][1])-prices[i]) 呢？题解上对于第二个参数只取了 -prices[i] ，这就没有把前一天所拥有的现金包括进去，但是我按照我的想法试了一下，结果是错误的，自己推导了一遍，也不是很理解，既然前一天不持有股票，今天要买入股票，不应该就是拿前一天不持有股票的所得现金，减去今天股票的价格嘛？
>     > **啊！我明白了，就是只买卖一次股票嘛，所以肯定是 0-prices[i] 嘛，蠢了~**
>   - **[Leetcode 122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)** [速览题解](#122)
>     > 简评：这道题与上一道题的差别在于可以多次买卖，但是每次买卖必须相邻，不能多次买后再多次卖。注意推导 dp[i][0] 与上一题的区别，本题，因为一只股票可以买卖多次，所以当第 i 天买入股票的时候，所持有的现金可能有之前买卖过的利润。
>   - **[Leetcode 123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/)** [速览题解](#123)
>   - **[Leetcode 188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)** [速览题解](#188)
>     > 简评：上面的三道买卖股票的最佳时机都是这道题 `k` 取特殊值时的情况
>   - **[Leetcode 309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/)** [速览题解](#309)
>   - **[Leetcode 714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)** [速览题解](#714)
>     > 简评：这道题也是无限制交易，相对于 II 来说，就是多了手续费
>
> <a id="subsequence-solution"></a>
>
> - [**子序列系列**](#subsequence)
>
>   - **[Leetcode 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/)** [速览题解](#300)
>     > 简评：这道题不需要连续递增，可以将时间复杂度降低到 O(nlogn)，[参考评论区](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)
>   - **[Leetcode 674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)** [速览题解](#674)
>
>     > 简评：这道题需要连续递增，对于 dp[i]的状态的定义是以下标 i 为结尾，但是并不是说一定以下标 0 为起始位置。这道题也可以用贪心，但是和动态规划思路一致。这道题还有人用并查集解，可以学习下
>
>   - **[Leetcode 53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)** [速览题解](#53)
>
>     > 简评：这道题也可以用贪心算法来做，这道题注意与最长连续递增子序列不一样。最长连续递增子序列得到的子序和不一定是最大子序和，举例如：`{-1, 1, 0, 3, 4}`。
>
>     **不连续递增子序列的跟前 0-i 个状态有关，连续递增的子序列只跟前一个状态有关**
>
>     **另外可以发现，我们可以求一个连续或不连续上升（下降）序列的最大个数或者最大和，两种求的不一样，但是思路显然是一致的。另外还可以求连续子序列中和最大的，或者非连续序列中和最大的（这种遍历全部正数或者仅选取一个负数就行了，是最简单的）。注意归类**
>
>   - **[Leetcode 718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)** [速览题解](#718)
>     > 简评：这道题目还可以用滑动指针来做
>   - **[Leetcode 1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)** [速览题解](#1143)
>     > 简评：718 要求连续，而 1143 要求不连续，区别注意归类
>   - **[Leetcode 1035. 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)** [速览题解](#1035)
>
>     > 简评：注意这道题是 1143.最长公共子序列的应用！[参考链接](https://leetcode-cn.com/problems/uncrossed-lines/solution/ni-de-yi-fu-wo-ba-liao-zui-chang-gong-gong-zi-xu-3/)
>
>     考虑使用动态规划时，使用滚动数组一定要弄清楚是要顺序遍历还是逆序遍历。如果使用二维数组时 `dp[i][j]` 要用到 `dp[i][<j]` 的元素则必须顺序遍历。如果只需要使用到 `dp[i - 1][<=j]` 的元素，则使用逆序遍历方便
>
>   - **[Leetcode 392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/submissions//)** [速览题解](#392)
>
>     **子序列不要求连续匹配，因此跟前 0-i 个状态有关。而重复子数组要求连续，此时就只跟前一个状态有关**。这里还有一个值得关注的事情`string1[i - 1] == string2[j - 2]`时都是 `dp[i][j] = dp[i - 1][j - 1] + 1`。而当`string1[i - 1] != string2[j - 2]`时，注意分别是怎么转移的
>
> <a id="additional-questions"></a>
>
> - **附加题**
>   - **[Leetcode 10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)** [速览题解](#10)
>     > 简评：[这道题比较难，也没有很懂思路，参考这个链接](https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-dong-tai-gui-hua-by-jy/)。这道题一共有两种常见的方法：递归 + 动态规划
>   - **[Leetcode 91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)** [速览题解](#91)
>   - **[Leetcode 152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/submissions/)** [速览题解](#152)
>
> <a id="UnderstandingRepetitiveSubproblems"></a>
>
> - **理解重复子问题**
>   - **[剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)** [速览题解](#46)

---

<a id="509"></a>

### [509. 斐波那契数](#base-solution)

```C++{.line-numbers}
//递归做法
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        return fib(n - 1) + fib(n - 2);
    }
};

//记忆化递归法
class Solution {
public:

    int fib(int n) {
        if(n < 2) return n;

        vector<int> dp(n + 1, -1);
        dp[0] = 0;
        dp[1] = 1;
        return helper(n, dp);
    }
    int helper(int n, vector<int> &dp)
    {
        if(dp[n] != -1)
            return dp[n];
        else
            dp[n] = helper(n - 1, dp) + helper(n - 2, dp);

        return dp[n];
    }
};

//动态规划做法
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;

        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;

        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};

//动态规划优化空间复杂度
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```

<a id="70"></a>

### [70. 爬楼梯](#base-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;

        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
};

//优化空间复杂度后的动态规划
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;

        int dp[3];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
        {
            dp[0] = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = dp[0];
        }
        return dp[0];
    }
};

//转换为完全背包的动态规划
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= 2; j++)
                if(i - j >= 0)
                    dp[i] += dp[i - j];
        return dp[n];
    }
};
```

<a id="746"></a>

### [746. 使用最小花费爬楼梯](#base-solution)

```C++{.line-numbers}
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];

        for(int i = 2; i < cost.size(); i++)
        {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1;
            dp1 = dpi;
        }

        return min(dp0, dp1);
    }
};

//第二种看法，这种比较符合常理
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int size = cost.size();

        if(size <= 2) return 0;
        vector<int> dp(size + 1, 0);
        dp[0] = 0;
        dp[1] = 0;

        for(int i = 2; i <= size; i++)
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        //dp[i]表示跳到第i级台阶需要花费多少力气

        return dp[size];
    }
};
```

<a id="62"></a>

### [62. 不同路径](#base-solution)

```C++{.line-numbers}
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];
    }
};

// 利用数学公式来做
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;

        for(int x = n, y = 1; y < m; x++, y++)
            ans = ans * x / y;

        return ans;
    }
};
```

<a id="63"></a>

### [63. 不同路径 II](#base-solution)

```C++{.line-numbers}
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int row = obstacleGrid.size();
        if(row == 0)
            return 0;
        int col = obstacleGrid[0].size();
        vector<vector<int>> dp(row, vector<int>(col, 0));

        for(int i = 0; i < col && obstacleGrid[0][i] == 0; i++)
                dp[0][i] = 1;

        for(int i = 0; i < row && obstacleGrid[i][0] == 0; i++)
                dp[i][0] = 1;

        for(int i = 1; i < row; i++)
            for(int j = 1; j < col; j++)
                if(!obstacleGrid[i][j])
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

        return dp[row - 1][col - 1];
    }
};

//优化空间复杂度
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();

        vector<int> dp(n, 0);

        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++)
            dp[j] = 1;

        for(int i = 1; i < m; i++)
            for(int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                    continue;
                }
                if (j - 1 >= 0) {
                    dp[j] += dp[j - 1];
                }
            }

        return dp[n - 1];
    }
};

//写得简洁一点
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();

        vector<int> dp(n, 0);
        dp[0] = 1;

        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if (obstacleGrid[i][j] == 1)
                    dp[j] = 0;
                else if (j != 0 )
                    dp[j] += dp[j - 1];

        return dp[n - 1];
    }
};
```

<a id="343"></a>

### [343. 整数拆分](#base-solution)

```C++{.line-numbers}
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        vector<int> dp(n + 1, 0);
        dp[2] = 1;

        for(int i = 3; i <= n; i++)
            for(int j = 2; j < i; j++)
                dp[i] = max(dp[i], max(j * (i - j), dp[j] * (i - j)));
                //dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));//一样能够得出结果

        return dp[n];
    }
};

// 其实只算一半即可
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        vector<int> dp(n + 1, 0);
        dp[2] = 1;

        for(int i = 3; i <= n; i++)
            for(int j = 1; j < i / 2 + 1; j++) // 只算一半
                dp[i] = max(dp[i], max(dp[i - j] * j, (i - j) * j));

        return dp[n];
    }
};

//数学解法：证明方式，先将问题转化为数学公式，然后对公式求导，得出函数在x=3时取得极值
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        if(n == 2) return 1;
        if(n == 3) return 2;
        if(n == 4) return 4;

        int res = 1;
        while(n > 4)
        {
            res = res * 3;
            n = n - 3;
            cout<<res<<endl;
        }
        return res * n;
    }
};

```

<a id="96"></a>

### [96. 不同的二叉搜索树](#base-solution)

```C++{.line-numbers}
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        //有i个结点时，有多少颗二叉树
        for(int i = 1; i <= n; i++)
            //将序号j作为根时有多少种二叉搜索树
            for(int j = 1; j <= i; j++)
                dp[i] = dp[i] + dp[j - 1] * dp[i - j];

        return dp[n];
    }
};

// 数学原理：卡塔兰数
class Solution {
public:
    int numTrees(int n) {
        long long res = 1;

        for(int i = 0; i < n; i++)
            res = res * 2 * (2 * i + 1) / (i + 2);

        return res;
    }
};
```

<a id="01package-origin"></a>

### [01 背包问题](#TopicSummary)

```C++{.line-numbers}
class Solution
{
public:
    int printDp(vector<vector<int>> dp, int m, int n)
    {
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j <= n; j++)
            {
                cout << dp[i][j] << " ";
            }
            cout << endl;
        }
    }
    int tst2DBagProblem(int &bag, vector<int> &weight, vector<int> &value)
    {
        vector<vector<int>> dp(weight.size(), vector<int>(bag + 1, 0));

        for (int i = bag; i >= weight[0]; i--)
            dp[0][i] = dp[0][i - weight[0]] + value[0];

        for (int i = 1; i < weight.size(); i++) //遍历物品
        {
            for (int j = bag; j >= 0; j--) //遍历背包
            {
                if (j >= weight[i])
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                else //注意不要忽略了
                    dp[i][j] = dp[i - 1][j];
            }
        }

        printDp(dp, weight.size(), bag);//打印
        return dp[weight.size() - 1][bag];
    }
    int tst1DBagProblem(int &bag, vector<int> &weight, vector<int> &value)
    {
        vector<int> dp(bag + 1, 0);

        for (int i = 0; i < weight.size(); i++) //遍历物品
        {
            for (int j = bag; j >= weight[i]; j--) //遍历背包
            {
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
            }

            for (int k = 0; k <= bag; k++) //打印
            {
                cout << dp[k] << " ";
            }
            cout << endl;
        }
        return dp[bag];
    }
};
int main()
{
    int bag = 4;
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    cout << Solution().tst2DBagProblem(bag, weight, value) << endl;

    return 0;
}
```

<a id="416"></a>

### [416. 分割等和子集](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sz = nums.size();
        int sum = 0;
        for(int i = 0; i < sz; i++)
            sum += nums[i];
        if(sum % 2 == 1) return false;
        sum = sum / 2;//这里有问题

        vector<int> dp(sum + 1, 0);
        for(int i = 0; i < sz; i++)
            for(int j = sum; j >= nums[i]; j--)
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

        return dp[sum] == sum;
    }
};

// 动态规划简化版
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int e: nums) sum += e;
        if(sum % 2) return false;
        sum = sum /2;

        vector<int> dp(sum + 1, 0);
        for(int e: nums)
            for(int j = sum; j >= e; j--)//注意j--
                dp[j] = max(dp[j], dp[j - e] + e);

        return dp[sum] == sum;
    }
};

// 位运算
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int e: nums) sum += e;
        if(sum % 2) return false;

        bitset<10001> bs(1);

        for(int e: nums)
        {
            bs = bs | (bs << e);
            if(bs[sum / 2])
                return true;
        }

        return false;
    }
};
//位运算简化版
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        bitset<10001>bits(1);
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum & 1) return false; // sum为奇数
        for (int &num : nums) bits |= (bits << num);
        return bits[sum >> 1];
    }
};
```

<a id="1049"></a>

### [1049. 最后一块石头的重量 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int i = 0; i < stones.size(); i++)
            sum += stones[i];

        int target = sum / 2;
        vector<int> dp(target + 1, 0);
        for(int i = 0; i < stones.size(); i++)
            for(int j = target; j >= stones[i]; j--)
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

        return sum -  2 *  dp[target];
    }
};

// 使用位运算来做，时间复杂度较差，空间复杂度较好
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        const int bound = 40000;
        const int capacity = 80000;

        bitset<80000> F;
        F.reset();
        F[bound] = 1;

        for (int stone : stones) {
            F = (F << stone) | (F >> stone);
        }
        for (int i = 0; i < 30000; i++) {
            if (F[bound+i]) return i;
        }
        return -1;
    }
};
```

<a id="494"></a>

### [494. 目标和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for(int e : nums) sum += e;
        if(S > sum) return false;
        if((S + sum) % 2) return false;

        int target = (S + sum) / 2;
        vector<int> dp(target + 1, 0);
        dp[0] = 1;

        for(int e: nums)
            for(int j = target; j >= e; j--)
                dp[j] = dp[j] + dp[j - e];

        return dp[target];
    }
};

// 暴力递归
class Solution {
public:
    long count = 0;
    int findTargetSumWays(vector<int>& nums, int S) {
        helper(nums, 0, 0, S);
        return count;
    }
    void helper(vector<int>& nums, int i, int sum, int S)
    {
        if(i == nums.size())
        {
            if(sum == S)
                count++;
        }//这个括号注意打上，不然就可能把下面的else归到上面的第二个if上
        else
        {
            helper(nums, i + 1, sum + nums[i], S);
            helper(nums, i + 1, sum - nums[i], S);
        }
    }
};
```

<a id="474"></a>

### [474. 一和零](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(string str: strs)
        {
            int oneNum = 0, zeroNum = 0;
            for(char c: str)
            {
                if(c == '0') zeroNum++;
                else oneNum++;
            }
            for(int i = m; i >= zeroNum; i--)
                for(int j = n; j >= oneNum; j--)
                    dp[i][j] = max(dp[i][j],dp[i - zeroNum][j - oneNum] + 1);
        }

        return dp[m][n];
    }
};
```

<a id="879"></a>

### [879. 盈利计划](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        if( n <= 0) return 0;

        // dp[n][minProfit] 代表 n 个人 达到 minProfit 的利润一共有多少种计划
        vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1, 0));
        for(int i = 0; i <= n; i++) dp[i][0] = 1;


        for(int k = 0; k < group.size(); k++)
        {
            int people = group[k];
            int prof = profit[k];
            for(int i = n; i >= people; i--)
            {
                for(int j = minProfit; j >= 0; j--)// 当 prof 大于 j 时，单个利润仍然存在可能满足条件的组合
                    dp[i][j] = (dp[i][j] + dp[i - people][max(j - prof, 0)]) % (int)(1e9 + 7);
            }
        }
        return dp[n][minProfit];
    }
};
```

<a id="complate-package-origin"></a>

### [完全背包问题代码](#TopicSummary)

```C++{.line-numbers}
// 0 二维，内部优先遍历物品，再遍历背包容量
//1 二维，内部优先遍历背包，再遍历物品
class Solution0
{
public:
    int change(int amount, vector<int> &coins)
    {
        vector<vector<int>> dp(coins.size(), vector<int>(amount + 1, 0));

        for (int i = 0; i < coins.size(); i++)
            dp[i][0] = 1;

        for (int i = 0; i <= amount; i++)//遍历背包
        {
            for (int j = 0; j < coins.size(); j++)//遍历物品
            {
                if (i - coins[j] >= 0)
                    dp[j][i] = dp[j - 1][i] + dp[j][i - coins[j]];
                else//这里需要注意
                    dp[j][i] = dp[j - 1][i];
            }
        }

        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = 0; j <= amount; j++)
            {
                cout << dp[i][j] << " ";
            }
            cout << endl;
        }
        return dp[coins.size() - 1][amount];
    }
};

//1 二维，内部优先遍历背包，再遍历物品
//组合
class Solution1
{
public:
    int change(int amount, vector<int> &coins)
    {
        vector<vector<int>> dp(coins.size(), vector<int>(amount + 1, 0));

        for (int i = 0; i < coins.size(); i++)
            dp[i][0] = 1;

        for (int j = 0; j < coins.size(); j++) //遍历物品
        {
            for (int i = 0; i <= amount; i++) //遍历背包
            {
                if (i - coins[j] >= 0)
                    dp[j][i] = dp[j - 1][i] + dp[j][i - coins[j]];
                else
                    dp[j][i] = dp[j - 1][i];
            }
        }

        for (int i = 0; i < coins.size(); i++)
        {
            for (int j = 0; j <= amount; j++)
            {
                cout << dp[i][j] << " ";
            }
            cout << endl;
        }
        return dp[coins.size() - 1][amount];
    }
};

//3 一维，内部先遍历背包，再遍历物品
//组合
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};

int main()
{
    vector<int> nums{1, 2, 5};
    cout << Solution0().change(5, nums) << endl;

    return 0;
}
```

<a id="518"></a>

### [518. 零钱兑换 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;

        for(int i = 0; i < coins.size(); i++)
            for(int j = coins[i]; j <= amount; j++)
                dp[j] += dp[j - coins[i]];

        return dp[amount];
    }
};
```

<a id="322"></a>

### [322. 零钱兑换](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;

        for(int i = 0; i < coins.size(); i++)
            for(int j = coins[i]; j <= amount; j++)
                if(dp[j - coins[i]] != INT_MAX)
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

        if(dp[amount] == INT_MAX) return -1;
        else return dp[amount];
    }
};

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;

        for(int i = 1; i <= amount; i++)
            for(int coin: coins)
                if(i - coin >= 0 && dp[i - coin] != INT_MAX)
                    dp[i] = min(dp[i - coin] + 1, dp[i]);

        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

<a id="279"></a>

### [279. 完全平方数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;

        for(int i = 0; i <= n; i++)
            for(int j = 1; j * j <= i; j++)
                dp[i] = min(dp[i - j * j] + 1, dp[i]);

        return dp[n];
    }
};
```

<a id="139"></a>

### [139. 单词拆分](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int i = 1; i <= s.size(); i++)
            for(int j = 0; j < i; j++)
            {
                string word = s.substr(j,i-j);
                if(wordSet.find(word) !=wordSet.end() && dp[j])
                    dp[i] = true;
            }

        return dp[s.size()];
    }
};
```

<a id="198"></a>

### [198. 打家劫舍](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];

        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }

        return dp[nums.size() - 1];
    }
};
```

<a id="213"></a>

### [213. 打家劫舍 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        int res1 = robRange(nums, 0, nums.size() - 2);
        int res2 = robRange(nums, 1, nums.size() - 1);
        return max(res1, res2);
    }
    int robRange(vector<int> nums, int left, int right)
    {
        if(left == right) return nums[left];

        vector<int> dp(nums.size());
        dp[left] = nums[left];
        dp[left + 1] = max(nums[left], nums[left + 1]);
        for(int i = left + 2; i <= right; i++)
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

        return dp[right];
    }
};
```

<a id="337"></a>

### [337. 打家劫舍 III](#TopicSummary)

```C++{.line-numbers}
//普通递归
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        return max(val1, val2);
    }
};

//记忆化递归
class Solution {
public:
    unordered_map<TreeNode*, int> umap;
    int rob(TreeNode* root) {
        if(root == NULL) return 0;
        if(root->left == NULL && root->right == NULL) return root->val;
        if(umap[root]) return umap[root];

        int val1 = root->val;
        if(root->left) val1 += rob(root->left->left) + rob(root->left->right);
        if(root->right) val1 += rob(root->right->left) + rob(root->right->right);

        int val2 = rob(root->left) + rob(root->right);
        umap[root] = max(val1, val2);
        return max(val1, val2);
    }
};

//动态规划递归
class Solution {
public:
    vector<int> robTree(TreeNode* root)
    {
        if(root == NULL) return vector<int>{0, 0};

        vector<int> left = robTree(root->left);
        vector<int> right = robTree(root->right);

        int val2 = root->val + left[0] + right[0];
        int val1 = max(left[0], left[1]) + max(right[0], right[1]);

        return {val1, val2};

    }
    int rob(TreeNode* root) {
        vector<int> res = robTree(root);
        return max(res[0], res[1]);
    }
};
```

<a id="121"></a>

### [121. 买卖股票的最佳时机](#shares-solution)

```C++{.line-numbers}
// 贪心：前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<int> dp(prices.size(), 0);
        int minValue = prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            minValue = min(minValue, prices[i]);
            dp[i] = max(dp[i - 1], prices[i] - minValue);
        }
        return dp[prices.size() - 1];
    }
};

// 动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;

        int dp0 = 0;            // 一直不买
        int dp1 = -prices[0];   // 只买了一次
        int dp2 = INT_MIN;      // 买了一次，卖了一次

        for(int i = 1; i < prices.size(); i++)
        {
            dp1 = max(dp1, dp0 - prices[i]);
            dp2 = max(dp2, dp1 + prices[i]);
        }
        return max(dp0, dp2);
    }
};

//动态规划，Carl的思路
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = 0;          //dp[i][0]代表第i天不持有股票
        dp[0][1] = -prices[0]; //dp[i][1]代表第i天持有股票
        for(int i = 1; i < prices.size(); i++)
        {
            //不持有股票：前一天持有股票今天卖出 / 前一天也没有股票
            dp[i][0] = max(dp[i - 1][1] + prices[i], dp[i - 1][0]);
            //持有股票：继续持有前一天持有的股票 / 重新持有今天的股票
            dp[i][1] = max(dp[i - 1][1], -prices[i]);
        }
        return dp[prices.size() - 1][0];
    }
};
//动态规划，Carl的思路，优化空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;

        int dp0 = 0;
        int dp1 = -prices[0];

        for(int i = 1; i < prices.size(); i++)
        {
            //下面两个语句的顺序要注意一下
            dp0 = max(dp0, dp1 + prices[i]);
            dp1 = max(dp1,  - prices[i]);
        }
        return max(dp0, dp1);
    }
};
```

<a id="122"></a>

### [122. 买卖股票的最佳时机 II](#shares-solution)

```C++{.line-numbers}
// 动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<int> dp(prices.size(), 0);
        for(int i = 1; i < prices.size(); i++)
        {
            dp[i] = max(dp[i - 1], dp[i - 1] + prices[i] - prices[i - 1]);
        }
        return dp[prices.size() - 1];
    }
};

//动态规划，优化空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        vector<int> dp(2, 0);
        for(int i = 1; i < prices.size(); i++)
        {
            dp[1] = max(dp[0], dp[0] + prices[i] - prices[i - 1]);
            dp[0] = dp[1];
        }
        return dp[1];
    }
};

//动态规划，Carl的思路，空间复杂度没有优化
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};

//动态规划，Carl的思路，优化空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2, 0));

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            dp[i % 2][0] = max(dp[(i-1)%2][0], dp[(i-1)%2][1]+prices[i]);
            dp[i % 2][1] = max(dp[(i-1)%2][1], dp[(i-1)%2][0]-prices[i]);
        }
        return dp[(prices.size()-1)%2][0];
    }
};

//动态规划，Carl的思路，优化空间复杂度另外一个版本
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<int> dp(2, 0);

        dp[0] = 0;
        dp[1] = -prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            dp[0] = max(dp[0], dp[1]+prices[i]);
            dp[1] = max(dp[1], dp[0]-prices[i]);
        }
        return dp[0];
    }
};
```

<a id="123"></a>

### [123. 买卖股票的最佳时机 III](#shares-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;
        for(int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};

//动态规划，压缩空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        vector<int> dp(5, 0);
        dp[0] = 0;
        dp[1] = -prices[0];
        dp[2] = 0;
        dp[3] = -prices[0];
        dp[4] = 0;
        for(int i = 1; i < prices.size(); i++)
        {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

<a id="188"></a>

### [188. 买卖股票的最佳时机 IV](#shares-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size()<=1) return 0;

        vector<vector<int>> dp(prices.size(), vector<int> (2 * k + 1, 0));
        for(int i = 1; i < 2 * k; i+=2)
            dp[0][i] = -prices[0];

        for(int i = 1; i < prices.size(); i++)
        {
            for (int j = 0; j < 2 * k - 1; j += 2)
            {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};

//动态规划，压缩空间复杂度
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size()<=1) return 0;

        vector<int> dp(2 * k + 1, 0);
        for(int i = 1; i < 2 * k; i+=2)
            dp[i] = -prices[0];

        for(int i = 1; i < prices.size(); i++)
        {
            for (int j = 0; j < 2 * k - 1; j += 2)
            {
                dp[j + 1] = max(dp[j + 1], dp[j] - prices[i]);
                dp[j + 2] = max(dp[j + 2], dp[j + 1] + prices[i]);
            }
        }
        return dp[2 * k];
    }
};
```

<a id="309"></a>

### [309. 最佳买卖股票时机含冷冻期](#shares-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        vector<vector<int>> dp(prices.size(), vector<int>(3, 0));
        dp[0][0] = -prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]);
            dp[i][2] = dp[i - 1][0] + prices[i];
        }
        return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);

    }
};
//动态规划，压缩空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;

        vector<int> dp(3, 0);
        dp[0] = -prices[0];
        for(int i = 1; i < prices.size(); i++)
        {
            dp[0] = max(dp[0], dp[1] - prices[i]);
            dp[1] = max(dp[1], dp[2]);
            dp[2] = dp[0] + prices[i];
        }
        return max(dp[1], dp[2]);

    }
};
```

<a id="714"></a>

### [714. 买卖股票的最佳时机含手续费](#shares-solution)

```C++{.line-numbers}
//贪心算法
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if(prices.size() == 0) return 0;

        int profit = 0;
        int buy = prices[0] + fee;
        for(int i = 1; i < prices.size(); i++)
        {
            if(prices[i] + fee < buy)
                buy = prices[i] + fee;
            else if(prices[i] > buy)
            {
                profit += prices[i] - buy;
                buy = prices[i];
            }
        }
        return profit;
    }
};

//动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = -prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};

//动态规划，压缩空间复杂度
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<int> dp(2, 0);
        dp[0] = -prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[0] = max(dp[0], dp[1] - prices[i]);
            dp[1] = max(dp[1], dp[0] + prices[i] - fee);
        }
        return max(dp[0], dp[1]);
    }
};
```

<a id="300"></a>

### [300. 最长递增子序列](#subsequence-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int size = nums.size();
        if(size == 0) return 0;
        if(size == 1) return 1;
        vector<int> dp(size, 1);

        int res = 1;
        for(int i = 1; i < size; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(nums[i] > nums[j])
                {
                    dp[i] = max(dp[j] + 1, dp[i]);
                }
            }
            if(dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```

<a id="674"></a>

### [674. 最长连续递增序列](#subsequence-solution)

```C++{.line-numbers}
//动态规划，空间复杂度较差
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size(), 1);

        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] <= nums[i - 1])
                dp[i] = 1;
            else
                dp[i] = dp[i - 1] + 1;
        }

        return *max_element(dp.begin(), dp.end());
    }
};

//优化动态规划的空间复杂度
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int dp[2] = {1, 1};

        int max = 1;
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] <= nums[i - 1])
            {
                dp[0] = 1;
            }
            else
            {
                dp[1] = dp[0] + 1;
                dp[0] = dp[1];
                if(dp[1] > max)
                    max = dp[1];
            }
        }

        return max;
    }
};

//贪心，和动态规划区别不大
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() == 0) return 0;

        int max = 1, count = 1;
        for(int i = 1; i < nums.size(); i++)
        {
            if(nums[i] <= nums[i - 1])
            {
                count = 1;
            }
            else
            {
                count++;
                if(count > max)
                    max = count;
            }
        }

        return max;
    }
};

//双指针
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.empty() || nums.size() == 1) {
            return nums.size();
        }

        int res = 1, tmp = 1;
        for(int i = 0, j = 1; j < nums.size(); i++, j++)
        {
            if(nums[j] > nums[i])
            {
                tmp++;
            }
            else
            {
                res = max(res, tmp);
                tmp = 1;
                i = j - 1;
            }
        }

        return max(res, tmp);
    }
};

//优化双指针写法
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.empty() || nums.size() == 1) {
            return nums.size();
        }

        int res = 1, tmp = 1;
        for(int i = 0, j = 1; j < nums.size(); i++, j++, tmp++)
        {
            if(nums[j] <= nums[i])
            {
                res = max(res, tmp);
                tmp = 0;
            }
        }

        return max(res, tmp);
    }
};
```

<a id="718"></a>

### [718. 最长重复子数组](#subsequence-solution)

```C++{.line-numbers}
//动态规划：二维dp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp(A.size()+ 1, vector<int>(B.size() + 1, 0));

        int res = 0;
        for(int i = 1; i <= A.size(); i++)
        {
            for(int j = 1; j <= B.size(); j++)
            {
                if(A[i - 1] == B[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if(dp[i][j] > res) res = dp[i][j];
            }
        }

        return res;
    }
};

//动态规划：一维dp，在二维的基础上使用了滚动数组
//顺序遍历
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        if(A.size() == 0 || B.size() == 0) return 0;

        vector<int> dp(B.size() + 1, 0);
        int res = 0;
        for(int i = 1; i <= A.size(); i++)
        {
            int pre = 0;
            for(int j = 1; j <= B.size(); j++)
            {
                int temp = dp[j];
                if(A[i - 1] == B[j - 1])
                {
                    dp[j] = pre + 1;
                }
                else
                    dp[j] = 0;
                res = max(res, dp[j]);
                pre = temp;
            }
        }

        return res;
    }
};
//逆序遍历
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<int> dp(B.size() + 1, 0);

        int res = 0;
        for(int i = 1; i <= A.size(); i++)
        {
            for(int j = B.size(); j > 0; j--)
            {
                if(A[i - 1] == B[j - 1])
                {
                    dp[j] = dp[j - 1] + 1;
                }
                else
                {
                    dp[j] = 0;
                }
                if(dp[j] > res) res = dp[j];
            }
        }

        return res;
    }
};
```

<a id="1143"></a>

### [1143. 最长公共子序列](#subsequence-solution)

```C++{.line-numbers}
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        if(text1.size() == 0 || text2.size() == 0) return 0;

        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for(int i = 1; i <= text1.size(); i++)
        {
            for(int j = 1; j <= text2.size(); j++)
            {
                if(text1[i - 1] == text2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[text1.size()][text2.size()];
    }
};

//状态压缩
//这里只考虑顺序遍历，因为涉及到三个参数
// dp[i - 1][j - 1]、dp[i - 1][j]、dp[i][j - 1]的选择
// 其中尤其是dp[i][j - 1]限制了只能顺序遍历，不能逆序遍历。
// 因为只有顺序遍历才能先求出dp[i][j - 1]
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        if(text1.size() == 0 || text2.size() == 0) return 0;

        vector<int> dp(text2.size() + 1, 0);
        for(int i = 1; i <= text1.size(); i++)
        {
            int pre = 0;
            for(int j = 1; j <= text2.size(); j++)
            {
                int temp = dp[j];
                if(text1[i - 1] == text2[j - 1])
                    dp[j] = pre + 1;
                else
                    dp[j] = max(dp[j], dp[j - 1]);
                pre = temp;
            }
        }
        return dp[text2.size()];
    }
};
```

<a id="1035"></a>

### [1035. 不相交的线](#subsequence-solution)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int maxUncrossedLines(vector<int>& A, vector<int>& B) {
        if(A.size() == 0 || B.size() == 0) return 0;
        vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));

        for(int i = 1; i <= A.size(); i++)
        {
            for(int j = 1; j <= B.size(); j++)
            {
                if(A[i - 1] == B[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else
                {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[A.size()][B.size()];
    }
};

//动态规划，状态压缩
class Solution {
public:
    int maxUncrossedLines(vector<int>& A, vector<int>& B) {
        if(A.size() == 0 || B.size() == 0) return 0;
        vector<int> dp(B.size() + 1, 0);

        for(int i = 1; i <= A.size(); i++)
        {
            int pre = 0;
            for(int j = 1; j <= B.size(); j++)
            {
                int tmp = dp[j];
                if(A[i - 1] == B[j - 1])
                {
                    dp[j] = pre + 1;
                }
                else
                {
                    dp[j] = max(dp[j], dp[j - 1]);
                }
                pre = tmp;
            }
        }

        return dp[B.size()];
    }
};
```

<a id="53"></a>

### [53. 最大子序和](#subsequence-solution)

```C++{.line-numbers}
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];

        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            res = max(dp[i], res);
        }

        return res;
    }
};

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];

        vector<int> dp(2, 0);
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.size(); i++)
        {
            dp[1] = max(dp[0] + nums[i], nums[i]);
            dp[0] = dp[1];
            res = max(dp[1], res);
        }

        return res;
    }
};
```

<a id="392"></a>

### [392. 判断子序列](#subsequence-solution)

```C++{.line-numbers}
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size()+1, 0));

        for(int i = 1; i <= s.size(); i++)
        {
            for(int j = 1; j <= t.size(); j++)
            {
                if(s[i-1] == t[j - 1])
                    dp[i][j] = dp[i - 1][j - 1]+1;
                else
                    dp[i][j] = dp[i][j - 1];
            }
        }
        if(dp[s.size()][t.size()]==s.size()) return true;
        return false;
    }
};

//双指针
class Solution {
public:
    bool isSubsequence(string s, string t) {

        int i = 0, j = 0;
        while(i < s.size() && j < t.size())
        {
            if(s[i] == t[j])
            {
                i++;
            }
            j++;
        }
        return i == s.size();
    }
};
```

<a id="10"></a>

### [10. 正则表达式匹配](#additional-questions)

```C++{.line-numbers}
//使用递归
class Solution
{
public:
    bool isMatch(string s, string p)
    {
        if (p.empty())
        {
            return s.empty();
        }
        if ('*' == p[1])
        {
            return isMatch(s, p.substr(2)) || (!s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p));
        }
        else
        {
            return !s.empty() && (s[0] == p[0] || '.' == p[0]) && (isMatch(s.substr(1), p.substr(1)));
        }
    }
};

//使用动态规划
```

<a id="91"></a>

### [91. 解码方法](#additional-questions)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        vector<int> dp(s.size() + 1);
        dp[0] = 1; dp[1] = 1;
        for (int i = 1; i < s.size(); i++) {
            if (s[i] == '0')//1.s[i]为0的情况
                if (s[i - 1] == '1' || s[i - 1] == '2') //s[i - 1]等于1或2的情况
                    dp[i + 1] = dp[i - 1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]
                else
                    return 0;
            else //2.s[i]不为0的情况
                if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))//s[i-1]s[i]两位数要小于26的情况
                    dp[i+1] = dp[i]+dp[i-1];
                else//其他情况
                    dp[i+1] = dp[i];
        }
        return dp[s.size()];
    }
};
// 其实dp[i]和上面的含义一样：代表前 i 个字符（0...i - 2, i - 1）的解码方案
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        vector<int> dp(s.size() + 1, 0);
        dp[0] = 1; dp[1] = 1;
        for(int i = 2; i <= s.size(); i++)
        {
            if(s[i - 1] == '0')
            {
                if(s[i - 2] == '1' || s[i - 2] == '2')
                    dp[i] = dp[i - 2];
                else
                    return 0;
            }
            else if(s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6'))
                dp[i] = dp[i - 2] + dp[i - 1];
            else
                dp[i] = dp[i - 1];
        }

        return dp[s.size()];
    }
};

//动态规划，压缩空间复杂度
class Solution {
public:
    int numDecodings(string s) {
        if (s[0] == '0') return 0;
        int pre = 1, curr = 1;//dp[-1] = dp[0] = 1
        for (int i = 1; i < s.size(); i++) {
            int tmp = curr;
            if (s[i] == '0')
                if (s[i - 1] == '1' || s[i - 1] == '2') curr = pre;
                else return 0;
            else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))
                curr = curr + pre;
            pre = tmp;
        }
        return curr;
    }
};
```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];

        vector<int> dpMax(nums.size(), 0);
        vector<int> dpMin(nums.size(), 0);
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            dpMax[i] = max(dpMax[i - 1] * nums[i], max(nums[i], dpMin[i - 1] * nums[i]));
            dpMin[i] = min(dpMax[i - 1] * nums[i], min(nums[i], dpMin[i - 1] * nums[i]));
        }

        return *max_element(dpMax.begin(), dpMax.end());
    }
};

//动态规划，压缩空间复杂度
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];

        int dpMax = nums[0];
        int dpMin = nums[0];
        int res = nums[0];
        for(int i = 1; i < nums.size(); i++)
        {
            int mi = dpMin;
            int mx = dpMax;
            dpMax = max(mx * nums[i], max(nums[i], mi * nums[i]));
            dpMin = min(mx * nums[i], min(nums[i], mi * nums[i]));
            res = max(res, dpMax);
        }

        return res;
    }
};
```

<a id="46"></a>

### [46. 把数字翻译成字符串](#UnderstandingRepetitiveSubproblems)

```C++{.line-numbers}
class Solution {
public:
    int translateNum(int num) {
        int dp1 = 1;
        int dp2 = 1;
        int dp3 = 1;
        while(num != 0)
        {
            if(10 <= num % 100 && num % 100 <= 25)
                dp3 = dp1 + dp2;
            else
                dp3 = dp2;
            dp1 = dp2;
            dp2 = dp3;
            num = num / 10;
        }

        return dp3;
    }
};
```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```

<a id="152"></a>

### [152. 乘积最大子数组](#additional-questions)

```C++{.line-numbers}

```
