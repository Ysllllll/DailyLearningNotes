<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >
</p>

> 又是一波总结

相信大家已经对双指针法很熟悉了，但是双指针法并不隶属于某一种数据结构，我们在讲解数组，链表，字符串都用到了双指针法，所有有必要针对双指针法做一个总结。

# 数组篇

在[数组：就移除个元素很难么？](https://mp.weixin.qq.com/s/wj0T-Xs88_FHJFwayElQlA)中，原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。

一些同学可能会写出如下代码（伪代码）：

```C++{.line-numbers}
for (int i = 0; i < array.size(); i++) {
    if (array[i] == target) {
        array.erase(i);
    }
}
```

这个代码看上去好像是 O(n)的时间复杂度，其实是 O(n^2)的时间复杂度，因为 erase 操作也是 O(n)的操作。

所以此时使用双指针法才展现出效率的优势：**通过两个指针在一个 for 循环下完成两个 for 循环的工作。**

# 字符串篇

在[字符串：这道题目，使用库函数一行代码搞定](https://mp.weixin.qq.com/s/X02S61WCYiCEhaik6VUpFA)中讲解了反转字符串，注意这里强调要原地反转，要不然就失去了题目的意义。

使用双指针法，**定义两个指针（也可以说是索引下表），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。**，时间复杂度是 O(n)。

在[替换空格](https://mp.weixin.qq.com/s/t0A9C44zgM-RysAQV3GZpg) 中介绍使用双指针填充字符串的方法，如果想把这道题目做到极致，就不要只用额外的辅助空间了！

思路就是**首先扩充数组到每个空格替换成"%20"之后的大小。然后双指针从后向前替换空格。**

有同学问了，为什么要从后向前填充，从前向后填充不行么？

从前向后填充就是 O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组（字符串）填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

那么在[字符串：花式反转还不够！](https://mp.weixin.qq.com/s/X3qpi2v5RSp08mO-W5Vicw)中，我们使用双指针法，用 O(n)的时间复杂度完成字符串删除类的操作，因为题目要产出冗余空格。

**在删除冗余空格的过程中，如果不注意代码效率，很容易写成了 O(n^2)的时间复杂度。其实使用双指针法 O(n)就可以搞定。**

**主要还是大家用 erase 用的比较随意，一定要注意 for 循环下用 erase 的情况，一般可以用双指针写效率更高！**

# 链表篇

翻转链表是现场面试，白纸写代码的好题，考察了候选者对链表以及指针的熟悉程度，而且代码也不长，适合在白纸上写。

在[链表：听说过两天反转链表又写不出来了？](https://mp.weixin.qq.com/s/pnvVP-0ZM7epB8y3w_Njwg)中，讲如何使用双指针法来翻转链表，**只需要改变链表的 next 指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。**

思路还是很简单的，代码也不长，但是想在白纸上一次性写出 bugfree 的代码，并不是容易的事情。另外这道题扩展开来，就是链表对折，可以参考[重排链表](https://leetcode-cn.com/problems/reorder-list)

在链表中求环，应该是双指针在链表里最经典的应用，在[链表：环找到了，那入口呢？](https://mp.weixin.qq.com/s/_QVP3IkRZWx9zIpQRgajzA)中讲解了如何通过双指针判断是否有环，而且还要找到环的入口。

**使用快慢指针（双指针法），分别定义 fast 和 slow 指针，从头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow 指针在途中相遇 ，说明这个链表有环。**

那么找到环的入口，其实需要点简单的数学推理，我在文章中把找环的入口清清楚楚的推理的一遍，如果对找环入口不够清楚的同学建议自己看一看[链表：环找到了，那入口呢？](https://mp.weixin.qq.com/s/_QVP3IkRZWx9zIpQRgajzA)。

# N 数之和篇

在[哈希表：解决了两数之和，那么能解决三数之和么？](https://mp.weixin.qq.com/s/r5cgZFu0tv4grBAexdcd8A)中，讲到使用哈希法可以解决 1.两数之和的问题

其实使用双指针也可以解决 1.两数之和的问题，只不过 1.两数之和求的是两个元素的下标，没法用双指针，如果改成求具体两个元素的数值就可以了，大家可以尝试用双指针做一个 leetcode 上两数之和的题目，就可以体会到我说的意思了。

使用了哈希法解决了两数之和，但是哈希法并不使用于三数之和！

使用哈希法的过程中要把符合条件的三元组放进 vector 中，然后在去去重，这样是非常费时的，很容易超时，也是三数之和通过率如此之低的根源所在。

去重的过程不好处理，有很多小细节，如果在面试中很难想到位。

时间复杂度可以做到 O(n^2)，但还是比较费时的，因为不好做剪枝操作。

所以这道题目使用双指针法才是最为合适的，用双指针做这道题目才能就能真正体会到，**通过前后两个指针不停向中间逼近，在一个 for 循环下完成两个 for 循环的工作。**

只用双指针法时间复杂度为 O(n^2)，但比哈希法的 O(n^2)效率高得多，哈希法在使用两层 for 循环的时候，能做的剪枝操作很有限。

在[双指针法：一样的道理，能解决四数之和](https://mp.weixin.qq.com/s/nQrcco8AZJV1pAOVjeIU_g)中，讲到了四数之和，其实思路是一样的，**在三数之和的基础上再套一层 for 循环，依然是使用双指针法。**

对于三数之和使用双指针法就是将原本暴力 O(n^3)的解法，降为 O(n^2)的解法，四数之和的双指针解法就是将原本暴力 O(n^4)的解法，降为 O(n^3)的解法。

同样的道理，五数之和，n 数之和都是在这个基础上累加。

# 总结

本文中一共介绍了 leetcode 上九道使用双指针解决问题的经典题目，除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将 O(n^2)的时间复杂度，降为 O(n)。

建议大家可以把文中涉及到的题目再好好做一做，琢磨琢磨，基本对双指针法就不在话下了。

### 滑动窗口和双指针区别

- 应用「滑动窗口」的问题，两个变量同向移动
- 应用「双指针」的问题，两个变量一头一尾，向着中间移动

### 解题思路

- 对于绝大多数「滑动窗口」问题，一般而言，都需要先思考暴力解法，进而思考暴力解法是不是有可以优化的地方。「暴力解法」通常以「二重循环」、「三重循环」的形式出现，优化的思路有：
  - 以空间换时间：在遍历的过程中，记录变量的值，以使得每一次不同规模的区间的相关信息的计算不必从头开始；
  - 利用题目给出的性质，在枚举的过程中，能够一下子 排除很多不必要的方案 ，以降低时间复杂度。

<a id="TopicSummary"></a>

> **题目汇总**
>
> - <font size=4>**循环不变量【单数组】**</font>
>
>   - **[Leetcode 26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)** [速览题解](#26)
>     - 简评：定义循环不变量 `[0, end]` 为有效区间
>   - **[Leetcode 80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)** [速览题解](#80)
>     - 简评：定义循环不变量 `[0, end]` 为有效区间，相比于上一道题，这道题允许每个元素至多重复一次，添加一个 `count` 变量记录重复了几次
>   - **[Leetcode 674. 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)** [速览题解](#674)
>     - 简评：定义循环不变量 `[left, right]` 或 `[left, right)` 为有效的连续递增区间
>   - **[Leetcode 27. 移除元素](https://leetcode-cn.com/problems/remove-element/)** [速览题解](#27)
>     - 简评：定义循环不变量 `[0, left)` 为有效的非零区间，从尾开始收集val元素`right = nums.size() - 1`。将有效的元素（非val）移动到数组的前面，但是**可以改变**非val元素在数组中的**相对位置关系**
>   - **[Leetcode 283. 移动零](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)** [速览题解](#283)
>     - 简评：定义循环不变量 `[0, left)` 为有效的非val区间， 从头开始移动元素 `right = 0`。将有效的元素（非零）移动到数组的前面，**不能改变**非零元素在数组中的**相对位置关系**。如果将空间复杂度要求降低，上面的两道题就非常简单了
>   - **[Leetcode . 快速排序中的partion()](2)** [速览题解](#2)
>     - 简评：**移除元素**和**移动零**都是将特定的元素移动到数组的前端。
> - <font size=4>**滑动窗口【单数组—定长度】**</font>
>
>    > [参考文章：我写了套框架，把滑动窗口算法变成了默写题](https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA)
>    >熟悉了滑窗的模板后，不妨思考下面几个问题（评论区给答案）：
>    >1 为什么模板中的内层while有时可以优化为if
>    >2 为什么有时可以不维护res的值，而直接返回len-L或者R-L
>    >3 当题目要求的不是“符合条件的窗口的最大值”，而是“符合条件的窗口的最小值”，模板如何修改
>
>   - **[Leetcode 643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)** [速览题解](#643)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)** [速览题解](#1052)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)** [速览题解](#1423)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 1456. 定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)** [速览题解](#1456)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 1658. 将 x 减到 0 的最小操作数](https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/)** [速览题解](#1658)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>
> - <font size=4>**滑动窗口【单数组—变长度】**</font>
>
>   > [参考文章：我写了套框架，把滑动窗口算法变成了默写题](https://mp.weixin.qq.com/s/ioKXTMZufDECBUwRRp3zaA)
>
>   - **[Leetcode 3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)** [速览题解](#3)
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)** [速览题解](#424)
>     - 简评：模板题
>   - **[Leetcode 209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)** [速览题解](#209)
>     - 简评：模板题
>   - **[Leetcode 1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)** [速览题解](#1004)
>     - 简评：模板题
>   - **[Leetcode 1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)** [速览题解](#1208)
>     - 简评：模板题
>   - **[Leetcode 1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)** [速览题解](#1493)
>     - 简评：模板题
>   - **[Leetcode 978. 最长湍流子数组](https://leetcode-cn.com/problems/longest-turbulent-subarray/)** [速览题解](#978)
>     - 简评：模板题
>   - **[Leetcode 995. K 连续位的最小翻转次数](https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/)** [速览题解](#995)
>     - 简评：模板题
> - <font size=4>**滑动窗口【双数组】**</font>
>
>   - **[Leetcode 76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)** [速览题解](#76)
>     - 简评：操作两个字符串，模板题
>   - **[Leetcode 438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)** [速览题解](#438)
>     - 简评：操作两个字符串，模板题
>   - **[Leetcode 567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)** [速览题解](#567)
>     - 简评：操作两个字符串，模板题
> - <font size=4>**滑动窗口【计数问题】**</font>
>   - **[Leetcode 159. 至多包含两个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)** [速览题解](#159)
>   - **[Leetcode 340. 至多包含 K 个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)** [速览题解](#340)
>   - **[Leetcode 795. 区间子数组个数](https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/)** [速览题解](#795)
>   - **[Leetcode 992. K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers/)** [速览题解](#992)
>   - **[Leetcode 719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)** [速览题解](#719)
>
> - <font size=4>**滑动窗口【设计数据结构】**</font>
>
>   - **[Leetcode 239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/solution/)** [速览题解](#239)<a id="l239"></a>
>     - 简评：需要设计一个**单调递增队列**，注意入队条件是新元素比窗口内的元素大时入队，出队条件是队头元素不在窗口内时。这道题的另外一个启发是：**可以设计一个单调递增的 `class` 来解题**
>     简评：关键在单调队列中压入的是值还是对应的下标，两种方式都能实现，压入下标的更加简洁一点。**这道题的时间复杂度是 O(n)，因为每个元素最多入队出队一次**。单调队列 deque 占用 O(2n)，遍历 nums 数组为 O(n)，所以最后的时间复杂度就是 O(n)。所使用的数据结构 deque 不是严格连续分布的
>   - **[Leetcode 480. 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)** [速览题解](#480)<a id="l480"></a>
>     简评：这道题的重点 `minHeap` 和 `maxHeap` 在 `shiftUp` 和 `shiftDown` 两个操作上
>   - **[Leetcode 220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)** [速览题解](#220)<a id="l220"></a>
>     简评：这道题的重点 `minHeap` 和 `maxHeap` 在 `shiftUp` 和 `shiftDown` 两个操作上
>   - **[Leetcode 1438. 绝对差不超过限制的最长连续子数组](https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)** [速览题解](#1438)<a id="l438"></a>
>     简评：这道题的重点 `minHeap` 和 `maxHeap` 在 `shiftUp` 和 `shiftDown` 两个操作上
>
>
> - <font size=4>**双指针【单数组—n数之和】**</font>
>
>   - **[☆Leetcode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/)** [速览题解](#1)
>     - 简评：这道题不能用双指针法，因为双指针要求数组排序，但是我们数组排序后下标就变了。另外注意哈希碰撞，虽然这里哈希碰撞没有影响
>   - **[Leetcode 167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)** [速览题解](#167)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - **不去重：求满足的一对下标即可**
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 1099. 小于 K 的两数之和](https://leetcode-cn.com/problems/two-sum-less-than-k/)** [速览题解](#1099)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - **不去重：求小于k的最大和**
>     - 简评：双指针，这道题注意是否要去重
>   - **[Leetcode 15. 三数之和](https://leetcode-cn.com/problems/3sum/)** [速览题解](#15)
>     - **指针类型：双端指针`left = i + 1; right = nums.size() - 1;`**
>     - **去重：需要对 "结果集" 去重**
>     - 简评：这道题与下标无关，所以可以排序。然后固定一边，剩下的变换成求**两数之和**的问题，注意当 nums[i]>0 后可以直接返回了，另外要注意去重
>   - **[Leetcode 16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/submissions/)** [速览题解](#16)
>     - **指针类型：双端指针`left = i + 1; right = nums.size() - 1;`**
>     - **不去重：只求最接近的三数和**
>     - 简评：关键点在于如何定义窗口内的元素不重复
>   - **[Leetcode 259. 较小的三数之和](https://leetcode-cn.com/problems/3sum-smaller/)** [速览题解](#259)
>     - **指针类型：双端指针`left = i + 1; right = nums.size() - 1;`**
>     - **不去重：求所有组合的数量**
>     - 简评：双指针，这道题注意是否要去重
>   - **[Leetcode 18. 四数之和](https://leetcode-cn.com/problems/4sum/)** [速览题解](#18)
>     - **指针类型：双端指针`left = i + 1; right = nums.size() - 1;`**
>     - **去重：需要对 "结果集" 去重**
>     - 简评：三数之和的基础上再套一层循环，但是要注意剪枝！！如何剪枝参考第二种代码
>     - **总评**：1. 注意 target 为一个负得更小的值时，不能单纯的用 nums[i] > target 来剪枝。2. 将问题逐渐简化为**两数之和**，变为两数之和后，由于有序，就是一个简单的**双指针问题**。**但是为什么这里第一题不用双指针呢？**，因为它要的是下标，没办法对数组排序
> - <font size=4>**双指针【单数组—简单双端指针】**</font>
>
>   - **[Leetcode 344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)** [速览题解](#344)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：简单双指针
>   - **[Leetcode 345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)** [速览题解](#345)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：简单双指针
>   - **[Leetcode 125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)** [速览题解](#125)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：简单双指针
>   - **[Leetcode 42. 接雨水](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)** [速览题解](#42)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：双指针，木桶原理。这道题还有单调栈、动态规划解法
>   - **[Leetcode 11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)** [速览题解](#11)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：双指针，木桶原理
>   - **[Leetcode 977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)** [速览题解](#977)
>     - **指针类型：双端指针`left = 0; right = nums.size() - 1;`**
>     - 简评：这道题我们想要的是绝对值有序。可以比较两端的绝对值大小来得到一个绝对值有序的数组。需要添加一个数组来存放结果。**这道题和88题一样，合并两个有序数组**
>   - **[☆Leetcode 845. 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)** [速览题解](#845)
>     - 简评：可以用中心扩展法，相对于双指针法，空间复杂度比较高。同时这里不是**双端双指针**，而是有**先后走顺序的双指针**
> - <font size=4>**双指针【双数组—单端指针】**</font>
>
>   - **[Leetcode 844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)** [速览题解](#844)
>     - 简评：操作两个字符串，双指针，木桶原理
>   - **[Leetcode 88. 合并两个有序数组](https://leetcode-cn.com/problems/4sum/)** [速览题解](#88)
>     - 简评：和977题一样，变化不大，三个指针倒序合并。其它思路就是先合并再排序，但是时间复杂度不好
>

---

<a id="26"></a>

### [Leetcode 26. 删除有序数组中的重复项](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();

        int end = 0;//[0, end]无重复
        int left = 1;

        while(left < nums.size())
        {
            if(nums[end] != nums[left])
            {
                end++;
                nums[end] = nums[left];
            }
            left++;
        }

        return end + 1;
    }
};
```

<a id="80"></a>

### [Leetcode 80. 删除有序数组中的重复项 II](#TopicSummary)

```C++{.line-numbers}
// 不建议使用下面的写法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 2) return nums.size();

        int end = 0; // [0, end] 为合格区间
        int left = 1; // [left, ...] 为待检测区间
        int count = 1;

        while(left < nums.size())
        {
            if(nums[end] != nums[left])
            {
                end++;
                nums[end] = nums[left];
                count = 1;
            }
            else if(nums[end] == nums[left] && count == 1)
            {
                end++;
                nums[end] = nums[left];
                count--;
            }    
            left++;
        }

        return end + 1;
    }
};

// 可扩展的写法
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 2) return nums.size();

        int pivot = 1;
        for(int i = 2; i < nums.size(); i++)
        {
            if(nums[i] != nums[pivot - 1])
                swap(nums[++pivot], nums[i]);
        }

        return pivot + 1;
    }
};
// 允许重复 repeat 个
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() <= 2) return nums.size();

        int repeat = 2;

        int pivot = repeat - 1;
        for(int i = repeat; i < nums.size(); i++)
        {
            if(nums[i] != nums[pivot - repeat + 1])
                swap(nums[++pivot], nums[i]);
        }

        return pivot + 1;
    }
};
```

<a id="674"></a>

### [Leetcode 674. 最长连续递增序列](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();

        int ret = 1;
        // 注意 left 和 right 初始化的时候，各自的空间要组成一个完整的空间
        int left = 0, right = 0; // 最长的连续递增子序列[left, right]

        while(right < nums.size())
        {
            // 这里注意，right作为迭代指针，好像定义为[left,right)会更加合理一点，
            // 因为如果nums[right]满足，就right++，判断下一个nums[right]
            // 但是这里如果不满足，我们会收缩left，实际上也是满足[left, right]递增的
            // 当然这是自圆其说的一种说话，还是推荐[left, right)
            if(right > 0 && nums[right] <= nums[right - 1])
            {
                left = right;
            }
            ret = max(ret, right - left + 1);
            right++;
        }

        return ret;
    }
};

class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() <= 1) return nums.size();

        int ret = 1;
        // 注意 left 和 right 初始化的时候，各自的空间要组成一个完整的空间
        int left = 0, right = 1; // 最长的连续递增子序列[left, right)

        while(right < nums.size())
        {
            if(right > 0 && nums[right] <= nums[right - 1])
            {
                left = right;
            }
            right++;
            ret = max(ret, right - left);
        }

        return ret;
    }
};
```

<a id="27"></a>

### [Leetcode 27. 移除元素](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size() == 0) return 0;
        
        int right = nums.size() - 1; // (right, end] 为 val 区间
        int left = 0; // [0, left) 为不含 val 的区间

        // 注意 left 和 right 初始化的时候，各自的空间要组成一个完整的空间
        while(left <= right) // 跳出循环时有left = right + 1，构成[0, end]
        {
            while(left <= right && nums[right] == val)
                right--;
            while(left <= right && nums[left] != val)
                left++;
            if(left <= right)
                swap(nums[left], nums[right]);
        }

        return left;
    }
};
```

<a id="283"></a>

### [Leetcode 283. 移动零](#TopicSummary)

```C++{.line-numbers}

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.size() <= 1) return;

        // [0, pivot) 全为非零区间
        // [i, end] 全为待检查区间
        int pivot = 0;
        for(int i = 0; i < nums.size(); i++)
            if(nums[i] != 0)
                nums[pivot++] = nums[i];
        for(int i = pivot; i< nums.size(); i++)
            nums[i] = 0;
    }
};

// 如果不要求保持非零元素的相对顺序
// partition的写法
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.size() <= 1) return;

        int pivot = 0;
        for(int i = 1; i < nums.size(); i++)
            if(nums[i] != 0)
                swap(nums[i], nums[pivot++]);
    }
};
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if(nums.size() <= 1) return;

        int pivot = 0;
        for(int i = 1; i < nums.size(); i++)
            if(nums[i] != 0)
                swap(nums[i], nums[++pivot]);
        swap(nums[0], nums[pivot]);
    }
};
```

<a id="643"></a>

### [Leetcode 643. 子数组最大平均数 I](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        if(nums.size() < k) return 0;

        long window = 0;
        int left = 0, right = 0;
        double ret = -DBL_MAX;
        while(right < nums.size())
        {
            int num1 = nums[right];
            right++;
            
            window += num1;

            while(right - left >= k)
            {
                ret = max(ret, (double)window / k);

                int num2 = nums[left];
                left++;
                window -= num2;
            }
        }

        return ret;
    }
};
```

<a id="1052"></a>

### [Leetcode 1052. 爱生气的书店老板](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {

        int res = 0, ext = 0, window = 0;
        int left = 0;
        int right = 0;

        while(right < customers.size())
        {
            res += (1 - grumpy[right]) * customers[right];

            window += grumpy[right] * customers[right];
            right++;

            while(right - left >= minutes)
            {
                ext = max(ext, window);
                window -= grumpy[left] * customers[left];
                left++;
            }
        }

        return res + ext;
    }
};
```

<a id="1423"></a>

### [Leetcode 1423. 可获得的最大点数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        if(cardPoints.size() < k) return 0;

        int sum = accumulate(cardPoints.begin(), cardPoints.end(), 0);
        if(k == cardPoints.size()) return sum;
        
        int left = 0;
        int right = 0;
        int ret = INT_MAX, window = 0;
        while(right < cardPoints.size())
        {
            window += cardPoints[right];
            right++;

            while(right - left >= cardPoints.size() - k)
            {
                ret = min(ret, window);
                window -= cardPoints[left];
                left++;
            }
        }

        return sum - ret;
    }
};
```

<a id="1456"></a>

### [Leetcode 1456. 定长子串中元音的最大数目](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool isVowel(const char c)
    {
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')
            return true;
        else
            return false;
    }
    int maxVowels(string s, int k) {
        int ret = INT_MIN;
        int window = 0;

        int left = 0;
        int right = 0;

        while(right < s.size())
        {
            window += isVowel(s[right]);
            right++;

            while(right - left >= k)
            {
                ret = max(ret, window);
                window -= isVowel(s[left]);
                left++;
            }
        }
        return ret;
    }
};
```

<a id="1658"></a>

### [Leetcode 1658. 将 x 减到 0 的最小操作数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(x > sum) return -1;
        if(x == sum) return nums.size();

        int left = 0;
        int right = 0;
        int window = 0;
        int ret = INT_MAX;

        while(right < nums.size())
        {
            window += nums[right];
            right++;

            while(window >= sum - x)
            {
                if(window == sum - x)
                    ret = min(ret, (int)(nums.size() - right + left));

                window -= nums[left];
                left++;
            }
        }

        return ret == INT_MAX ? -1: ret;
    }
};
```

<a id="3"></a>

### [Leetcode 3. 无重复字符的最长子串](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;

        vector<int> index(128, -1);
        // [left, right) 是无重复的子区间
        int left =0, res = 0;
        for(int right = 0; right < s.size(); right++)
        {
            // 用于判断当前 right 是否重复
            // 重复则移动 left 指针
            if(index[s[right]] != -1)
                left = max(left, index[s[right]] + 1);

            // 将 nums[right] 纳入到 无重复区间中
            index[s[right]] = right;
            res = max(res, right - left + 1);
        }

        return res;
    }
};

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;

        int left = 0, right = 0;
        int res = 0; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            window[c]++;
            // 判断左侧窗口是否要收缩
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                window[d]--;
            }
            // 在这里更新答案
            res = max(res, right - left);
        }
        return res;
    }
};

//
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, r = 0;
        int maxlen = 0;

        for( ; r<s.size(); r++)
        {
            for(int k = l; k < r; k++)
            {
                if(s[r] == s[k])
                {
                    l = k + 1;
                    break;
                }
            }
            if(r - l + 1 > maxlen)
            {
                maxlen = r - l + 1;
            }
        }
        return maxlen;
    }
};

//
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> m(128, 0);
        int ans = 0;
        int i = 0;
        for (int j = 0; j < s.size(); j++) {
            i = max(i, m[s[j]]);
            m[s[j]] = j + 1;
            ans = max(ans, j - i + 1);
        }
        return ans;
    }
};

// 动态规划
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;

        vector<int> dp(s.size(), 0);
        dp[0] = 1;
        for(int i = 1; i < s.size(); i++)
        {
            int j = i - 1;
            for(; (j >= 0) && (s[i] != s[j]); j--);
            dp[i] = min(dp[i - 1] + 1, i - j);
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```

<a id="76"></a>

### [Leetcode 76. 最小覆盖子串](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        // 记录最小覆盖子串的起始索引及长度
        int start = 0, len = INT_MAX;
        while (right < s.size()) {
            // c 是将移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }

            // 判断左侧窗口是否要收缩
            while (valid == need.size()) {
                // 在这里更新最小覆盖子串
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d 是将移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // 返回最小覆盖子串
        return len == INT_MAX ?
            "" : s.substr(start, len);
    }
};
```

<a id="209"></a>

### [Leetcode 209. 长度最小的子数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0, sum = 0, res = INT_MAX;

        while(right < nums.size())
        {
            int numR = nums[right];
            right++;

            sum = sum + numR;

            while(sum >= target)
            {
                if(right - left < res)
                    res = right - left;

                int numL = nums[left];
                left++;

                sum = sum - numL;
            }
        }

        return res == INT_MAX? 0: res;
    }
};
```

<a id="1004"></a>

### [Leetcode 1004. 最大连续1的个数 III](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int window = 0;
        int left = 0;
        int right = 0;
        int ret = 0;

        while(right < nums.size())
        {
            if(nums[right] == 0)
                window++;
            right++;

            if(window > k)
            {
                if(nums[left] == 0)
                    window--;
                left++;
            }
            ret = max(ret, right - left); // 注意这里的判断应该放在哪里
        }
        
        return ret;
    }
};
```

<a id="1208"></a>

### [Leetcode 1208. 尽可能使字符串相等](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        int left = 0, right = 0, ret = 0;

        while(right < s.size())
        {
            maxCost -= abs(s[right] - t[right]);
            right++;

            while(maxCost < 0)
            {
                maxCost += abs(s[left] - t[left]);
                left++;
            }

            ret = max(right - left, ret);
        }
        return ret;
    }
};
```

<a id="1493"></a>

### [Leetcode 1493. 删掉一个元素以后全为 1 的最长子数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int ret = 0;
        int left = 0, right = 0, window = 0;

        while(right < nums.size())
        {
            if(nums[right] == 0)
                window++;
            right++;

            while(window > 1)
            {
                if(nums[left] == 0)
                    window--;
                left++;
            }
            ret = max(ret, right - left);
        }

        return ret - 1;
    }
};
```

<a id="978"></a>

### [Leetcode 978. 最长湍流子数组](#TopicSummary)

```C++{.line-numbers}

```

<a id="995"></a>

### [Leetcode 995. K 连续位的最小翻转次数](#TopicSummary)

```C++{.line-numbers}

```

<a id="438"></a>

### [Leetcode 438. 找到字符串中所有字母异位词](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        int left = 0, right = 0, valid = 0;
        unordered_map<char, int> windows, needs;
        for(char c : p) needs[c]++;//在s里找p
        while(right < s.size())
        {
            char ch = s[right];
            right++;
            if(needs.count(ch))//是需要的字母
            {
                windows[ch]++;
                if(windows[ch] == needs[ch])
                    valid++;
            }
            while(valid == needs.size())//窗口字母个数符合
            {
                if(right - left == p.size())//窗口大小也符合就说明完全符合
                    res.push_back(left);//left就是窗口的起点加入到结果中
                char ch = s[left];
                left++;
                if(needs.count(ch))
                {
                    if(windows[ch] == needs[ch])
                        valid--;
                    windows[ch]--;
                }
            }
        }
        return res;
    }
};
```

<a id="567"></a>

### [Leetcode 567. 字符串的排列](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool checkInclusion(string p, string s) {
        vector<int> res;
        int left = 0, right = 0, valid = 0;
        unordered_map<char, int> windows, needs;
        for(char c : p) needs[c]++;//在s里找p
        while(right < s.size())
        {
            char ch = s[right];
            right++;
            if(needs.count(ch))//是需要的字母
            {
                windows[ch]++;
                if(windows[ch] == needs[ch])
                    valid++;
            }
            while(valid == needs.size())//窗口字母个数符合
            {
                if(right - left == p.size())//窗口大小也符合就说明完全符合
                    return true;
                char ch = s[left];
                left++;
                if(needs.count(ch))
                {
                    if(windows[ch] == needs[ch])
                        valid--;
                    windows[ch]--;
                }
            }
        }
        return false;
    }
};
```

<a id="424"></a>

### [Leetcode 424. 替换后的最长重复字符](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int characterReplacement(string s, int k) {
        unordered_map<char, int> window;

        int maxCount = INT_MIN;
        int left = 0, right = 0;
        while(right < s.size())
        {
            char ch = s[right];
            right++;

            window[ch]++;
            // 只大不小
            maxCount = max(maxCount, window[ch]);

            while(right - left - maxCount > k)
            {
                char ch = s[left];
                left++;

                window[ch]--;
            }
        }

        return right - left;
    }
};
```

<a id="1438"></a>

### [1438. 绝对差不超过限制的最长连续子数组](#longest)

```C++{.line-numbers}
class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
        deque<int> queMax, queMin;
        int n = nums.size();
        int left = 0, right = 0;
        int ret = 0;
        while (right < n) {
            while (!queMax.empty() && queMax.back() < nums[right]) {
                queMax.pop_back();
            }
            while (!queMin.empty() && queMin.back() > nums[right]) {
                queMin.pop_back();
            }
            queMax.push_back(nums[right]);
            queMin.push_back(nums[right]);
            while (!queMax.empty() && !queMin.empty() && queMax.front() - queMin.front() > limit) {
                if (nums[left] == queMin.front()) {
                    queMin.pop_front();
                }
                if (nums[left] == queMax.front()) {
                    queMax.pop_front();
                }
                left++;
            }
            ret = max(ret, right - left + 1);
            right++;
        }
        return ret;
    }
};

class Solution {
public:

    //解法二：使用双指针构造滑动窗口。使用单调队列计算窗口内任意两元素的绝对差的最大值，若该最大值大于 limit 则将窗口左端右移一位，否则将窗口右端右移一位；满足要求的滑动窗口的最大长度即为所求。
    int longestSubarray(vector<int>& nums, int limit)
    {
        deque<int> maxQueue; //最大值队列。存储可能成为滑动窗最大值的元素值。单调减
        deque<int> minQueue; //最小值队列。存储可能成为滑动窗最小值的元素值。单调增
        int n = nums.size();
        int windowRight = 0;
        int windowLeft = 0;
        int maxLength = 0;
        int currentLength;

        //以 [windowLeft,windowRight] 为滑动窗口
        while (windowRight < n)
        {
            while (!maxQueue.empty() && nums[windowRight] > maxQueue.back())
                maxQueue.pop_back(); //这些元素值已不可能成为滑动窗口的最大值
            while (!minQueue.empty() && nums[windowRight] < minQueue.back())
                minQueue.pop_back(); //这些元素值已不可能成为滑动窗口的最小值

            maxQueue.push_back(nums[windowRight]);
            minQueue.push_back(nums[windowRight]);

            //找到以 windowRight 为右端点的满足要求的最长子数组
            while (maxQueue.front()- minQueue.front() > limit) //不断移出子数组左端的元素
            {
                if (nums[windowLeft] == maxQueue.front()) //移出的是原窗口的最大值
                    maxQueue.pop_front();
                if (nums[windowLeft] == minQueue.front()) //移出的是原窗口的最小值
                    minQueue.pop_front();
                windowLeft++;
            }
            currentLength = windowRight - windowLeft + 1;
            maxLength = maxLength > currentLength ? maxLength : currentLength;
            windowRight++;
        }
        return maxLength;
    }
};
```

<a id="1"></a>

### [1. 两数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for(int i = 0; i < nums.size(); i++)
        {
            if(mp.find(target - nums[i]) != mp.end())
                return {i, mp[target - nums[i]]};
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

<a id="15"></a>

### [15. 三数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 已经排好序了，如果首个都大于0，left-right一定大于0
            // 这样剪枝可能出现的问题参考 "四数之和"
            if (nums[i] > 0)
            {
                return result;
            }

            // 注意去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
               if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});

                    //这里尤其注意
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

<a id="18"></a>

### [18. 四数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if(nums.size() < 4) return {};

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int left = 0, right = 0;
        long sum = 0;
        for(int i = 0; i < nums.size() - 3; i++)
        {
            // 剪枝错误，当target为负数时就会直接返回
            // if (nums[i] > target) return res;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            for(int j = i + 1; j < nums.size(); j++)
            {
                // 注意了，这里也不能这样去重，因为 j 会循环到nums.size() - 2处，
                // 但是这些都是错误组合，不能提前返回
                // if (nums[i] + nums[j] > target) return res;
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;

                left = j + 1, right = nums.size() - 1;
                while(left < right)
                {
                    sum = (long)nums[i] + (long)nums[j] + (long)nums[left] + (long)nums[right];
                    if(sum == target)
                    {
                        res.push_back(vector<int>{nums[i],nums[j], nums[left], nums[right]});
                        while(left < right && nums[left] == nums[left + 1]) left++;
                        while(left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    }
                    else if(sum > target)
                        right--;
                    else
                        left++;
                }
            }
        }
        return res;
    }
};

// 剪枝详细
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target)
    {
       vector<vector<int> > res;
       int n = nums.size();
       if (n < 4)   return res; // 特判
       sort(nums.begin(), nums.end()); // 排序
       // 选取第一个数
       for (int i = 0; i < n - 3; i++)
       {
            if (i > 0 && nums[i] == nums[i-1])  // 去重
                continue;
            if (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) // 剪枝
                break;
            if (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) // 剪枝
                continue;
            // 选取第二个数
            for (int j = i+1; j < n - 2; j++)
            {
                if (j > i+1 && nums[j] == nums[j-1]) // 去重
                    continue;
                if (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) // 剪枝
                    break;
                if (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) // 剪枝
                    continue;
                // 通过双指针取第三个和第四个数
                int left = j + 1;
                int right = n - 1;
                while (left < right)
                {
                    if (nums[left] + nums[right] < target - nums[i] - nums[j])
                        left++;     // 此两数之和太小，左指针右移
                    else if (nums[left] + nums[right] > target - nums[i] - nums[j])
                        right--;    // 此两数之和太大，右指针左移
                    else
                    {
                        // 找到一组解，左右指针内缩，继续寻找
                        res.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});

                        // 去重
                        while (left < right && nums[left] == nums[left+1])   left++;
                        while (left < right && nums[right] == nums[right-1])   right--;
                        left++; right--;
                    }
                }
            }
       }
       return res;
    }
};

```

<a id="88"></a>

### [88. 合并两个有序数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        if(n == 0) return;
        if(m == 0)
        {
            for(int i = 0; i < n; i++)
                nums1[i] = nums2[i];
            return;
        }

        int j1 = m - 1, j2 = n - 1, i = 0;
        for(i = m + n - 1; (i >= 0) && (j1 >= 0) && (j2 >= 0); i--)
        {
            if(nums1[j1] < nums2[j2])
            {
                nums1[i] = nums2[j2];
                j2--;
            }
            else
            {
                nums1[i] = nums1[j1];
                j1--;
            }
        }

        while(i >= 0 && j1 >= 0)
            nums1[i--] = nums1[j1--];
        while(i >= 0 && j2 >= 0)
            nums1[i--] = nums2[j2--];

        return;
    }
};

// 极简写法
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = nums1.size() - 1;
        m--;
        n--;
        while (n >= 0) {
            while (m >= 0 && nums1[m] > nums2[n]) {
                swap(nums1[i--], nums1[m--]);
            }
            swap(nums1[i--], nums2[n--]);
        }
    }
};
```

<a id="16"></a>

### [Leetcode 16. 最接近的三数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());

        int res = nums[0] + nums[1] + nums[2];
        for(int i = 0; i < nums.size() - 2; i++)
        {
            if(i > 0 && nums[i] == nums[i - 1])
                continue;
            int left = i + 1, right = nums.size() - 1;
            while(left < right)
            {
                int sum = nums[i] + nums[left] + nums[right];
                if(abs(target - sum) < abs(target - res))
                    res = sum;
                if(sum < target)
                    left++;
                else if(sum > target)
                    right--;
                else
                    return res;
            }
        }
        return res;
    }
};
```

<a id="167"></a>

### [Leetcode 167. 两数之和 II - 输入有序数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0, right = numbers.size() - 1;
        while(left < right)
        {
            if(numbers[left] + numbers[right] == target)
                return {left + 1, right + 1};
            else if(numbers[left] + numbers[right] < target)
                left ++;
            else
                right--;
        }

        return {};
    }
};

class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res;

        int left = 0;
        int right = numbers.size() - 1;
        while(left < right)
        {
            if(numbers[left] + numbers[right] == target)
            {
                res.push_back(left + 1);
                res.push_back(right + 1);
                break;
            }
            else if(numbers[left] + numbers[right] < target)
                left++;
            else
                right--;
        }

        return res;
    }
};
```

<a id="42"></a>

### [Leetcode 42. 接雨水](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() == 0) return 0;
        int left = 0, right = height.size() - 1;
        int leftMax = height[left];
        int rightMax = height[right];
        int res = 0;

        while(left < right)
        {
            leftMax = max(leftMax, height[left]);
            rightMax = max(rightMax, height[right]);
            if(leftMax < rightMax)
            {
                res += leftMax - height[left];
                left++;
            }
            else
            {
                res += rightMax - height[right];
                right--;
            }
        }
        return res;
    }
};

// 下面的写法也比较容易理解
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}
```

<a id="11"></a>

### [Leetcode 11. 盛最多水的容器](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int maxArea(vector<int>& height) {
        if(height.size() == 0) return 0;

        int left = 0, right = height.size() - 1;
        int leftMax = height[left];
        int rightMax = height[right];
        int res = 0;

        while(left < right)
        {
            leftMax = max(leftMax, height[left]);
            rightMax = max(rightMax, height[right]);
            if(leftMax < rightMax)
            {
                res = max(res, (right - left) * leftMax);
                left++;
            }
            else
            {
                res = max(res, (right - left) * rightMax);
                right--;
            }
        }
        return res;
    }
};

class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0;

        int left = 0, right = height.size() - 1;
        while (left < right)
        {
            if (height[left] < height[right])
            {
                res = max(res, height[left] * (right - left));
                left++;
            }
            else
            {
                res = max(res, height[right] * (right - left));
                right--;
            }
        }

        return res;
    }
};
```

<a id="125"></a>

### [Leetcode 125. 验证回文串](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool isCharOrInt(const char c)
    {
        if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
            return true;
        else
            return false;
    }
    bool equal(const char c1, const char c2)
    {
        if(c1 >= '0' && c1 <= '9')
            return c1 == c2;
        return c1 == c2 || (abs(c1 - c2) == 32);
    }
    bool isPalindrome(string s) {
        if(s.size() <= 1) return true;

        int left = 0, right = s.size() - 1;
        while(left < right)
        {
            while((isCharOrInt(s[left]) == false) && left < right)
                left++;
            while((isCharOrInt(s[right]) == false) && left < right)
                right--;
            if(equal(s[left], s[right]) == false)
                return false;
            right--;
            left++;
        }
        return true;
    }
};

// 使用了库函数
class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        int left = 0, right = n - 1;
        while (left < right) {
            while (left < right && !isalnum(s[left])) {
                ++left;
            }
            while (left < right && !isalnum(s[right])) {
                --right;
            }
            if (left < right) {
                if (tolower(s[left]) != tolower(s[right])) {
                    return false;
                }
                ++left;
                --right;
            }
        }
        return true;
    }
};
```

<a id="344"></a>

### [Leetcode 344. 反转字符串](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    void reverseString(vector<char>& s) {
        if(s.size() <= 1) return;

        int left = 0, right = s.size() - 1;
        while(left < right)
        {
            char c = s[left];
            s[left] = s[right];
            s[right] = c;

            left++;
            right--;
        }
        return;
    }
};
```

<a id="345"></a>

### [Leetcode 345. 反转字符串中的元音字母](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool isVowel(const char c)
    {
        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')
            return true;
        if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')
            return true;
        return false;
    }
    string reverseVowels(string s) {
        if(s.size() <= 1)
            return s;
        
        int left = 0, right = s.size() - 1;
        while(left < right)
        {
            while(left < right && (isVowel(s[left]) == false))
                left++;
            while(left < right && (isVowel(s[right]) == false))
                right--;
            if(left < right)
            {
                char c = s[left];
                s[left] = s[right];
                s[right] = c;
                
                left++;
                right--;
            }
        }

        return s;
    }
};
```

<a id="259"></a>

### [Leetcode 259. 较小的三数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int threeSumSmaller(vector<int>& nums, int target) {
        if(nums.size() <= 2) return 0;
        sort(nums.begin(), nums.end());

        int ret = 0;

        for(int i = 0; i < nums.size(); i++)
        {
            int left = i + 1, right = nums.size() - 1;
            while(left < right)
            {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum < target)
                {
                    ret += right-left;
                    left++;
                }
                else
                    right--;
            }
        }
        return ret;
    }
};
```

<a id="1099"></a>

### [Leetcode 1099. 小于 K 的两数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int twoSumLessThanK(vector<int>& nums, int k) {
        if(nums.size() < 2) return -1;

        sort(nums.begin(), nums.end());
        int left = 0, right = nums.size() - 1;
        int ret = INT_MIN;
        
        while(left < right)
        {
            int sum = nums[left] + nums[right];

            if(sum < k)
            {         
                ret = max(ret, sum);
                left++;
            }
            else
                right--;
        }

        return ret == INT_MIN? -1: ret;
    }
};
```

<a id="844"></a>

### [Leetcode 844. 比较含退格的字符串](#TopicSummary)

```C++{.line-numbers}
class Solution {
private:
    void jump(const string &x, int &i, int &b) {    //跳转到下一个有效字符的坐标
        while (i >= 0) {
            if (x[i] == '#') b++;
            else if (b) b--;
            else break;
            i--;
        }
    }

public:
    bool backspaceCompare(string S, string T) {
        int i = S.size() - 1, j = T.size() - 1;
        int bs = 0, bt = 0;
        while (i >= 0 || j >= 0) {                  //双指针，从后往前扫描
            jump(S, i, bs);
            jump(T, j, bt);
            if (i < 0 || j < 0) break;
            if (S[i--] != T[j--]) return false;
        }
        return i < 0 && j < 0;
    }
};
```

<a id="845"></a>

### [Leetcode 845. 数组中的最长山脉](#TopicSummary)

```C++{.line-numbers}
// 双指针写法
class Solution {
public:
    int longestMountain(vector<int>& A) {
        int maxLength = 0;
        int i = 1;
        
        while (i < A.size()) {
            int increasing = 0, decreasing = 0;
            
            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;
            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;
            
            if (increasing > 0 && decreasing > 0) 
                maxLength = max(maxLength, increasing + decreasing + 1);
            
            while(i < A.size() && A[i - 1] == A[i]) i++;
        }
        return maxLength;
    }
};

// 中心扩展法 + 动态规划
class Solution {
public:
    int longestMountain(vector<int>& arr) {
        int n = arr.size();
        if (!n) {
            return 0;
        }
        vector<int> left(n);
        for (int i = 1; i < n; ++i) {
            left[i] = (arr[i - 1] < arr[i] ? left[i - 1] + 1 : 0);
        }
        vector<int> right(n);
        for (int i = n - 2; i >= 0; --i) {
            right[i] = (arr[i + 1] < arr[i] ? right[i + 1] + 1 : 0);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (left[i] > 0 && right[i] > 0) {
                ans = max(ans, left[i] + right[i] + 1);
            }
        }
        return ans;
    }
};
```

<a id="977"></a>

### [Leetcode 977. 有序数组的平方](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        if(nums.size() == 0) return {};
        if(nums.size() == 1) return {nums[0] * nums[0]};
        
        vector<int> ret(nums.size(), 0);
        int left = 0, right = nums.size() - 1;
        int k = ret.size() - 1;

        while(left <= right) // 注意这里的等于
        {
            if(abs(nums[left]) < abs(nums[right]))
                ret[k--] = nums[right] * nums[right], right--;
            else
                ret[k--] = nums[left] * nums[left], left++;
        }

        return ret;
    }
};
```
