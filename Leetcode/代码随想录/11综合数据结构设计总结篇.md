>
> - <font size=4>**虚拟头节点—删除特定节点**</font>
>
>   - **[Leetcode 146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)** [速览题解](#460)
>     - 简评：
>   - **[Leetcode 933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)** [速览题解](#933)
>     - 简评：
>   - **[Leetcode 1756. 设计最近使用（MRU）队列](https://leetcode-cn.com/problems/design-most-recently-used-queue/)** [速览题解](#1756)
>     - 简评：
>   - **[Leetcode 剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)** [速览题解](#09)
>     - 简评：
>   - **[Leetcode 341. 扁平化嵌套列表迭代器](https://leetcode-cn.com/problems/flatten-nested-list-iterator/)** [速览题解](#341)
>     - 简评：
>   - **[Leetcode 剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 155. 最小栈](https://leetcode-cn.com/problems/min-stack/)** [速览题解](#155)
>     - 简评：
>   - **[Leetcode 208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 303. 区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)** [速览题解](#146)
>     - 简评：
>   - **[Leetcode 146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)** [速览题解](#146)
>     - 简评：

---

<a id="146"></a>

### [Leetcode 146. LRU 缓存机制](#TopicSummary)

```C++{.line-numbers}
// 完全基于双向链表的实现，可以应用到 ucore 中
class LRUCache {
private:
    class ListNode
    {
    public:
        ListNode* pre;
        ListNode* next;
        int key;
        int value;

        ListNode(): key(0), value(0), next(this), pre(this){}
        ListNode(int key, int val): key(key), value(val), next(this), pre(this){}

        static void _add(ListNode* elem, ListNode *node)
        {
            _addNode(elem, node, node->next);
        }
        static void _addNode(ListNode *elem, ListNode *pre, ListNode* next) // add after
        {
            pre->next = next->pre = elem;
            elem->next = next;
            elem->pre = pre;
        }
        static void _delete(ListNode *node)
        {
            _deleteNode(node->pre, node->next);
            node->pre = node->next = node;
        }
        static void _deleteNode(ListNode *pre, ListNode* next)
        {
            pre->next = next;
            next->pre = pre;
        }
        
    };
    ListNode *_dummy;
    ListNode *_getCurrent;
    int _size;
    int _capacity;

public:
    LRUCache(int capacity): _capacity(capacity), _size(0), _getCurrent(nullptr){
        _dummy = new ListNode();
    }
    
    int get(int key) {
        _getCurrent = nullptr;
        if(_size == 0) return -1;

        ListNode *cur = _dummy->next;
        while(cur != _dummy)
        {
            if(cur->key == key)
            {
                _getCurrent = cur;
                ListNode::_delete(_getCurrent);
                ListNode::_add(_getCurrent, _dummy);
                return cur->value;
            }
            cur = cur->next;
        }
        return -1;
    }
    
    void put(int key, int value) {
        int keyValue = get(key);

        if(keyValue != -1 && _getCurrent != nullptr)
        {
            _getCurrent->value = value;
        }
        else
        {
            if(_size == _capacity)
            {
                ListNode::_delete(_dummy->pre);
                _size--;
            }
            ListNode *elem = new ListNode(key, value);
            ListNode::_add(elem, _dummy);
            _size++;
        }
    }
};

// 在 Leetcode 中，上面的时间复杂度不符合要求
// 在下面的实现中，使用了 unordered_map 来做哈希查找，以保证时间复杂度为O(1)
class LRUCache {
private:
    class ListNode
    {
    public:
        ListNode* pre;
        ListNode* next;
        int key; // 不能省掉 key
        int value;

        ListNode(): key(0), value(0), next(this), pre(this){}
        ListNode(int key, int val): key(key), value(val), next(this), pre(this){}

        static void addHead(ListNode *node, ListNode* elem)
        {
            addHead(node, node->next, elem);
        }
        static void addHead(ListNode *pre, ListNode* next, ListNode *elem) // add after
        {
            pre->next = next->pre = elem;
            elem->next = next;
            elem->pre = pre;
        }
        static void deleteNode(ListNode *node)
        {
            deleteNode(node->pre, node->next);
            node->pre = node->next = node;
        }
        static void deleteNode(ListNode *pre, ListNode* next)
        {
            pre->next = next;
            next->pre = pre;
        }
        
    };


    ListNode *m_head;
    int m_size;
    int m_capacity;
    unordered_map<int, ListNode*> m_keyset;

public:
    LRUCache(int capacity): m_capacity(capacity), m_size(0){
        m_head = new ListNode();
    }
    
    int get(int key) {

        if(m_size == 0 || m_keyset.count(key) == false)
        {
            return -1;
        }
        else
        {
            ListNode* ret = m_keyset[key];
            ListNode::deleteNode(ret);
            ListNode::addHead(m_head, ret);
            return ret->value;
        }
    }
    
    void put(int key, int value) {
        int keyValue = get(key);

        // 找到了 key，更新其 value
        if(keyValue != -1)
        {
            m_keyset[key]->value = value;
        }
        // 没有找到 key，插入 (key, value)
        else
        {
            if(m_size == m_capacity)
            {
                // 这里可以看到 ListNode 不能省掉 key
                m_keyset.erase(m_head->pre->key);
                ListNode::deleteNode(m_head->pre);
                m_size--;
            }
            ListNode *elem = new ListNode(key, value);
            m_keyset[key] = elem;
            ListNode::addHead(m_head, elem);
            m_size++;
        }
    }
};
```

<a id=""></a>

### [Leetcode ](#TopicSummary)

```C++{.line-numbers}

```

<a id=""></a>

### [Leetcode ](#TopicSummary)

```C++{.line-numbers}

```
