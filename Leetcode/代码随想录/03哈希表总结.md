<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >

[toc]

> 哈希表总结篇如约而至

哈希表系列也是早期讲解的时候没有写总结篇，所以选个周末给补上，毕竟「代码随想录」的系列怎么能没有总结篇呢[机智]。

# 哈希表理论基础

在[关于哈希表，你该了解这些！](https://mp.weixin.qq.com/s/g8N6WmoQmsCUw3_BaWxHZA)中，我们介绍了哈希表的基础理论知识，不同于枯燥的讲解，这里介绍了都是对刷题有帮助的理论知识点。

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

对于哈希表，要知道**哈希函数**和**哈希碰撞**在哈希表中的作用.

哈希函数是把传入的 key 映射到符号表的索引上。

哈希碰撞处理有多个 key 映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

在 C++语言中，set 和 map 都分别提供了三种数据结构，每种数据结构的底层实现和用途都有所不同，在[关于哈希表，你该了解这些！](https://mp.weixin.qq.com/s/g8N6WmoQmsCUw3_BaWxHZA)中我给出了详细分析，这一知识点很重要！

例如什么时候用 std::set，什么时候用 std::multiset，什么时候用 std::unordered_set，都是很有考究的。

**只有对这些数据结构的底层实现很熟悉，才能灵活使用，否则很容易写出效率低下的程序**。

# 哈希表经典题目

## 数组作为哈希表

一些应用场景就是为数组量身定做的。

在[哈希表：有效的字母异位词](https://mp.weixin.qq.com/s/vM6OszkM6L1Mx2Ralm9Dig)中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！

这道题目包含小写字母，那么使用数组来做哈希最合适不过。

在[哈希表：赎金信](https://mp.weixin.qq.com/s/sYZIR4dFBrw_lr3eJJnteQ)中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！

本题和[哈希表：有效的字母异位词](https://mp.weixin.qq.com/s/vM6OszkM6L1Mx2Ralm9Dig)很像，[哈希表：有效的字母异位词](https://mp.weixin.qq.com/s/vM6OszkM6L1Mx2Ralm9Dig)是求 字符串 a 和 字符串 b 是否可以相互组成，在[哈希表：赎金信](https://mp.weixin.qq.com/s/sYZIR4dFBrw_lr3eJJnteQ)中是求字符串 a 能否组成字符串 b，而不用管字符串 b 能不能组成字符串 a。

一些同学可能想，用数组干啥，都用 map 不就完事了。

**上面两道题目用 map 确实可以，但使用 map 的空间消耗要比数组大一些，因为 map 要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！**

## set 作为哈希表

在[哈希表：两个数组的交集](https://mp.weixin.qq.com/s/N9iqAchXreSVW7zXUS4BVA)中我们给出了什么时候用数组就不行了，需要用 set。

这道题目没有限制数值的大小，就无法使用数组来做哈希表了。

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

所以此时一样的做映射的话，就可以使用 set 了。

关于 set，C++ 给提供了如下三种可用的数据结构：（详情请看[关于哈希表，你该了解这些！](https://mp.weixin.qq.com/s/g8N6WmoQmsCUw3_BaWxHZA)）

- std::set
- std::multiset
- std::unordered_set

std::set 和 std::multiset 底层实现都是红黑树，std::unordered_set 的底层实现是哈希， 使用 unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择 unordered_set。

在[哈希表：快乐数](https://mp.weixin.qq.com/s/G4Q2Zfpfe706gLK7HpZHpA)中，我们再次使用了 unordered_set 来判断一个数是否重复出现过。

## map 作为哈希表

在[哈希表：两数之和](https://mp.weixin.qq.com/s/uVAtjOHSeqymV8FeQbliJQ)中 map 正式登场。

来说一说：使用数组和 set 来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set 是一个集合，里面放的元素只能是一个 key，而两数之和这道题目，不仅要判断 y 是否存在而且还要记录 y 的下表位置，因为要返回 x 和 y 的下表。所以 set 也不能用。

map 是一种`<key, value>`的结构，本题可以用 key 保存数值，用 value 在保存数值所在的下表。所以使用 map 最为合适。

C++提供如下三种 map：：（详情请看[关于哈希表，你该了解这些！](https://mp.weixin.qq.com/s/g8N6WmoQmsCUw3_BaWxHZA)）

- std::map
- std::multimap
- std::unordered_map

std::unordered_map 底层实现为哈希，std::map 和 std::multimap 的底层实现是红黑树。

同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[哈希表：两数之和](https://mp.weixin.qq.com/s/uVAtjOHSeqymV8FeQbliJQ)中并不需要 key 有序，选择 std::unordered_map 效率更高！

在[哈希表：四数相加 II](https://mp.weixin.qq.com/s/Ue8pKKU5hw_m-jPgwlHcbA)中我们提到了其实需要哈希的地方都能找到 map 的身影。

本题咋眼一看好像和[18. 四数之和](https://mp.weixin.qq.com/s/r5cgZFu0tv4grBAexdcd8A)，[15.三数之和](https://mp.weixin.qq.com/s/nQrcco8AZJV1pAOVjeIU_g)差不多，其实差很多！

**关键差别是本题为四个独立的数组，只要找到 A[i] + B[j] + C[k] + D[l] = 0 就可以，不用考虑重复问题，而[18. 四数之和](https://mp.weixin.qq.com/s/nQrcco8AZJV1pAOVjeIU_g)，[15.三数之和](https://mp.weixin.qq.com/s/r5cgZFu0tv4grBAexdcd8A)是一个数组（集合）里找到和为 0 的组合，可就难很多了！**

用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。

其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。

在[哈希表：解决了两数之和，那么能解决三数之和么？](https://mp.weixin.qq.com/s/r5cgZFu0tv4grBAexdcd8A)中我给出了哈希法和双指针两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。

所以[18. 四数之和](https://mp.weixin.qq.com/s/r5cgZFu0tv4grBAexdcd8A)，[15.三数之和](https://mp.weixin.qq.com/s/nQrcco8AZJV1pAOVjeIU_g)都推荐使用双指针法！

# 总结

对于哈希表的知识相信很多同学都知道，但是没有成体系。

本篇我们从哈希表的理论基础到数组、set 和 map 的经典应用，把哈希表的整个全貌完整的呈现给大家。

**同时也强调虽然 map 是万能的，详细介绍了什么时候用数组，什么时候用 set**。

相信通过这个总结篇，大家可以对哈希表有一个全面的了解。

<a id="TopicSummary"></a>

> **题目汇总**
>
> - 数组作为哈希表
>   - **[Leetcode 242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/solution/)** [速览题解](#242)
>   - **[Leetcode 383. 赎金信](https://leetcode-cn.com/problems/ransom-note/submissions/)** [速览题解](#383)
>     简评：如果数值有大小限制，就可以使用数组，因为这样我们的数组大小也会有限制。否则就不适合使用数组作为哈希表
> - set 作为哈希表
>   - **[Leetcode 349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)** [速览题解](#349)
>   - **[Leetcode 202. 快乐数](https://leetcode-cn.com/problems/happy-number/)** [速览题解](#202)
> - map 作为哈希表
>   - **[Leetcode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/)** [速览题解](#1)
>   - **[Leetcode 167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/)** [速览题解](#167)
>   - **[Leetcode 653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)** [速览题解](#653)
>   - **[Leetcode 454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)** [速览题解](#454)
>   - **[Leetcode 15. 三数之和](https://leetcode-cn.com/problems/3sum/)** [速览题解](#15)
>   - **[Leetcode 18. 四数之和](https://leetcode-cn.com/problems/4sum/)** [速览题解](#18)
>
> ---
>
> - <font size=4>**哈希集合 `(HashSet)`**</font>
>
>
>   - **[Leetcode 705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)** [速览题解](#705)<a id="l705"></a>
>     - 简评：设计哈希集合 `(HashSet)`。**重点：1.确定哈希函数；2.冲突处理。其中冲突处理有三种：链地址法、开放地址法、再哈希法**。本题使用链地址法，链地址法中的链这里使用的 `list`， 其实也可以改为 `vector`。但是使用 `vector` 出现的问题是 `remove` 操作会达到O(n)，一个巧妙的解决方案是把末尾元素赋值到待删除位置，然后删除末尾元素。
>     - 简评：尽管使用了链地址法，同一个桶中的元素还是有可能过多，此时如果在同一个桶中有太多的值，这些值将被保留在一个**高度平衡的二叉树搜索树**中。
>   - **[Leetcode 217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)** [速览题解](#217)<a id="l217"></a>
>     - 简评：很简单
>   - **[Leetcode 136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)** [速览题解](#136)<a id="l136"></a>
>     - 简评：这道题最好的做法是利用异或运算。当然也可以用哈希集合来做，如果没有就添加，有就删除，这样有两次重复的元素都会被删除，留下没有重复的那个
>   - **[Leetcode 349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)** [速览题解](#349)<a id="l349"></a>
>     - 简评：这道题比较简单，注意如何使用一个 `set` 完成。用一个数组初始化化 `set`，然后查看另外一个数组在 `set` 中是否存在，注意去重，一旦第一次发现存在就要从 `set` 中删除掉，否则结果集有重复元素
>   - **[Leetcode 202. 快乐数](https://leetcode-cn.com/problems/happy-number/)** [速览题解](#202)<a id="l202"></a>
>     - 简评：这道题可以用**哈希集合**来做，也可以用**双指针**来做。求是否有循环的都可以用哈希和双指针来做
>     - 简评：1.这道题会会陷入循环，但是要看是哪一个数循环，如果是 1 循环就是快乐数，这个过程中会得到一个隐式的链表，所以用到了快慢指针的思想。2.这道题会有三种情况，参考[官方解析](https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/)。
>
> - <font size=4>**哈希映射 `(HashMap)`**</font>
> 队列实现栈，数组实现栈，链表实现栈
>
>   - **[Leetcode 706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)** [速览题解](#706)<a id="l706"></a>
>     - 简评：设计哈希集合 `(HashSet)`。**重点：1.确定哈希函数；2.冲突处理。其中冲突处理有三种：链地址法、开放地址法、再哈希法**。本题使用链地址法
>   - **[Leetcode 1. 两数之和](https://leetcode-cn.com/problems/two-sum/)** [速览题解](#1)<a id="l1"></a>
>     - 简评：哈希法时间复杂度和空间复杂度都是 $O(n)$。暴力循环的时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$
>   - **[Leetcode 599. 两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)** [速览题解](#599)<a id="l599"></a>
>     - 简评：哈希法时间复杂度和空间复杂度都是 $O(n)$。暴力循环的时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$
>   - **[Leetcode 205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)** [速览题解](#205)<a id="l205"></a>
>     - 简评：**双哈希映射，互相映射：`unordered_map<int, int> s2t, unordered_map<int, int>  t2s`**
>   - **[Leetcode 290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)** [速览题解](#290)<a id="l290"></a>
>     - 简评：`205` 的升级版，也是**双哈希映射，互相映射：`unordered_map<char, string> ch2str, unordered_map<string, char>  str2ch`**。这道题也可以先把 `s` 拆分到 `vector<string>` 数组中，然后就转变成了 `205` 的做法
>   - **[Leetcode 387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)** [速览题解](#387)<a id="l387"></a>
>     - 简评：两种方法。第一遍遍历字符串统计字符出现的频率，第二遍遍历字符串，遇到频率为 1 的立即返回其下标。另外一种思路是在第一遍遍历字符串的统计过程中对重复的字符进行特殊标记，第二遍遍历统计结果中没有进行特殊标记的集合，返回结果
>   - **[Leetcode 219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)** [速览题解](#219)<a id="l219"></a>
>     - 简评：找到重复的数并且相隔不超过 `k`，这道题还是比较简单。在遍历的过程中记录每个元素的位置，当有重复出现的元素时将当前下标减去记录的下标，判断是否小于等于 `k`，是就返回，不是就更新（因为要保证离遍历位置最近，才有可能小于 `k`）该重复元素的位置。
>   - **[Leetcode 350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)** [速览题解](#350)<a id="l350"></a>
>     - 简评：注意这道题与349的区别， 349 是集合意义上的交集，本题是映射角度的交集。本题还有[进阶三问，讨论参考本链接。](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/jin-jie-san-wen-by-user5707f/)
>   - **[Leetcode 242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/solution/)** [速览题解](#242)<a id="l242"></a>
>     - 简评：使用哈希映射**统计词频**。
>
> - <font size=4>**哈希映射 `(HashMap)`—设计键**</font>
> 排序结果作键、偏移量作键、序列化树作键、[设计键 - 总结](https://leetcode-cn.com/leetbook/read/hash-table/xxavl2/)
>
>   - **[Leetcode 49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)** [速览题解](#49)<a id="l49"></a>
>     - 简评：**排序后数组作键**。当字符串 / 数组中每个元素的顺序不重要时，**可以使用排序后的字符串 / 数组作为键**。这道题可以自己设计一个 `hash(质数)` 生成 `key`，然后再传入 `map` 中
>   - **[Leetcode 249. 移位字符串分组](https://leetcode-cn.com/problems/group-shifted-strings/)** [速览题解](#249)<a id="l249"></a>
>     - 简评：**偏移量作键**。如果只关心每个值的偏移量，通常是第一个值的偏移量，则**可以使用偏移量作为键。**
>   - **[Leetcode 36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)** [速览题解](#36)<a id="l36"></a>
>     - 简评：行，列，块，三个哈希表。比较简单
>   - **[Leetcode 652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)** [速览题解](#652)<a id="l652"></a>
>     - 简评：在树中，你有时可能会希望直接使用 TreeNode 作为键。 但在大多数情况下，采用**子树的序列化表述**可能是一个更好的主意。
>
> - <font size=4>**哈希小结**</font>
>
>   - **[Leetcode 771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)** [速览题解](#771)<a id="l771"></a>
>     - 简评：这道题非常简单
>   - **[Leetcode 3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)** [速览题解](#3)<a id="l3"></a>
>     - 简评：这道题除开暴力法，最基础的做法是使用滑动窗口。在滑动窗口的基础之上还可以进行优化，**将重复字符的下一个位置用哈希表记录下来**，遇见重复的字符就直接跳转到该重复字符的下一个位置
>   - **[Leetcode 170. 两数之和 III - 数据结构设计](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/)** [速览题解](#170)<a id="l170"></a>
>     - 简评：这道题并不简单。不能使用 `unordered_set`：`[2,2,4]`，`find(4)` 时无法知道究竟找到的是 `4 or 2 + 2`。
>   - **[Leetcode 454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)** [速览题解](#454)<a id="l454"></a>
>     - 简评：这道题与 `四数之和` 的区别是，本题是在**四个集合**中找这 4 个数，而四数之和是在**同一个集合**中找 4 个数。
>   - **[Leetcode 347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)** [速览题解](#347)<a id="l347"></a>
>     - 简评：这道题最基础的做法是使用排序（堆排序、快速排序...），这里是另外一种思路，使用哈希表统计频次然后找出前 `k` 个最高频，但是这里存在一个问题：时间复杂度会很高
>   - **[Leetcode 288. 单词的唯一缩写](https://leetcode-cn.com/problems/unique-word-abbreviation/)** [速览题解](#288)<a id="l288"></a>
>     - 简评：这道题注意读题，另外注意哈希表的用法：`unordered_map<int, vector<int>>`，当哈希冲突严重或者说 `vector` 过大时，`STL` 的做法是使用红黑树

---

<a id="242"></a>

### [242. 有效的字母异位词](#l242)

```C++{.line-numbers}
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};

        for (int i = s.length() - 1; i >= 0; i--)
            record[s[i]-'a']++;

        for (int i = t.length() - 1; i >= 0; i--)
            record[t[i]-'a']--;

        for(int i = 0; i<26;i++)
            if(record[i])
                return false;

        return true;
    }
};

class Solution {
public:
    bool isAnagram(string s, string t) {
        unordered_map<char, int> count;

        for(auto c: s)
            count[c]++;
        
        for(auto c:t)
            if(count.count(c))
            {
                count[c]--;
                if(count[c] == 0)
                    count.erase(c);
            }
            else
                return false;
        return count.size() == 0;
    }
};
```

<a id="383"></a>

### [383. 赎金信](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};

        for(int i = magazine.size() - 1; i >= 0; i--)
            record[magazine[i] - 'a']++;

        for(int i = ransomNote.size() - 1; i >= 0; i--)
        {
            record[ransomNote[i] - 'a']--;
            if (record[ransomNote[i] - 'a'] < 0)
                return false;
        }

        return true;
    }
};
```

<a id="349"></a>

### [349. 两个数组的交集](#TopicSummary)

```C++{.line-numbers}
// 使用两个set
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> res;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());

        for(int num: nums2)
        {
            if(nums_set.find(num) != nums_set.end())
                res.insert(num);
        }

        return vector<int>(res.begin(), res.end());
    }
};

// 使用一个set
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> set;
        vector<int> res;

        for(auto nums: nums1)
            set.insert(nums);

        for(auto nums: nums2)
            if(set.find(nums) != set.end())
            {
                res.push_back(nums);
                set.erase(nums);
            }
        return res;
    }
};
```

<a id="202"></a>

### [202. 快乐数](#TopicSummary)

```C++{.line-numbers}
//用了哈希表，不推荐
class Solution {
public:
    int getNext(int n)
    {
        int sum = 0;

        while(n != 0)
        {
            sum += ((n % 10) * (n % 10));
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;

        while(set.find(n) == set.end())
        {
            set.insert(n);
            n = getNext(n);
        }

        return n == 1;
    }
};

//利用快慢指针破除循环
class Solution {
public:

    int bitSquareSum(int sum)
    {
        int s = 0;
        while(sum)
        {
            s+= (sum % 10) * (sum % 10);
            sum = sum / 10;
        }
        return s;
    }
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = bitSquareSum(slow);
            fast = bitSquareSum(fast);
            fast = bitSquareSum(fast);
        }while(slow!=fast && fast != 1);
        return fast == 1;
    }
};
```

<a id="1"></a>

### [1. 两数之和](#l1)

```C++{.line-numbers}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;

        for(int i = 0; i < nums.size(); i++)
        {
            auto iter = m.find(target - nums[i]);
            if(iter == m.end())
                m.insert(pair<int, int>(nums[i], i));
            else
                return {iter->second, i};
        }
        return {};
    }
};
```

<a id="599"></a>

### [599. 两个列表的最小索引总和](#l599)

```C++{.line-numbers}
class Solution {
public:
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        vector<string> res;
        unordered_map<string, int> mp;
        int minIndex = list1.size() + list2.size() - 2;

        for(int i = 0; i < list1.size(); i++)
            mp[list1[i]] = i;

        for(int i = 0; i < list2.size(); i++)
        {
            if(mp.count(list2[i]))
            {
                // 找到更优的方案，一定要把旧方案全部清理掉
                if(mp[list2[i]] + i < minIndex)
                {
                    res.clear();
                    res.push_back(list2[i]);
                    minIndex = mp[list2[i]] + i;
                }
                // 有相同的也要插入
                else if(mp[list2[i]] + i == minIndex)
                    res.push_back(list2[i]);
            }
        }

        return res;
    }
};
```

<a id="205"></a>

### [205. 同构字符串](#l205)

```C++{.line-numbers}
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.size() != t.size())
            return false;
        
        unordered_map<int, int> s2t;
        unordered_map<int, int> t2s;

        for(int i = 0; i < s.size(); i++)
        {
            int x = s[i], y = t[i];
            if((s2t.count(x) && s2t[x] != y) || (t2s.count(y) && t2s[y] != x))
                return false;
            s2t[x] = y;
            t2s[y] = x;
        }
        return true;
    }
};
```

<a id="290"></a>

### [290. 单词规律](#l290)

```C++{.line-numbers}
class Solution {
public:
    bool wordPattern(string pattern, string s) {

        unordered_map<char, string> ch2str;
        unordered_map<string, char> str2ch;

        int i = 0;
        for(auto ch: pattern)
        {
            string str;
            if(i >= s.size())
                return false;
            while(i < s.size() && s[i] != ' ')
                str += s[i++];

            if(ch2str.count(ch) && ch2str[ch] != str)
                return false;
            if(str2ch.count(str) && str2ch[str] != ch)
                return false;
            ch2str[ch] = str;
            str2ch[str] = ch;
            i++;
        }
        return i >= s.size() - 1;
    }
};
```

<a id="387"></a>

### [387. 字符串中的第一个唯一字符](#l387)

```C++{.line-numbers}
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<int, int> count;
        // 先遍历一遍字符串
        for(auto c: s)
            count[c]++;
        
        // 顺序遍历遇到第一个只有一个的返回索引
        for(int i = 0; i < s.size(); i++)
            if(count[s[i]] == 1)
                return i;

        return -1;
    }
};

// 第二种思路，对于重复的字符我们设定特定的值标记
class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map<char, int> position;
        
        for(int i = 0; i < s.size(); i++)
        {
            if(position.count(s[i]))
            {
                if(position[s[i]] != -1)
                    position[s[i]] = -1;
            }
            else
                position[s[i]] = i;
        }
        
        int first = s.size();
        for(auto [_, pos]: position)
            if(pos != -1 && pos < first)
                first = pos;

        if(first == s.size())
            return -1;
        else return first;
    }
};
```

<a id="219"></a>

### [219. 存在重复元素 II](#l219)

```C++{.line-numbers}
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> position;

        for(int i = 0; i < nums.size(); i++)
        {
            if(position.count(nums[i]))
                if(i - position[nums[i]] <= k)
                    return true;
            position[nums[i]] = i;
        }

        return false;
    }
};
```

<a id="350"></a>

### [350. 两个数组的交集 II](#l350)

```C++{.line-numbers}
// 进阶一：如果给定的数组已经排好序呢？你将如何优化你的算法？
// 答：使用双指针顺序遍历
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int length1 = nums1.size(), length2 = nums2.size();
        vector<int> intersection;
        int index1 = 0, index2 = 0;
        while (index1 < length1 && index2 < length2) {
            if (nums1[index1] < nums2[index2]) {
                index1++;
            } else if (nums1[index1] > nums2[index2]) {
                index2++;
            } else {
                intersection.push_back(nums1[index1]);
                index1++;
                index2++;
            }
        }
        return intersection;
    }
};

// 进阶二：如果 nums1 的大小比 nums2 小很多，哪种方法更优？
// 答：将较小的数组哈希计数，随后在另一个数组中根据哈希来寻找
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            return intersect(nums2, nums1);
        }
        unordered_map <int, int> m;
        for (int num : nums1) {
            ++m[num];
        }
        vector<int> intersection;
        for (int num : nums2) {
            if (m.count(num)) {
                intersection.push_back(num);
                --m[num];
                if (m[num] == 0) {
                    m.erase(num);
                }
            }
        }
        return intersection;
    }
};

// 进阶三：如果 nums2 的元素存储在磁盘上，内存是有限的，
//        并且你不能一次加载所有的元素到内存中，你该怎么办？
// 答：通过归并外排将两个数组排序后再使用排序双指针查找
```

<a id="49"></a>

### [49. 字母异位词分组](#l49)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;

        for(auto str: strs)
        {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].push_back(str); 
        }

        vector<vector<string>> res;
        for(auto [_, v]: mp)
            res.push_back(v);
        return res;
    }
};
```

<a id="249"></a>

### [249. 移位字符串分组](#l249)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<string>> groupStrings(vector<string>& strings) {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> mp;
        for (const auto& str : strings) {
            string key(str);
            for (auto& ch : key) {
                // 注意这里需要加26再求余数26，才能正确处理诸如"ba"这样的情况
                ch = (ch - str[0] + 26) % 26 + 'a';
            }
            mp[key].push_back(str);
        }

        for (const auto& [_, m] : mp) {
            res.push_back(m);
        }

        return  res;
    }
};
```

<a id="36"></a>

### [36. 有效的数独](#l36)

```C++{.line-numbers}
// 使用三个数组分别记录
class Solution
{
public:
    bool isValidSudoku(vector<vector<char>> &board)
    {
        vector<vector<int>> row(9, vector<int>(9, 0));
        vector<vector<int>> col(9, vector<int>(9, 0));
        vector<vector<int>> box(9, vector<int>(9, 0));

        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] == '.')
                {
                    continue;
                }
                int val = board[i][j] - '1';
                int box_index = (i / 3) * 3 + j / 3;
                if (row[i][val] == 0 && col[j][val] == 0 && box[box_index][val] == 0)
                {
                    row[i][val] = 1;
                    col[j][val] = 1;
                    box[box_index][val] = 1;
                }
                else
                {
                    return false;
                }
            }
        }
        return true;
    }
};

// 使用一个数组，做位运算
class Solution
{
public:
    bool isValidSudoku(vector<vector<char>> &board)
    {
        vector<int> wow(9, 0);
        int mux1;
        int mux2;
        int mux3;
        int box_index;

        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] == '.')
                {
                    continue;
                }
                mux1 = 0x01 << (board[i][j] - '1');
                mux2 = 0x01 << 9 << (board[i][j] - '1');
                mux3 = 0x01 << 9 << 9 << (board[i][j] - '1');
                box_index = (i / 3) * 3 + j / 3;
                if ((wow[i] & mux1) != mux1 && (wow[j] & mux2) != mux2 && (wow[box_index] & mux3) != mux3)
                {
                    wow[i] = wow[i] | mux1;
                    wow[j] = wow[j] | mux2;
                    wow[box_index] = wow[box_index] | mux3;
                }
                else
                {
                    return false;
                }
            }
        }
        return true;
    }
};
```

<a id="652"></a>

### [652. 寻找重复的子树](#l652)

```C++{.line-numbers}
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        vector<TreeNode*> res;
        unordered_map<string, int> mp;
        dfs(root, res, mp);
        return res;
    }
    
    string dfs(TreeNode* root, vector<TreeNode*>& res, unordered_map<string, int>& mp){
        if(root==0) return "";
        //二叉树先序序列化
        string str = to_string(root->val) + "," + dfs(root->left, res, mp) + "," + dfs(root->right, res, mp);
        
        if(mp[str]==1){
            res.push_back(root);
        } 
        mp[str]++;
        return str;
    }
};
```

<a id="771"></a>

### [771. 宝石与石头](#l771)

```C++{.line-numbers}
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        vector<int> count(128, 0);

        for(auto jewel: jewels)
            count[jewel]++;
        
        int res = 0;

        for(auto stone: stones)
            if(count[stone])
                res++;

        return res;
    }
};
```

<a id="3"></a>

### [3. 无重复字符的最长子串](#l3)

```C++{.line-numbers}
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0, right = 0;
        vector<int> index(128, -1);
        int ret = 0;

        for(; right < s.size(); right++)
        {
            if(index[s[right]] != -1)
                left = max(left, index[s[right]]); // 这里必须加上max，考虑示例["abba"]
            
            index[s[right]] = right + 1;
            ret = max(ret, right - left + 1);
        }



        return ret;
    }
};
```

<a id="170"></a>

### [170. 两数之和 III - 数据结构设计](#l170)

```C++{.line-numbers}
class TwoSum {
private:
    unordered_map<int, int> map{};
public:
    /** Initialize your data structure here. */
    TwoSum() {
    }
    
    /** Add the number to an internal data structure.. */
    void add(int number) {
        map[number]++;
    }
    
    /** Find if there exists any pair of numbers which sum is equal to the value. */
    bool find(int value) {
        for(auto [first, second]: map)
        {
            // 注意溢出
            long v = (long)value - (long)first;
            if(v == first && second > 1)
                return true;
            if(v != first && map.find(v) != map.end())
                return true;
        }
        return false;
    }
};
```

<a id="167"></a>

### [167. 两数之和 II - 输入有序数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res;

        int left = 0;
        int right = numbers.size() - 1;
        while(left < right)
        {
            if(numbers[left] + numbers[right] == target)
            {
                res.push_back(left + 1);
                res.push_back(right + 1);
                break;
            }
            else if(numbers[left] + numbers[right] < target)
                left++;
            else
                right--;
        }

        return res;
    }
};

class Solution {
    public int[] twoSum(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; ++i) {
            int low = i + 1, high = numbers.length - 1;
            while (low <= high) {
                int mid = (high - low) / 2 + low;
                if (numbers[mid] == target - numbers[i]) {
                    return new int[]{i + 1, mid + 1};
                } else if (numbers[mid] > target - numbers[i]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
        }
        return new int[]{-1, -1};
    }
}
```

<a id="653"></a>

### [653. 两数之和 IV - 输入 BST](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool findTarget(TreeNode* root, int k, set<int> &s)
    {
        if(root == NULL)
            return false;
        if(s.find(k - root->val) != s.end())
            return true;
        s.insert(root->val);
        return findTarget(root->left, k, s) || findTarget(root->right, k, s);

    }
    bool findTarget(TreeNode* root, int k) {
        set<int> s;
        return findTarget(root, k, s);
    }
};

class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        set<int> s;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            root = q.front(); q.pop();
            if(s.find(k - root->val) != s.end())
                return true;
            s.insert(root->val);
            if(root->left) q.push(root->left);
            if(root->right) q.push(root->right);
        }
        return false;
    }
};

class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        vector<int> res;
        inorder(root,res);
        int left = 0;
        int right = res.size()-1;
        while(left<right)
        {
            int sum = res[left] + res[right];
            if(sum == k) return true;
            else if(sum < k) //和比目标值小，则移动左指针
                left++;
            else
                right--; //和比目标值大，则移动右指针
        }
        return false;

    }
    void inorder(TreeNode *root,vector<int> &res)
    {
        if(root)
        {
            inorder(root->left,res);
            res.push_back(root->val);
            inorder(root->right,res);
        }
    }
};
```

<a id="454"></a>

### [454. 四数相加 II](#l454)

```C++{.line-numbers}
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap;

        for(int a: A)
            for(int b: B)
                umap[a + b]++;

        int count = 0;
        for(int c: C)
            for(int d: D)
                if(umap.find(0 - (c + d)) != umap.end())
                    count +=umap[0 - (c + d)];

        return count;
    }
};
```

<a id="347"></a>

### [347. 前 K 个高频元素](#l347)

```C++{.line-numbers}
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // first对应元素value second对应元素出现次数
        unordered_map<int,int>hashmap;
        vector<int> ret;

        // 记录元素出现次数
        for(int i:nums) hashmap[i]++;

        int maxtimes = 0;
        // 找到元素出现的最高频率次数
        for(auto i:hashmap) {
            if(i.second > maxtimes) maxtimes = i.second;
        }
            
        // 从最高往低走 依次输出
        // 这里会导致时间复杂度特别高
        // [10000000: 1, 1: 40]
        // 这样for循环会执行 10000000 - 1 次
        // 并且每一次都会遍历 41 次
        // 但是还可以再优化，创建反映射
        while(k > 0){
            for(auto i:hashmap){
                if(i.second == maxtimes){
                    ret.push_back(i.first);
                    k--;
                } 
            }
            maxtimes--;
        }
        return ret;
    }
};
```

<a id="288"></a>

### [288. 单词的唯一缩写](#l288)

```C++{.line-numbers}
class ValidWordAbbr 
{
public:
    unordered_map<string, vector<string>> mode_words;

    ValidWordAbbr(vector<string>& dictionary) 
    {   //为了按照题目的设计来。不然自己定个模式，写起来更简洁
        for (auto word: dictionary)
        {
            string mode;
            if (word.size() <= 2)   
                mode = word;
            else
                mode = word[0] + to_string(word.size() - 2) + word.back();
            mode_words[mode].push_back(word);
        }    
    }
    
    bool isUnique(string word) 
    {
        string mode;
        if (word.size() <= 2)
            mode = word; 
        else
            mode = word[0] + to_string(word.size() - 2) + word.back();
        if (mode_words.count(mode) )
        {
            for (auto other_word: mode_words[mode])
            {
                if (word != other_word)
                    return false;
            }
    //     // 这里不能这么写：["a", "a"] 会出错
    //     if(mode_words[mode].size() > 1 || mode_words[mode][0] != word)
    //         return false;
        }
        return true;
    }
};
```

<a id="15"></a>

### [15. 三数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果遍历到的元素已经大于零，那么无论如何与后续的元素
            // 组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

<a id="18"></a>

### [18. 四数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 这种剪枝是错误的，这道题目target 是任意值
            // 例如target为负数的时候，-1 > -5(target)返回，显然错误
            // if (nums[k] > target) {
            //     return result;
            // }
            // 去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 正确去重方法
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    if (nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    } else if (nums[k] + nums[i] + nums[left] + nums[right] < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 去重逻辑应该放在找到一个四元组之后
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }
};

// 添加了剪枝，快了很多
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target)
    {
       vector<vector<int> > res;
       int n = nums.size();
       if (n < 4)   return res; // 特判
       std::sort(nums.begin(), nums.end()); // 排序
       // 选取第一个数
       for (int i = 0; i < n - 3; i++)
       {
            if (i > 0 && nums[i] == nums[i-1])  // 去重
                continue;
            if (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) // 剪枝
                break;
            if (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) // 剪枝
                continue;
            // 选取第二个数
            for (int j = i+1; j < n - 2; j++)
            {
                if (j > i+1 && nums[j] == nums[j-1]) // 去重
                    continue;
                if (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) // 剪枝
                    break;
                if (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) // 剪枝
                    continue;
                // 通过双指针取第三个和第四个数
                int left = j + 1;
                int right = n - 1;
                while (left < right)
                {
                    if (nums[left] + nums[right] < target - nums[i] - nums[j])
                        left++;     // 此两数之和太小，左指针右移
                    else if (nums[left] + nums[right] > target - nums[i] - nums[j])
                        right--;    // 此两数之和太大，右指针左移
                    else
                    {
                        // 找到一组解，左右指针内缩，继续寻找
                        res.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
                        left++; right--;
                        // 去重，注意与上面的不同之处
                        while (left < right && nums[left] == nums[left-1])   left++;
                        while (left < right && nums[right] == nums[right+1])   right--;
                    }
                }
            }
       }
       return res;
    }
};
```

<a id="705"></a>

### [705. 设计哈希集合](#l705)

```C++{.line-numbers}
class MyHashSet {
private:
    vector<list<int>> data;
    static const int base = 769;
    static int hash(int key)
    {
        return key % base;
    }
public:
    MyHashSet(): data(base){
    }
    
    void add(int key) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
            if((*it) == key)
                return;
        data[h].push_back(key);
    }
    
    void remove(int key) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
            if((*it) == key)
            {
                data[h].erase(it);
                return;
            }
    }

    bool contains(int key) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
            if((*it) == key)
                return true;
        
        return false;
    }
};
```

<a id="217"></a>

### [217. 存在重复元素](#l217)

```C++{.line-numbers}
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> set;

        for(int i = 0; i < nums.size(); i++)
            if(set.find(nums[i]) == set.end())
                set.insert(nums[i]);
            else
                return true;
        return false;
    }
};
```

<a id="136"></a>

### [136. 只出现一次的数字](#l136)

```C++{.line-numbers}
// 异或解法
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(auto num: nums)
            res ^= num;

        return res;
    }
};

// 哈希解法
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> set;

        for(auto num: nums)
        {
            if(set.find(num) != set.end())
                set.erase(num);
            else
                set.insert(num);
        }
        return *set.begin();
    }
};
```

<a id="706"></a>

### [706. 设计哈希映射](#l706)

```C++{.line-numbers}
/*
我觉得官方题解应尽可能无懈可击一点，因为它很可能直接影响很多新同学写的代码。对于C++代码：

1.for (auto it = data[h].begin(); it != data[h].end(); it++)
  非必要情况迭代器自增不要用"it++"而应该用"++it"，
  因为++后置返回的是旧的迭代器，这显然是不必要的开销。
  对于非连续性容器，我认为最快的遍历方式应该是
  for (auto &&p : data[h])
  这个包含的应该是（记得C++Primer第五版看到的，未验证）
  for (auto it = data[h].begin(), end = data[h].end(); it != end; ++it)
2.data[h].push_back(make_pair(key, value));
  可以利用emplace优化
  data[h].emplace_back(key, value);
3.hash函数好像可以用inline优化一下。

答：
1.it++ 和 ++it 在上面的语义中没有区别，编译器发现it++ 返回
  的旧迭代器后续没有使用，会把对应的代码优化掉。至于 range 
  for 和使用迭代器遍历也没有本质区别，前者只是个语法糖而已。
2.对的。
3.hash 函数的定义直接写在声明里面的话就是默认 inline 了。
*/

class MyHashMap {
private:
    vector<list<pair<int, int>>> data;
    static const int base = 769;
    static int hash(int key){
        return key % base;
    }
public:
    MyHashMap(): data(base){
    }
    
    void put(int key, int value) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
            if((*it).first == key)
            {
                (*it).second = value;
                return;
            }
        data[h].push_back({key, value});
    }
    
    int get(int key) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
            if((*it).first == key)
            {
                return (*it).second;
            }
        return -1;
    }
    
    void remove(int key) {
        int h = hash(key);
        for(auto it = data[h].begin(); it != data[h].end(); it++)
        {
            if((*it).first == key)
            {
                data[h].erase(it);
                return;
            }
        }
    }
};

```
