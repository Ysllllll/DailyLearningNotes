>**程序员面试金典 04-05.合法二叉搜索树**：实现一个函数，检查一棵二叉树是否为二叉搜索树。
示例 1:
输入:
　　2
　1　　3
输出: true
示例 2:
输入:
　　5
　1　　4
　　　3　6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4。

没有啥思路，想过套模板，但是没有套对。

#### 先序遍历

我们根据结点值大于左子树的所有结点值，同时小于右子树的所有结点值。即：`root->left->val <= root->val < root->right->val`，注意**小于和小于等于**符号

```c++{.line-numbers}
//作者：程序员面试金典
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode *root, long long min, long long max)
    {
        if(!root) return true;

        if(root->val <= min || max <= root->val)
            return false;

        return isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);
    }

    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_MIN, LONG_MAX);
    }
};
```

#### 中序遍历

将二叉搜索树的中序遍历结果保存在数组中，然后判断数组是否有序。但是只有在树中不包含重复值的时候才能这样做。如果包含重复值就存在着问题：

```shell
有效的二叉树        无效的二叉树
    20                 20
20                          20
```

这里我们考虑树不包含重复值，同时我们优化上面的数组，使用一个pre来记录前一个结点，这样降低空间复杂度。

```C++{.line-numbers}
//作者：Sweetiee

class Solution {
private:
    TreeNode* pre;
public:
    bool isValidBST(TreeNode* root) {
        if (!root)
            return true;

        // 访问左子树
        if (!isValidBST(root -> left))
            return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (pre && root -> val <= pre -> val)
            return false;
        pre = root;

        // 访问右子树
        return isValidBST(root -> right);
    }
};
```

---

>**Leetcode 700.二叉搜索树中的搜索**：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。
例如，
给定二叉搜索树:
　　　　4
　　2　　　7
　1　　3
和值: 2
你应该返回如下子树:
　　　2
　　1　　3
在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

这道题很简单，首先可以无差别搜索，也就是对整棵树进行搜索。时间复杂度为$O(N)$。

```C++{.line-numbers}
//作者：Ysllllll
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val == val) return root;

        TreeNode *left = searchBST(root->left, val);
        TreeNode *right = searchBST(root->right, val);

        if(left)
            return left;
        if(right)
            return right;
        return NULL;
    }
};
```

进行优化，只搜索树的某一分支，平均时间复杂度为 $O(logN)$，最差时间复杂度就是树退化为一个双向链表，此时的最坏时间复杂度为 $O(N)$。

```C++{.line-numbers}
//作者：Ysllllll
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root || root->val == val) 
            return root;
        else if(root->val > val)
            return searchBST(root->left, val);
        else
            return searchBST(root->right, val);
    }
};
```

---

>**Leetcode 701.二叉搜索树中的插入操作**：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。
示例 1：
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
示例 2：
输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]
示例 3：
输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]
提示：
>
>- 给定的树上的节点数介于 $0$ 和 $10^4$ 之间
>- 每个节点都有一个唯一整数值，取值范围从 $0$ 到 $10^8$
>- $-10^8 <= val <= 10^8$
>- 新值和原始二叉搜索树中的任意节点值都不同

```C++{.line-numbers}
class Solution {
public:

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root) return new TreeNode(val);
        if(root->val <= val)
            root->right = insertIntoBST(root->right, val);
        else if(root->val > val)
            root->left = insertIntoBST(root->left, val);
        return root;
    }
};
```