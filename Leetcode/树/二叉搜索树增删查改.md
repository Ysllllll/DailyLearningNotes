>**程序员面试金典 04-05.合法二叉搜索树**：实现一个函数，检查一棵二叉树是否为二叉搜索树。
示例 1:
输入:
　　2
　1　　3
输出: true
示例 2:
输入:
　　5
　1　　4
　　　3　6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4。

没有啥思路，想过套模板，但是没有套对。

#### 先序遍历

我们根据结点值大于左子树的所有结点值，同时小于右子树的所有结点值。即：`root->left->val <= root->val < root->right->val`，注意**小于和小于等于**符号

```c++{.line-numbers}
//作者：程序员面试金典
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode *root, long long min, long long max)
    {
        if(!root) return true;

        if(root->val <= min || max <= root->val)
            return false;

        return isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);
    }

    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_MIN, LONG_MAX);
    }
};
```

#### 中序遍历

将二叉搜索树的中序遍历结果保存在数组中，然后判断数组是否有序。但是只有在树中不包含重复值的时候才能这样做。如果包含重复值就存在着问题：

```shell
有效的二叉树        无效的二叉树
    20                 20
20                          20
```

这里我们考虑树不包含重复值，同时我们优化上面的数组，使用一个pre来记录前一个结点，这样降低空间复杂度。

```C++{.line-numbers}
//作者：Sweetiee

class Solution {
private:
    TreeNode* pre;
public:
    bool isValidBST(TreeNode* root) {
        if (!root)
            return true;

        // 访问左子树
        if (!isValidBST(root -> left))
            return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (pre && root -> val <= pre -> val)
            return false;
        pre = root;

        // 访问右子树
        return isValidBST(root -> right);
    }
};
```
