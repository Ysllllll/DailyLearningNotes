### 二叉树的最近公共祖先

考虑：

- 二叉树是否是二叉搜索树
  - 普通二叉树
  - 二叉搜索树
- 二叉树中是否有父节点
  - 有父节点
    - 直接获取两条路径并求交点
  - 没有父节点
    - 关键点在如何区分两个节点是在父节点的两侧还是同侧
- 要不要判断待搜索节点是否在树中
- 递归还是迭代

>**剑指offer 68-I.二叉搜索树的最近公共祖先**：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。
[注意：本题与主站 235 题相同](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

#### 原理

若 `root` 是 `q`、`p` 两个结点的公共祖先，则他们的位置关系只有三种：

- `p` 和 `q` 在 `root` 的子树中，且分列 `root` 的异侧（即分别在左、右子树中）；
- `p=root`，且 `q` 在 `root` 的左或右子树中；
- `q=root`，且 `p` 在 `root` 的左或右子树中；

本题给定了两个重要条件：树为二叉搜索树、树的所有节点的值都是唯一的。根据以上条件，可方便地判断 `p,q` 与 `root` 的子树关系，即：

若 `root.val < p.val`，则 `p` 在 `root` 右子树中；
若 `root.val > p.val`，则 `p` 在 `root` 左子树中；
若 `root.val = p.val`，则 `p` 和 `root` 指向同一节点 。

#### 迭代

```C++{.line-numbers}
//作者：Krahets
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root)
        {
            if(p->val < root->val && q->val < root->val)
                root = root->left;
            else if(p->val > root->val && q->val > root->val)
                root = root->right;
            else
                break;
        }
        return root;
    }
};
```

#### 递归

```C++{.line-numbers}
//作者：Krahets
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return NULL;
        
        if(p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else if(p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);;
        return root;
    }
};
```

- 复杂度分析
  - 迭代/递归时间复杂度$O(N)$：其中 N 为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 $logN$ （满二叉树），最大为 N （退化为链表）。
  - 迭代空间复杂度$O(1)$：使用常数大小的额外空间。
  - 递归空间复杂度$O(N)$：最差情况下，即树退化为链表时，递归深度达到树的层数 N

---

>**剑指offer 68-II.二叉树的最近公共祖先**
>**程序员面试金典 04-08.首个共同祖先**
>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
说明:
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
[注意：本题与主站 236 题相同](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

#### 递归版本一

```C++{.line-numbers}
//作者：Ysllllll
class Solution {
public:
    bool cover(TreeNode* root , TreeNode* p)
    {
        if(root == NULL) return false;
        if(root == p) return true;
        return cover(root->left, p) || cover(root->right, p);
    }
    TreeNode* commonAncestor(TreeNode* root, TreeNode* p, TreeNode* q){
        if(root == NULL || root == p || root == q) return root;

        bool pIsOnLeft = cover(root->left, p);
        bool qIsOnLeft = cover(root->left, q);
        if(pIsOnLeft!=qIsOnLeft)
            return root;
        return pIsOnLeft?commonAncestor(root->left, p,q):commonAncestor(root->right, p,q);    
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!cover(root,p)||!cover(root,q))  return NULL;//判断两个结点是否都在树中
        return commonAncestor(root,p,q);
    }
};
```

毫无疑问，递归版本一存在很多重复的遍历。可以考虑这样一种极端情况：当树中的每一节点处，它的子树都位于节点的左侧，就退化为了一个链表。同时假若此时我们要找的两个结点为同一个叶子节点，此时会反复调用两个cover函数n次，每一次cover的递归深度都是当前遍历节点的子树高度。则时间复杂度就是：`n+n-1+...+3+2+1` = $O(N^2)$。空间复杂度就是递归深度为：$O(N)$

#### 递归版本二

```C++{.line-numbers}
//作者：jarvis1890
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //先找到p或者q就返回
        if(root == NULL || root == p || root == q) return root;
        //在左子树找p或q，假如p和q都在左子树，返回的那个值就是祖先
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        //在右子树找p或者q，假如p和q都在右子树，返回的那个值就是祖先
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left == NULL) return right;
        if(right == NULL) return left;
        // p和q一个在左子树一个在右子树
        return root;
    }
};
```

- 递归版本二的复杂度分析：
  - 时间复杂度 O(N)：其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。
  - 空间复杂度 O(N)：最差情况下，递归深度达到 N，系统使用 O(N) 大小的额外空间。

这里要注意这个代码存在着bug，考虑这样一种情况：树只有一个节点5，p=5，q=6。模拟运行会得到5。但是显然6不在树中。解决这个bug的方法就是先遍历一遍看是否都在树中。

#### 迭代+递归写法

思路是先把路径找到，然后找两条路径的公共结点。

```C++{.line-numbers}
//作者：Ysllllll
class Solution {
public:
    void traverse(TreeNode* root, TreeNode* p, TreeNode* q, vector<TreeNode*> &path, vector<TreeNode*> &path_p, vector<TreeNode*> &path_q)
    {
        if(root == NULL) return;

        path.push_back(root);

        if(root == q) path_q = path;
        if(root == p) path_p = path;

        if(path_q.size() == 0 || path_p.size()==0)
        {
            traverse(root->left, p, q, path, path_p, path_q);
            traverse(root->right, p, q, path, path_p, path_q);
        }
        path.pop_back();
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return root;
        if(p == q) return p;

        vector<TreeNode*> path;
        vector<TreeNode*> path_p;
        vector<TreeNode*> path_q;

        traverse(root, p, q, path, path_p, path_q);

        TreeNode* comm;
        for(int i = 0; i < path_p.size() && i < path_q.size(); i++)
            if(path_p[i] == path_q[i])
                comm = path_p[i];
            else
                break;
        return comm;
    }
};
```

#### 迭代写法

```C++{.line-numbers}
//作者：BAKEZQ
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        stack<TreeNode *> s;
        TreeNode * lca = nullptr;
        int find = 0, lcalevel = INT_MAX;

        while (root || !s.empty()) {
            if (root) {
                s.push(root);
                root = root->left;
            }
            else {
                root = s.top(); s.pop();
                if (root == p || root == q)
                    find++;
                if (find && s.size() < lcalevel) {
                    lca = root;
                    lcalevel = s.size();
                }
                if (find == 2)
                    return lca;
                
                root = root->right;
            }
        }

        return nullptr;
    }
};
```
