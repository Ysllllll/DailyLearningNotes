#

>**剑指 Offer 48.最长不含重复字符的子字符串**：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1:
　输入: "abcabcbb"
　输出: 3
　解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:
　输入: "bbbbb"
　输出: 1
　解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:
　输入: "pwwkew"
　输出: 3
　解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
提示：
　s.length <= 40000
[注意：本题与主站 3 题相同](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

考虑用动态规划来做：

首先，我们要定义一个数组，根据题目，我们定义一个一维的数组，数组元素的含义：`dp[i]` 代表前 `i` 个字符中最长的不连续子串。

然后，我们根据题目给的特例来填这个数组，注意特例一定要弄明白，否则状态转移会出错：

```shell
字符串： a   b   c   a   b   c   a   a
数组： | 1 | 2 | 3 | 3 | 3 | 3 | 3 | 1 |
```

根据这个特例，我们尝试找到它的状态转移方程：

`dp[i]` 与 `dp[i-1]、dp[i-2]...` 之间的关系。首先最朴素的，来了一个元素，我们在不考虑是否重复的情况下，`dp[i] = dp[i-1] + 1`；

到了这里找规律应该陷入了死胡同了，因为显然 `dp[i]` 不仅与 `dp[i-1]` 有关系，还可能与 `dp[0]` 有关系。例如上面例子中的 `s[0] = s[2] = "a"`，`dp[2]` 不仅与 `dp[1]` 有关，还受到 `dp[0]` 的影响。

此时就干脆的遍历比较。所以求 `dp[i]`，我们已经有了一个不完整的、朴素的状态转移式子 `dp[i] = dp[i - 1] + 1`。另外一半，则遍历 `0~i-1`，遍历的过程中我们需要记录的是前面最后一个 `s[j]` 与 `s[i]` 重复的字符在哪里，然后得出他们之间的长度 `i-j`，这个长度可能也是一个最长子串，最后就是取两个状态转移得到结果的最小值。最后忧虑的一点就是这样是否完整呢，立马编码检验，不对再想。

```C++
//作者：Ysllllll
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int len = s.length();
        if (!len) return 0;

        vector<int> dp(len, 0);
        dp[0] = 1;

        for (int i = 1; i < len; i++)
        {
            int t = 1;
            for (int j = 0; j < i; j++)
            {
                t++;
                if (s[i] == s[j])
                    t = 1;
            }
            dp[i] = min(dp[i - 1] + 1, t);
        }

        return *max_element(dp.begin(), dp.end());
    }
};
```

能够顺利通过，说明思路正确，但是可以发现上面的时间复杂度无论如何都不可能是O(n)，没有达到最优，最优的也实在想不出来了，直接看评论大神们做的。

#### 改进一：从右至左搜索重复字符

下面这段代码摘自上面的代码段，可以看见在寻找最后一个重复的字符时，是从左 `0` 至右 `i-1` 寻找的。我们可以改进搜寻方向：从右 `i-1` 至左 `0`。

```c++
            int t = 1;
            for (int j = 0; j < i; j++)
            {
                t++;
                if (s[i] == s[j])
                    t = 1;
            }
```

改进代码如下：

```C++
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        int len = s.length();
        if (!len) return 0;

        vector<int> dp(len, 0);
        dp[0] = 1;

        for (int i = 1; i < len; i++)
        {   
            int j = i - 1;
            //下面的代码要小心，不可写为s[i] != s[j] && j >= 0
            //当j=-1的时候，上面的写法先判断第一个导致s[j]会越界
            //写为下面这种形式，&&的短路特性会在j=-1的时候优先判
            //断j>=0然后结束for循环，不会执行s[i] != s[j]，所以
            //不会造成越界
            for (;j >= 0 && s[i] != s[j]; j--);
            dp[i] = min(dp[i - 1] + 1, i - j);
        }

        return *max_element(dp.begin(), dp.end());
    }
};
```

结果表明从左 `0` 至右 `i-1` 方向的搜寻比从右 `i-1` 至左 `0` 方向的搜寻慢很多很多，为何呢？

因为字符最多只有128个，所以从右 `i-1` 至左 `0` 方向最多最多搜寻128次，而从左 `0` 至右 `i-1` 方向会搜寻完整个 `0~i-1` 的字符，以确保正确的找到最后一个与 `s[i]` 重复的字符。

- 复杂度分析：
  - 时间复杂度 $O(N^2)$： 其中 `N` 为字符串长度，动态规划需遍历计算 `dp` 列表，占用 $O(N)$ ；每轮计算 $dp[j]$ 时搜索 `i` 需要遍历 `j` 个字符，占用 $O(N)$。
  - 空间复杂度 $O(1)$：几个变量使用常数大小的额外空间

#### 改进二：使用哈希记录最后一个重复的字符

