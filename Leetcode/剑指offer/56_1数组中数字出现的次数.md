#

>**剑指offer 56-I.数组中数字出现的次数**：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
示例 1：
　输入：nums = [4,1,4,6]
　输出：[1,6] 或 [6,1]
示例 2：
　输入：nums = [1,2,10,4,1,4,3,3]
　输出：[2,10] 或 [10,2]
限制：
　2 <= nums.length <= 10000

通过这道题也算学到了一些关于位运算的技巧，有以下几种位运算：

|   运算符   |                      特性                      |
| :--------: | :--------------------------------------------: |
|  &（与）   |                      短路                      |
|  I（或）   |                      短路                      |
|  ~（非）   |                      取反                      |
| ^（异或）  | 相同为0，相异为1，与0异或该位不变，与1异或取反 |
| <<（左移） |                      左移                      |
| >>（右移） |            负数右移时最高位补符号位            |

这里需要用到异或的特点：$a\land c\land c = a$，$a\land c\land b\land c = a\land b$。

题目中说的是数组中只有两个数不一样，所以我们全部异或后将得到这两个数的异或结果，但是无法得到这两个数。受到第一个式子的启发，如果我们将这个数组分为两组，并且这两个不同的数字位于不同的子分组，然后分别在两个子分组中再做异或运算就能单独得到这两个数字，异或运算比较简单，这道题的**关键点**就是如何将数组分为两个子数组，并且这两个不同的数刚好位于不同的子数组里面。

下面按照这个思路来：

**第一步**：取所有数字异或，根据 $a\land c\land b\land c = a\land b$,也就是说最后得出的结果是两个数值 `a,b` 异或的结果 `nXor`；

```C++{.line-numbers}
int nXor = 0;
for (int i = 0; i < nums.size(); i++)
{
     nXor ^= nums[i];
}
```

**第二步**：这里是本题的关键，如何把这两个数分在不同的两个子数组里面。由于 `a,b` 不同，再根据二进制异或的特性：相同位异或为0，不同位异或为1。所以异或结果中，`nXor` 某一位若为1，代表这两个数字 `a,b` 的这一位不同（注意是二进制形式）。`a,b` 两个数的二进制表示中有多少个不同位，`nXor` 中就有多少个位为1。这里我们只需要找到其中一位就行了，为了方便就找最低位，取出异或结果的最右侧的 `1（m）`，即取出 `a,b`的二进制中不同的最低位置；

```C++{.line-numbers}
int m = 1;
while ((nXor & m) == 0)
    m <<= 1;
```

这一步还有一种方法：

```C++{.line-numbers}
int m = nXor & (-nXor);//得到nXor最低位的1，等价于上面的方式

// 为何？
// 我们以 6(0000 0110) 为例，我们需要得到最低位的那个1
// 假设int是8位
// -6  原码1000 0110
//     反码1111 1001
//     补码1111 1010  //计算机中以补码的形式存储负数
// 所以得到：
// nXor & (-nXor) 
//   0000 0110
// & 1111 1010
//   0000 0010
// 所以m = nXor & (-nXor) 就是保留nXor的最后一个1，并且将其他位变为0，也就是nXor最后一个1是倒数第二位。
//作者：chuang-bian-gu-shi
```

**第三步**：根据 `m` 值，与每个数值 `&` 求值，根据值分组，因为 `m` 标识 `a,c` 之间的不同，所以 `a,b` 取值结果肯定不同，会被分到不同组，而因为两个 `b` 与 `k` 取值结果肯定会被分到同一组；

**第四步**：把两个组分别异或，最后的结果即 `a,b`；

```C++{.line-numbers}
int x = 0,y = 0;
for(int i = 0; i < len; i++)
    if(nums[i] & m)
        x^=nums[i];
    else
        y^=nums[i];

return {x,y};
```

```C++{.line-numbers}
//作者：木木
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int len = nums.size();

        int nXor = 0;
        for(int i = 0; i < len; i++)
            nXor^=nums[i];

        int m = 1;
        while ((nXor & m) == 0) m <<= 1;
        
        int x = 0,y = 0;
        for(int i = 0; i < len; i++)
            if(nums[i] & m) x^=nums[i];
            else y^=nums[i];

        return {x,y};
    }
};
```
