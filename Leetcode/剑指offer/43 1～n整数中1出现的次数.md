#

>**剑指offer 43.1～n 整数中 1 出现的次数**：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
示例 1：
　输入：n = 12
　输出：5
示例 2：
　输入：n = 13
　输出：6
限制：
　1 <= n < 2^31
[注意：本题与主站 233 题相同](https://leetcode-cn.com/problems/number-of-digit-one/)

##### 解法一：找规律

寻找 1 ~ n 整数中 1 出现的个数，如果能够联想到密码锁，就能够大概知道怎么找规律了。密码锁是固定某一位，然后旋转其它位。这里我们固定某一位上的数字为 1，看其它位一共有多少种组合，这些组合表明了这一位上会出现多少次 1。所以将问题转化为某一位出现1的次数是多少，然后将所有位出现 1 的次数加起来，就是 1 ~ n 整数中 1 出现的次数。

```bash
举例如下：
考虑如下的四位数n，我们仅看n的十位，n的十位可能是0~9中的
任何一个数字，我们要做的是不管十位原本为多少，我们都要固
定住该位为1，然后旋转其它位，其它位旋转的组合就是该位为 1
的次数。
更进一步在固定该位为1之前，我们需要考察该位原本是多少从
而分为三种类型：
    类型1：原本是0，固定为1。
    类型2：原本是1，固定为1。
    类型3：原本是2~9，固定为1。
为什么？因为将该位上原本的数固定为1后，高位和低位可以旋转
的范围不同。

n如下：
       high  | cur | low   digital（位权）= 10
    [ 2    3    0    7 ]  类1：十位为0
    [ 2    3    1    7 ]  类2：十位为1
    [ 2    3    2    7 ]  类3：十位为2~9
    
1.  [ 2  3  0  8 ]  十位原本为0，固定这一位为1，看其它位有多少种旋转组合。
    千位百位： 00 ~ 22 共23种旋转方式（为什么不能是23，因为此时1固定，那么 2310 > 2307）
    个位：     0 ~ 9  共10种旋转方式
    共有23 * 10种组合，这里我们需要使用另外的计算方式来得到这个230。如下
    实际计算方式是：high * digital =  23 * 10 种 = 230 种

    另外一个角度，把它当成一个三位数的锁在旋转
    [00] 1 [0] ~ [22] 1 [9] -> [00][0] ~ [22][9] = 230

2.  [ 2  3  1  8 ]  十位原本为1，固定这一位为1，看其它位有多少种旋转组合。
    千位百位：00 ~ 22 共23种旋转方式
    个位：     0 ~ 9  共10种旋转方式
    千位百位：   23   共1种旋转方式（注意与上面的不同，可以旋转到23，因为2310 < 2317，但是此时个位就只能旋转8次）
    个位：     0 ~ 7  共8种旋转方式
    实际计算方式是： high * digital + low + 1 = 23 * 10 + 7 + 1 = 238 种

3.  [ 2  3  2  8 ]  十位原本为2~9，固定这一位为1，看其它位有多少种旋转组合。
    千位百位：00 ~ 23 共24种旋转方式
    个位：     0 ~ 9  共10种旋转方式（注意我们固定了十位为1，所以2310~2319 < 2328）
    实际计算方式是：(high + 1) * digital = 24 * 10 = 240

其它位计算方式一样。
```

```C++
//作者：Ysllllll
class Solution {
public:
    int countDigitOne(int n) {
        if(!n) return 0;

        int res = 0;
        long long digital = 1;
        long long high, cur = 0, low;
        while(n / digital)
        {
            low = n % digital;
            cur = (n / digital) % 10;
            high = n / (digital * 10);
            switch(cur)
            {
                case 0:
                    res += high * digital;
                    break;
                case 1:
                    res += high * digital + low + 1;
                    break;
                default:
                    res += (high + 1) * digital;
            }
            digital *= 10;
        }
        return res;
    }
};
```

##### 复杂度分析

- 时间复杂度 $O(\log n)$： 循环内的计算操作使用 $O(1)$ 时间；循环次数为数字 nn 的位数，即 $\log_{10}{n}$ ，因此循环使用 $O(\log n)$ 时间。
- 空间复杂度 $O(1)$ ： 几个变量使用常数大小的额外空间。

看评论区有数位dp，不太懂，后面遇见了再学习。
