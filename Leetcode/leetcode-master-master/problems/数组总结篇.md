<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >
</p>
<p align="center">
  <a href="https://github.com/youngyangyang04/leetcode-master"><img src="https://img.shields.io/badge/Github-leetcode--master-lightgrey" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201115103410182.png"><img src="https://img.shields.io/badge/刷题-微信群-green" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201210231711160.png"><img src="https://img.shields.io/badge/公众号-代码随想录-brightgreen" alt=""></a>
  <a href="https://space.bilibili.com/525438321"><img src="https://img.shields.io/badge/B站-代码随想录-orange" alt=""></a>
  <a href="https://www.zhihu.com/people/sun-xiu-yang-64"><img src="https://img.shields.io/badge/知乎-代码随想录-blue" alt=""></a>
  <a href="https://www.toutiao.com/c/user/60356270818/#mid=1633692776932365"><img src="https://img.shields.io/badge/头条-代码随想录-red" alt=""></a>
</p>

# 数组理论基础

数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力

也就是说，想法很简单，但实现起来 可能就不是那么回事了。

首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以方便的通过下表索引的方式获取到下表下对应的数据。

举一个字符数组的例子，如图所示：

![算法通关数组](https://img-blog.csdnimg.cn/2020121411152849.png)

需要两点注意的是

* **数组下表都是从0开始的。**
* **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

例如删除下表为3的元素，需要对下表为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://img-blog.csdnimg.cn/2020121411155232.png)

而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

**数组的元素是不能删的，只能覆盖。**

那么二维数组直接上图，大家应该就知道怎么回事了

![算法通关数组2](https://img-blog.csdnimg.cn/20201214111612863.png)

**那么二维数组在内存的空间地址是连续的么？**

我们来举一个例子，例如： `int[][] rating = new int[3][4];` ， 这个二维数据在内存空间可不是一个 `3*4` 的连续地址空间

看了下图，就应该明白了：

![算法通关数组3](https://img-blog.csdnimg.cn/20201214111631844.png)

所以**二维数据在内存中不是 `3*4` 的连续地址空间，而是四条连续的地址空间组成！**

# 数组的经典题目

在面试中，数组是必考的基础数据结构。

其实数据的题目在思想上一般比较简单的，但是如果想高效，并不容易。

我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。

## 二分法

[数组：每次遇到二分法，都是一看就会，一写就废](https://mp.weixin.qq.com/s/fCf5QbPDtE6SSlZ1yh_q8Q)

这道题目呢，考察的数据的基本操作，思路很简单，但是在通过率在简单题里并不高，不要轻敌。

可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目

暴力解法时间复杂度：O(n)
二分法时间复杂度：O(logn)

在这道题目中我们讲到了**循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

**二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力**。

## 双指针法

* [数组：就移除个元素很难么？](https://mp.weixin.qq.com/s/wj0T-Xs88_FHJFwayElQlA)

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**  

暴力解法时间复杂度：O(n^2)
双指针时间复杂度：O(n)

这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为一下两点：

* 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。
* C++中vector和array的区别一定要弄清楚，vector的底层实现是array，所以vector展现出友好的一些都是因为经过包装了。

双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。

## 滑动窗口

* [数组：滑动窗口拯救了你](https://mp.weixin.qq.com/s/UrZynlqi4QpyLlLhBPglyg)

本题介绍了数组操作中的另一个重要思想：滑动窗口。

暴力解法时间复杂度：O(n^2)
滑动窗口时间复杂度：O(n)

本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。

## 模拟行为

* [数组：这个循环可以转懵很多人！](https://mp.weixin.qq.com/s/KTPhaeqxbMK9CxHUUgFDmg)

模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。

在这道题目中，我们再一次介绍到了**循环不变量原则**，其实这也是写程序中的重要原则。

相信大家又遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，踩了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实**真正解决题目的代码都是简洁的，或者有原则性的**，大家可以在这道题目中体会到这一点。

# 总结

从二分法到双指针，从滑动窗口到螺旋矩阵，相信如果大家真的认真做了「代码随想录」每日推荐的题目，定会有所收获。

推荐的题目即使大家之前做过了，再读一遍的文章，也会帮助你提炼出解题的精髓所在。

如果感觉有所收获，希望大家多多支持，打卡转发，点赞在看 都是对我最大的鼓励！

最后，大家周末愉快！

> **题目汇总**
>
> * 数组：每次遇到二分法，都是一看就会，一写就废
>   * **[Leetcode 35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)** [速览题解](#35)
> * 数组：就移除个元素很难么？
>   * **[Leetcode 27. 移除元素](https://leetcode-cn.com/problems/remove-element/submissions/)** [速览题解](#27)
> * 数组：滑动窗口拯救了你
>   * **[Leetcode 209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)** [速览题解](#209)
> * 数组：这个循环可以转懵很多人！
>   * **[Leetcode 54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)** [速览题解](#54)
>   * **[Leetcode 59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)** [速览题解](#59-2)

<a id="35"></a>

```C++{.line-numbers}
//35.搜索插入位置
class Solution
{
public:
    int searchInsert(vector<int> &nums, int target)
    {
        //左闭右闭[left, right]
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) // 当left==right，区间[left, right]依然有效
        {                                          
            int mid = left + ((right - left) / 2); // 防止溢出 等同于(left + right)/2
            if (target < nums[mid])
                right = mid - 1; // target 在左区间，所以[left, mid - 1]
            else if (nums[mid] < target)
                left = mid + 1; // target 在右区间，所以[mid + 1, right]
            else
                return mid; // nums[mid] == target
        }
        return left;
    }
};

class Solution
{
public:
    int searchInsert(vector<int> &nums, int target)
    {
        //左闭右开[left, right)
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里，[left, right)  target
        while (left < right) // 因为left == right的时候，在[left, right)是无效的空间
        { 
            int mid = left + ((right - left) >> 1);
            if (target < nums[mid])
                right = mid; // target 在左区间，在[left, mid)中
            else if (nums[mid] < target)
                left = mid + 1; // target 在右区间，在 [mid+1, right)中
            else
                // nums[mid] == target
                return mid; // 数组中找到目标值的情况，直接返回下标
        }
        return left;
    }
};
```

<a id="27"></a>

```C++{.line-numbers}
//27.移除元素
class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        //头尾指针
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right)
        {
            while(left <= right && nums[right] == val)
                right--;
            while(left <= right && nums[left] != val)
                left++;
            if(left <= right && left < nums.size() && right > 0)//注意这里要有left <= right
                swap(nums[left], nums[right]);
        }
        return right + 1;
    }
};

class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        //快慢指针
        int slow = 0; 
        for (int fast = 0; fast < nums.size(); fast++)  
            if (val != nums[fast])
                nums[slow++] = nums[fast]; 
        return slow;
    }
};
```

<a id="209"></a>

```C++{.line-numbers}
//209.长度最小的子数组
class Solution
{
public:
    int minSubArrayLen(int s, vector<int> &nums)
    {
        int result = INT32_MAX;
        int sum = 0;       // 滑动窗口数值之和
        int i = 0;         // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++)
        {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s)
            {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

<a id="54"></a>

```C++{.line-numbers}
//54. 螺旋矩阵
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};

```

<a id="59-2"></a>

```C++{.line-numbers}
//59-II. 螺旋矩阵II
class Solution
{
public:
    vector<vector<int>> generateMatrix(int n)
    {
        if (!n) return {}; //若数组为空，直接返回答案
        vector<vector<int>> matrix(n, vector<int>(n));
        int u = 0; //赋值上下左右边界
        int d = n - 1;
        int l = 0;
        int r = n - 1;
        int num = 1;
        while (true)
        {
            for (int i = l; i <= r; ++i) matrix[u][i] = num++; //向右移动直到最右
            if (++u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同

            for (int i = u; i <= d; ++i) matrix[i][r] = num++; //向下
            if (--r < l) break; //重新设定有边界

            for (int i = r; i >= l; --i) matrix[d][i] = num++; //向左
            if (--d < u) break; //重新设定下边界

            for (int i = d; i >= u; --i) matrix[i][l] = num++; //向上
            if (++l > r) break; //重新设定左边界
        }
        return matrix;
    }
};
```
