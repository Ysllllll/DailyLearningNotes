<a id="base"></a>

## 基础系列

[关于动态规划，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486381&idx=1&sn=b8b913edabdab1208bf677b9578442e7&scene=21#wechat_redirect)
[动态规划：斐波那契数](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486389&idx=1&sn=c04a762fa0d83aad2ef8738aa659523b&scene=21#wechat_redirect)
[动态规划：爬楼梯](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486421&idx=2&sn=2257ee9d1a7a46ba3e53acf965aa38d6&scene=21#wechat_redirect)
[动态规划：使用最小花费爬楼梯](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486432&idx=1&sn=5f449828e7fbe769540742e91b3fe13c&scene=21#wechat_redirect)
[本周小结！（动态规划系列一）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486446&idx=2&sn=ca6e87ecba6d0fb5c634d1007cece5ac&scene=21#wechat_redirect)
[动态规划：不同路径](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486478&idx=1&sn=17403b8995e6bf2a46a6800803f6aabd&scene=21#wechat_redirect)
[动态规划：不同路径还不够，要有障碍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486510&idx=2&sn=3b410fa6a9ad7cd763a7cd0f4928dfa7&scene=21#wechat_redirect)
[动态规划：整数拆分，你要怎么拆？](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486520&idx=1&sn=736878a6770a638d0cea0011bed187bd&scene=21#wechat_redirect)
[动态规划：不同的二叉搜索树](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486532&idx=1&sn=9c3d605f6bf81027f9f39d1c45b8c4a6&scene=21#wechat_redirect)
[本周小结！（动态规划系列二）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486564&idx=2&sn=89ebcf9fa23ef9935ebfe1d5824b9dc2&scene=21#wechat_redirect)

<a id="package"></a>

## 背包问题系列

[动态规划：关于 01 背包问题，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486598&idx=1&sn=dd7d0530dd7a5caef7ce70cc3d6eee3f&scene=21#wechat_redirect)
[动态规划：关于 01 背包问题，你该了解这些！（滚动数组）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486624&idx=2&sn=96e8c6344dc25f57462b675b55ccd6e7&scene=21#wechat_redirect)
[动态规划：分割等和子集可以用 01 背包！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486632&idx=1&sn=4bb229e3f3f5774ac684c0127c88c984&scene=21#wechat_redirect)
[动态规划：最后一块石头的重量 II](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486644&idx=1&sn=548c90df36b47d67290b5667c7cec3d3&scene=21#wechat_redirect)
[本周小结！（动态规划系列三）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486683&idx=2&sn=db28c1e34214a65b92cf2bd70d88ff3c&scene=21#wechat_redirect)
[动态规划：目标和！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486709&idx=1&sn=75f1f43d96dbd1c5c3e281b8963e3c50&scene=21#wechat_redirect)
[动态规划：一和零！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486739&idx=2&sn=e226eacf67df9b6c784264f954ae42bf&scene=21#wechat_redirect)
[动态规划：关于完全背包，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486748&idx=1&sn=dca9f65b75a75c50c502ae8aba279877&scene=21#wechat_redirect)
[动态规划：给你一些零钱，你要怎么凑？](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486757&idx=1&sn=36f5eb60bfe4d8993cf3b3def5645a34&scene=21#wechat_redirect)
[本周小结！（动态规划系列四）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486780&idx=2&sn=fdde680deb4ae6b9b3f1f08893039a73&scene=21#wechat_redirect)
[动态规划：Carl 称它为排列总和！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486826&idx=2&sn=80de2ae278bfd0c906d51fd012d37565&scene=21#wechat_redirect)
[动态规划：以前我没得选，现在我选择再爬一次！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486833&idx=1&sn=beda10fdf8f53e8596dd3ad56ff751d5&scene=21#wechat_redirect)
[动态规划：给我个机会，我再兑换一次零钱](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486848&idx=1&sn=fec1c0c36789f4929a9067910afd600b&scene=21#wechat_redirect)
[动态规划：一样的套路，再求一次完全平方数](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486872&idx=2&sn=01a3b81edafd125812d8860e89a6407f&scene=21#wechat_redirect)
[本周小结！（动态规划系列五）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486884&idx=1&sn=27552812d5194c7ce8eafceedc5cc222&scene=21#wechat_redirect)
[动态规划：单词拆分](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486916&idx=2&sn=739861fa954827bff3591459da514443&scene=21#wechat_redirect)
[动态规划：关于多重背包，你该了解这些！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486924&idx=1&sn=261b70e810ffc27c197b9b353678b87c&scene=21#wechat_redirect)
[听说背包问题很难？这篇总结篇来拯救你了](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247486998&idx=1&sn=d0c7ea872aabe0d27986922089edd298&scene=21#wechat_redirect)

其它参数资料：[0-1 背包问题](https://www.jianshu.com/p/a66d5ce49df5)、[动态规划之 01 背包问题（最易理解的讲解）](https://blog.csdn.net/mu399/article/details/7722810?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.baidujs)

## 打家劫舍系列

[动态规划：开始打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487032&idx=2&sn=51fe9348fabe8bc56c69358e790baf43&scene=21#wechat_redirect)
[动态规划：继续打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487055&idx=2&sn=9db1e211ebc4b9b066ff699f77534c76&scene=21#wechat_redirect)
[动态规划：还要打家劫舍！](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487067&idx=1&sn=bd543182c421b100c1d5db5b699666f3&scene=21#wechat_redirect)

## 股票系列

[动态规划：买卖股票的最佳时机](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487087&idx=2&sn=bb070ba67efbc375b704f229604652f8&scene=21#wechat_redirect)
[动态规划：本周我们都讲了这些（系列六）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487099&idx=1&sn=0215d476bbf9344e86973df907eda4c9&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 II](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487224&idx=1&sn=a6ad54c3ff36c501a35e8423405f2724&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 III](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487244&idx=2&sn=d4cefe597a0d5500adec6bff944c4bf5&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机 IV](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487253&idx=1&sn=662e863724c4c8588b79669db553f9ec&scene=21#wechat_redirect)
[动态规划：最佳买卖股票时机含冷冻期](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487286&idx=2&sn=4e129dbd298d907ad434a86ec25fed88&scene=21#wechat_redirect)
[动态规划：本周我们都讲了这些（系列七）](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487314&idx=2&sn=15e34495a269fa42fba6e0cc26c4cba1&scene=21#wechat_redirect)
[动态规划：买卖股票的最佳时机含手续费](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487353&idx=2&sn=fba963ef370c60328b39a620ece4e2a6&scene=21#wechat_redirect)

## 子序列系列

[动态规划：最长递增子序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487371&idx=2&sn=f57561d52e2322279e2c349a24757faa&scene=21#wechat_redirect)
[动态规划：最长连续递增序列](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247487388&idx=2&sn=87d091d532b2e2f57ad7c1eb0b56b30b&scene=21#wechat_redirect)

<a id="TopicSummary"></a>

> **题目汇总**
>
> - [基础系列](#base)
>   - **[Leetcode 509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/submissions/)** [速览题解](#509)
>   - **[Leetcode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)** [速览题解](#70)
>     简评：这道题还有一个升级版，如果我能够走 1 步、2 步、3 步、...、m 步，那请问我有多少种走法。这样问的一个思路就是，我将楼梯看成一个字符串，然后对这个字符串进行切割，切成多个子字符串，然后要保证子字符串的最大长度是 m。其实就是排列组合。另外这道题也表明了 **dp 数组的初始化不要为了初始化而初始化，如果某一个 dp[i] 没有意义，我们不初始化它就是了**
>   - **[Leetcode 746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)** [速览题解](#746)
>     简评：这道题是在第 70 题的基础之上而来的，这种类型的就存在一种规律，需要总结归纳
>   - **[Leetcode 62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)** [速览题解](#62)
>     简评：考虑一下空间复杂度和时间复杂度。这道题还可以用数学公式做，一共要走 m+n-2 步，其中要横向走 m-1 步，纵向走 n-1 步，那么就是一个组合问题，但是组合公式得记一下
>   - **[Leetcode 63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)** [速览题解](#63)
>     简评：这道题最主要的盲点是初始化时，遇到障碍物后，后面的结点都无法到达，此时对应的 dp[i]为 0。这道题可以用一维的 dp 来做以节省空间复杂度，但是得注意处理
>   - **[Leetcode 343. 整数拆分](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)** [速览题解](#343)
>     简评：这道题其实是剪绳子是一样的，就是换了个衣服，这道题还有优化的动归以及数学解法，[参考 Leetcode 官方的讲解](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)。注意逻辑判断是否相等时是 ==，不是=
>   - **[Leetcode 96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)** [速览题解](#96)
>     简评：注意是二叉**搜索树**，所以其实头结点的选取方式决定了左右结点的数量
> - [背包问题系列](#package)：下面几个问题都是 01 背包的应用
>   - **[Leetcode 416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/submissions/)** [速览题解](#416)
>     简评：这是一道 01 背包的应用，要学会从应用情景中分析出背后的原理。专业的术语叫做：**约化**，约化即是将一个问题转换为另外一类问题
>   - **[Leetcode 1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/submissions/)** [速览题解](#1049)
>   - **[Leetcode 494. 目标和](https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode/)** [速览题解](#494)
>   - **[Leetcode 474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/submissions/)** [速览题解](#474)
>   - **[Leetcode 518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)** [速览题解](#518)
>     简评：这道题是完全背包的应用，注意完全背包中遍历顺序的问题
>   - **[Leetcode 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/submissions/)** [速览题解](#70)
>     简评：这道题可以用完全背包来解决
>   - **[Leetcode 322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/submissions/)** [速览题解](#322)
>   - **[Leetcode 279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)** [速览题解](#279)
>   - **[Leetcode 139. 单词拆分](https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/)** [速览题解](#139)
> - 打家劫舍系列
> - 股票系列
> - 子序列系列

---

<a id="509"></a>

### [509. 斐波那契数](#TopicSummary)

```C++{.line-numbers}
//递归做法
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;
        return fib(n - 1) + fib(n - 2);
    }
};

//记忆化递归法
class Solution {
public:

    int fib(int n) {
        if(n < 2) return n;

        vector<int> dp(n + 1, -1);
        dp[0] = 0;
        dp[1] = 1;
        return helper(n, dp);
    }
    int helper(int n, vector<int> &dp)
    {
        if(dp[n] != -1)
            return dp[n];
        else
            dp[n] = helper(n - 1, dp) + helper(n - 2, dp);

        return dp[n];
    }
};

//动态规划做法
class Solution {
public:
    int fib(int n) {
        if(n < 2) return n;

        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;

        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
};

//动态规划优化空间复杂度
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```

<a id="70"></a>

### [70. 爬楼梯](#TopicSummary)

```C++{.line-numbers}
//动态规划
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;

        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
};

//优化空间复杂度后的动态规划
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;

        int dp[3];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
        {
            dp[0] = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = dp[0];
        }
        return dp[0];
    }
};

//转换为完全背包的动态规划
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= 2; j++)
                if(i - j >= 0)
                    dp[i] += dp[i - j];
        return dp[n];
    }
};
```

<a id="746"></a>

### [746. 使用最小花费爬楼梯](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];

        for(int i = 2; i < cost.size(); i++)
        {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1;
            dp1 = dpi;
        }

        return min(dp0, dp1);
    }
};

//第二种看法，这种比较符合常理
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int size = cost.size();

        if(size <= 2) return 0;
        vector<int> dp(size + 1, 0);
        dp[0] = 0;
        dp[1] = 0;

        for(int i = 2; i <= size; i++)
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
	    //dp[i]表示跳到第i级台阶需要花费多少力气

        return dp[size];
    }
};
```

<a id="62"></a>

### [62. 不同路径](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        return dp[m - 1][n - 1];
    }
};

// 利用数学公式来做
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;

        for(int x = n, y = 1; y < m; x++, y++)
            ans = ans * x / y;

        return ans;
    }
};
```

<a id="63"></a>

### [63. 不同路径 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int row = obstacleGrid.size();
        if(row == 0)
            return 0;
        int col = obstacleGrid[0].size();
        vector<vector<int>> dp(row, vector<int>(col, 0));

        for(int i = 0; i < col && obstacleGrid[0][i] == 0; i++)
                dp[0][i] = 1;

        for(int i = 0; i < row && obstacleGrid[i][0] == 0; i++)
                dp[i][0] = 1;

        for(int i = 1; i < row; i++)
            for(int j = 1; j < col; j++)
                if(!obstacleGrid[i][j])
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];

        return dp[row - 1][col - 1];
    }
};

//优化空间复杂度
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();

        vector<int> dp(n, 0);

        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++)
            dp[j] = 1;

        for(int i = 1; i < m; i++)
            for(int j = 0; j < n; j++)
            {
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                    continue;
                }
                if (j - 1 >= 0) {
                    dp[j] += dp[j - 1];
                }
            }

        return dp[n - 1];
    }
};

//写得简洁一点
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();

        vector<int> dp(n, 0);
        dp[0] = 1;

        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if (obstacleGrid[i][j] == 1)
                    dp[j] = 0;
                else if (j != 0 )
                    dp[j] += dp[j - 1];

        return dp[n - 1];
    }
};
```

<a id="343"></a>

### [343. 整数拆分](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        vector<int> dp(n + 1, 0);
        dp[2] = 1;

        for(int i = 3; i <= n; i++)
            for(int j = 2; j < i; j++)
                dp[i] = max(dp[i], max(j * (i - j), dp[j] * (i - j)));
                //dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));//一样能够得出结果

        return dp[n];
    }
};

//
class Solution {
public:
    int integerBreak(int n) {
        if(n < 2) return 0;
        if(n == 2) return 1;
        if(n == 3) return 2;
        if(n == 4) return 4;

        int res = 1;
        while(n > 4)
        {
            res = res * 3;
            n = n - 3;
            cout<<res<<endl;
        }
        return res * n;
    }
};

```

<a id="96"></a>

### [96. 不同的二叉搜索树](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= i; j++)
                dp[i] = dp[i] + dp[j - 1] * dp[i - j];

        return dp[n];
    }
};
```

<a id="416"></a>

### [416. 分割等和子集](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sz = nums.size();
        int sum = 0;
        for(int i = 0; i < sz; i++)
            sum += nums[i];
        if(sum % 2 == 1) return false;
        sum = sum / 2;//这里有问题

        vector<int> dp(sum + 1, 0);
        for(int i = 0; i < sz; i++)
            for(int j = sum; j >= nums[i]; j--)
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

        return dp[sum] == sum;
    }
};
```

<a id="1049"></a>

### [1049. 最后一块石头的重量 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int i = 0; i < stones.size(); i++)
            sum += stones[i];

        int target = sum / 2;
        vector<int> dp(target + 1, 0);
        for(int i = 0; i < stones.size(); i++)
            for(int j = target; j >= stones[i]; j--)
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

        return sum -  2 *  dp[target];
    }
};
```

<a id="494"></a>

### [494. 目标和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for(int i = 0; i < nums.size(); i++) sum += nums[i];

        if(S > sum) return 0;
        if((S + sum) % 2) return 0;
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for(int i = 0; i < nums.size(); i++)
            for(int j = bagSize; j >= nums[i]; j--)
                dp[j] += dp[j - nums[i]];

        return dp[bagSize];
    }
};
```

<a id="474"></a>

### [474. 一和零](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(string str: strs)
        {
            int oneNum = 0, zeroNum = 0;
            for(char c: str)
            {
                if(c == '0') zeroNum++;
                else oneNum++;
            }
            for(int i = m; i >= zeroNum; i--)
                for(int j = n; j >= oneNum; j--)
                    dp[i][j] = max(dp[i][j],dp[i - zeroNum][j - oneNum] + 1);
        }

        return dp[m][n];
    }
};
```

<a id="518"></a>

### [518. 零钱兑换 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;

        for(int i = 0; i < coins.size(); i++)
            for(int j = coins[i]; j <= amount; j++)
                dp[j] += dp[j - coins[i]];

        return dp[amount];
    }
};
```

<a id="322"></a>

### [322. 零钱兑换](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;

        for(int i = 0; i < coins.size(); i++)
            for(int j = coins[i]; j <= amount; j++)
                if(dp[j - coins[i]] != INT_MAX)
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

        if(dp[amount] == INT_MAX) return -1;
        else return dp[amount];
    }
};
```

<a id="279"></a>

### [279. 完全平方数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;

        for(int i = 0; i <= n; i++)
            for(int j = 1; j * j <= i; j++)
                dp[i] = min(dp[i - j * j] + 1, dp[i]);

        return dp[n];
    }
};
```

<a id="139"></a>

### [139. 单词拆分](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int i = 1; i <= s.size(); i++)
            for(int j = 0; j < i; j++)
            {
                string word = s.substr(j,i-j);
                if(wordSet.find(word) !=wordSet.end() && dp[j])
                    dp[i] = true;
            }

        return dp[s.size()];
    }
};
```
