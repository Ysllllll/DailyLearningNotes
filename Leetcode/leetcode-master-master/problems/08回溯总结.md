<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >
</p>

> 20 张树形结构图、14 道精选回溯题目，21 篇回溯法精讲文章，由浅入深，一气呵成，这是全网最强回溯算法总结！

# 回溯法理论基础

转眼间[「代码随想录」](https://img-blog.csdnimg.cn/20200815195519696.png)里已经分享连续讲解了 21 天的回溯算法，是时候做一个大总结了，本篇高能，需要花费很大的精力来看！

关于回溯算法理论基础，我录了一期 B 站视频[带你学透回溯算法（理论篇）](https://www.bilibili.com/video/BV1cy4y167mM)如果对回溯算法还不了解的话，可以看一下。

在[关于回溯算法，你该了解这些！](https://mp.weixin.qq.com/s/gjSgJbNbd1eAA5WkA-HeWw)中我们详细的介绍了回溯算法的理论知识，不同于教科书般的讲解，这里介绍的回溯法的效率，解决的问题以及模板都是在刷题的过程中非常实用！

**回溯是递归的副产品，只要有递归就会有回溯**，所以回溯法也经常和二叉树遍历，深度优先搜索混在一起，因为这两种方式都是用了递归。

回溯法就是暴力搜索，并不是什么高效的算法，最多再剪枝一下。

回溯算法能解决如下问题：

- 组合问题：N 个数里面按一定规则找出 k 个数的集合
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 棋盘问题：N 皇后，解数独等等

**我在回溯算法系列讲解中就按照这个顺序给大家讲解，可以说深入浅出，步步到位**。

回溯法确实不好理解，所以需要把回溯法抽象为一个图形来理解就容易多了，**在后面的每一道回溯法的题目我都将遍历过程抽象为树形结构方便大家的理解**。

在[关于回溯算法，你该了解这些！](https://mp.weixin.qq.com/s/gjSgJbNbd1eAA5WkA-HeWw)还用了回溯三部曲来分析回溯算法，并给出了回溯法的模板：

```C++{.line-numbers}
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**事实证明这个模板会伴随整个回溯法系列！**

<a id="combinatorialProblem"></a>

# [组合问题](#TopicSummary)

## [组合问题](#TopicSummary)

在[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)中，我们开始用回溯法解决第一道题目：组合问题。

我在文中开始的时候给大家列举 k 层 for 循环例子，进而得出都是同样是暴利解法，为什么要用回溯法！

**此时大家应该深有体会回溯法的魅力，用递归控制 for 循环嵌套的数量！**

本题我把回溯问题抽象为树形结构，如题：

![77.组合1](https://img-blog.csdnimg.cn/20201118152928844.png)

可以直观的看出其搜索的过程：**for 循环横向遍历，递归纵向遍历，回溯不断调整结果集**，这个理念贯穿整个回溯法系列，也是我做了很多回溯的题目，不断摸索其规律才总结出来的。

对于回溯法的整体框架，网上搜的文章这块都说不清楚，按照天上掉下来的代码对着讲解，不知道究竟是怎么来的，也不知道为什么要这么写。

**所以，录友们刚开始学回溯法，起跑姿势就很标准了！**

优化回溯算法只有剪枝一种方法，在[回溯算法：组合问题再剪剪枝](https://mp.weixin.qq.com/s/Ri7spcJMUmph4c6XjPWXQA)中把回溯法代码做了剪枝优化，树形结构如图：

![77.组合4](https://img-blog.csdnimg.cn/20201118153133458.png)

大家可以一目了然剪的究竟是哪里。

**[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)剪枝精髓是：for 循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的 k 个元素了，就没有必要搜索了**。

**在 for 循环上做剪枝操作是回溯法剪枝的常见套路！** 后面的题目还会经常用到。

## [组合总和](#TopicSummary)

### [组合总和（一）](#TopicSummary)

在[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)中，相当于 [回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)加了一个元素总和的限制。

树形结构如图：
![216.组合总和III](https://img-blog.csdnimg.cn/20201118201921245.png)

整体思路还是一样的，本题的剪枝会好想一些，即：**已选元素总和如果已经大于 n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉**，如图：

![216.组合总和III1](https://img-blog.csdnimg.cn/20201118202038240.png)

在本题中，依然还可以有一个剪枝，就是[回溯算法：组合问题再剪剪枝](https://mp.weixin.qq.com/s/Ri7spcJMUmph4c6XjPWXQA)中提到的，对 for 循环选择的起始范围的剪枝。

所以剪枝的代码可以在 for 循环加上 `i <= 9 - (k - path.size()) + 1` 的限制！

### [组合总和（二）](#TopicSummary)

在[回溯算法：求组合总和（二）](https://mp.weixin.qq.com/s/FLg8G6EjVcxBjwCbzpACPw)中讲解的组合总和问题，和[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)，[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。

不少同学都是看到可以重复选择，就义无反顾的把 startIndex 去掉了。

**本题还需要 startIndex 来控制 for 循环的起始位置，对于组合问题，什么时候需要 startIndex 呢？**

我举过例子，如果是一个集合来求组合的话，就需要 startIndex，例如：[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)，[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用 startIndex，例如：[回溯算法：电话号码的字母组合](https://mp.weixin.qq.com/s/e2ua2cmkE_vpYjM3j6HY0A)

**注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路**。

树形结构如下：

![39.组合总和](https://img-blog.csdnimg.cn/20201118152521990.png)

最后还给出了本题的剪枝优化，如下：

```C++
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

优化后树形结构如下：

![39.组合总和1](https://img-blog.csdnimg.cn/20201118202115929.png)

### [组合总和（三）](#TopicSummary)

在[回溯算法：求组合总和（三）](https://mp.weixin.qq.com/s/_1zPYk70NvHsdY8UWVGXmQ)中集合元素会有重复，但要求解集不能包含重复的组合。

**所以难就难在去重问题上了**。

这个去重问题，相信做过的录友都知道有多么的晦涩难懂。网上的题解一般就说“去掉重复”，但说不清怎么个去重，代码一甩就完事了。

为了讲解这个去重问题，**Carl 自创了两个词汇，“树枝去重”和“树层去重”**。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**。

![40.组合总和II1](https://img-blog.csdnimg.cn/2020111820220675.png)

我在图中将 used 的变化用橘黄色标注上，**可以看出在 candidates[i] == candidates[i - 1]相同的情况下：**

- used[i - 1] == true，说明同一树支 candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层 candidates[i - 1]使用过

**这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！**

对于去重，其实排列和子集问题也是一样的道理。

### [多个集合求组合](#TopicSummary)

在[回溯算法：电话号码的字母组合](https://mp.weixin.qq.com/s/e2ua2cmkE_vpYjM3j6HY0A)中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。

例如这里 for 循环，可不像是在 [回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)和[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)中从 startIndex 开始遍历的。

**因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而[回溯算法：求组合问题！](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)和[回溯算法：求组合总和！](https://mp.weixin.qq.com/s/HX7WW6ixbFZJASkRnCTC3w)都是是求同一个集合中的组合！**

树形结构如下：

![17. 电话号码的字母组合](https://img-blog.csdnimg.cn/20201118202335724.png)

如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入 1 \* #按键。

其实本题不算难，但也处处是细节，还是要反复琢磨。

<a id="cuttingProblem"></a>

# [切割问题](#TopicSummary)

在[回溯算法：分割回文串](https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q)中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。

我列出如下几个难点：

- 切割问题其实类似组合问题
- 如何模拟那些切割线
- 切割问题中递归如何终止
- 在递归循环中如何截取子串
- 如何判断回文

如果想到了**用求解组合问题的思路来解决 切割问题本题就成功一大半了**，接下来就可以对着模板照葫芦画瓢。

**但后续如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了**。

所以本题应该是一个道 hard 题目了。

除了这些难点，**本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入 i + 1**。

树形结构如下：

![131.分割回文串](https://img-blog.csdnimg.cn/20201118202448642.png)

同样的切割问题还有[回溯算法：复原 IP 地址](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485390&idx=1&sn=e95ad5b1c40f06fc18cd3fec54fd1cbc&chksm=f9a2349fced5bd89092073366fa77e0f3949dd75e5a7e3017e3d289551be10bdc6aa745b5f11&cur_album_id=1485825793120387074&scene=190#rd)。

<a id="subsetProblem"></a>

# [子集问题](#TopicSummary)

## [子集问题（一）](#TopicSummary)

在[回溯算法：求子集问题！](https://mp.weixin.qq.com/s/NNRzX-vJ_pjK4qxohd_LtA)中讲解了子集问题，**在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果**。

如图：

![78.子集](https://img-blog.csdnimg.cn/20201118202544339.png)

认清这个本质之后，今天的题目就是一道模板题了。

**本题其实可以不需要加终止条件**，因为 startIndex >= nums.size()，本层 for 循环本来也结束了，本来我们就要遍历整颗树。

有的同学可能担心不写终止条件会不会无限递归？

并不会，因为每次递归的下一层就是从 i+1 开始的。

如果要写终止条件，注意：`result.push_back(path);`要放在终止条件的上面，如下：

```C++{.line-numbers}
result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉结果
if (startIndex >= nums.size()) { // 终止条件可以不加
    return;
}
```

## [子集问题（二）](#TopicSummary)

在[回溯算法：求子集问题（二）](https://mp.weixin.qq.com/s/WJ4JNDRJgsW3eUN72Hh3uQ)中，开始针对子集问题进行去重。

本题就是[回溯算法：求子集问题！](https://mp.weixin.qq.com/s/NNRzX-vJ_pjK4qxohd_LtA)的基础上加上了去重，去重我们在[回溯算法：求组合总和（三）](https://mp.weixin.qq.com/s/_1zPYk70NvHsdY8UWVGXmQ)也讲过了，一样的套路。

树形结构如下：

![90.子集II](https://img-blog.csdnimg.cn/2020111217110449.png)

## [递增子序列](#TopicSummary)

在[回溯算法：递增子序列](https://mp.weixin.qq.com/s/ePxOtX1ATRYJb2Jq7urzHQ)中，处处都能看到子集的身影，但处处是陷阱，值得好好琢磨琢磨！

树形结构如下：
![491. 递增子序列1](https://img-blog.csdnimg.cn/20201112170832333.png)

很多同学都会把这道题目和[回溯算法：求子集问题（二）](https://mp.weixin.qq.com/s/WJ4JNDRJgsW3eUN72Hh3uQ)混在一起。

**[回溯算法：求子集问题（二）](https://mp.weixin.qq.com/s/WJ4JNDRJgsW3eUN72Hh3uQ)也可以使用 set 针对同一父节点本层去重，但子集问题一定要排序，为什么呢？**

我用没有排序的集合{2,1,2,2}来举个例子画一个图，如下：

![90.子集II2](https://img-blog.csdnimg.cn/2020111316440479.png)

**相信这个图胜过千言万语的解释了**。
<a id="permutationProblem"></a>

# [排列问题](#TopicSummary)

## [排列问题（一）](#TopicSummary)

[回溯算法：排列问题！](https://mp.weixin.qq.com/s/SCOjeMX1t41wcvJq49GhMw) 又不一样了。

排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。

可以看出元素 1 在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次 1，所以处理排列问题就不用使用 startIndex 了。

如图：

![46.全排列](https://img-blog.csdnimg.cn/20201112170304979.png)

**大家此时可以感受出排列问题的不同：**

- 每层都是从 0 开始搜索而不是 startIndex
- 需要 used 数组记录 path 里都放了哪些元素了

## [排列问题（二）](#TopicSummary)

排列问题也要去重了，在[回溯算法：排列问题（二）](https://mp.weixin.qq.com/s/9L8h3WqRP_h8LLWNT34YlA)中又一次强调了“树层去重”和“树枝去重”。

树形结构如下：

![47.全排列II1](https://img-blog.csdnimg.cn/20201112171930470.png)

**这道题目神奇的地方就是 used[i - 1] == false 也可以，used[i - 1] == true 也可以！**

我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2.png](https://img-blog.csdnimg.cn/20201112172230434.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://img-blog.csdnimg.cn/20201112172327967.png)

**可以清晰的看到使用(used[i - 1] == false)，即树层去重，效率更高！**

本题 used 数组即是记录 path 里都放了哪些元素，同时也用来去重，一举两得。

<a id="去重问题"></a>

# [去重问题](#TopicSummary)

以上我都是统一使用 used 数组来去重的，其实使用 set 也可以用来去重！

在[本周小结！（回溯算法系列三）续集](https://mp.weixin.qq.com/s/kSMGHc_YpsqL2j-jb_E_Ag)中给出了子集、组合、排列问题使用 set 来去重的解法以及具体代码，并纠正一些同学的常见错误写法。

同时详细分析了 使用 used 数组去重 和 使用 set 去重 两种写法的性能差异：

**使用 set 去重的版本相对于 used 数组的版本效率都要低很多**，大家在 leetcode 上提交，能明显发现。

原因在[回溯算法：递增子序列](https://mp.weixin.qq.com/s/ePxOtX1ATRYJb2Jq7urzHQ)中也分析过，主要是因为程序运行的时候对 unordered_set 频繁的 insert，unordered_set 需要做哈希映射（也就是把 key 通过 hash function 映射为唯一的哈希值）相对费时间，而且 insert 的时候其底层的符号表也要做相应的扩充，也是费时的。

**而使用 used 数组在时间复杂度上几乎没有额外负担！**

**使用 set 去重，不仅时间复杂度高了，空间复杂度也高了**，在[本周小结！（回溯算法系列三）](https://mp.weixin.qq.com/s/tLkt9PSo42X60w8i94ViiA)中分析过，组合，子集，排列问题的空间复杂度都是 O(n)，但如果使用 set 去重，空间复杂度就变成了 O(n^2)，因为每一层递归都有一个 set 集合，系统栈空间是 n，每一个空间都有 set 集合。

那有同学可能疑惑 用 used 数组也是占用 O(n)的空间啊？

used 数组可是全局变量，每层与每层之间公用一个 used 数组，所以空间复杂度是 O(n + n)，最终空间复杂度还是 O(n)。

<a id="scheduleIssues"></a>

# [行程安排](#TopicSummary)

之前说过，有递归的地方就有回溯，深度优先搜索也是用递归来实现的，所以往往伴随着回溯。

在[回溯算法：重新安排行程](https://mp.weixin.qq.com/s/3kmbS4qDsa6bkyxR92XCTA)其实也算是图论里深搜的题目，但是我用回溯法的套路来讲解这道题目，算是给大家拓展一下思路，原来回溯法还可以这么玩！

以输入：[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]为例，抽象为树形结构如下：

![](https://img-blog.csdnimg.cn/2020111518065555.png)

本题可以算是一道 hard 的题目了，关于本题的难点我在文中已经详细列出。

**如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上！**

本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，**算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归**。

<a id="chessboard"></a>

# [棋盘问题](#TopicSummary)

## [N 皇后问题](#TopicSummary)

在[回溯算法：N 皇后问题](https://mp.weixin.qq.com/s/lU_QwCMj6g60nh8m98GAWg)中终于迎来了传说中的 N 皇后。

下面我用一个 3 \* 3 的棋牌，将搜索过程抽象为一颗树，如图：

![51.N皇后](https://img-blog.csdnimg.cn/20201118225433127.png)

从图中，可以看出，二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

那么我们用皇后们的约束条件，来回溯搜索这颗树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

如果从来没有接触过 N 皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。

**这里我明确给出了棋盘的宽度就是 for 循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了**。

相信看完本篇[回溯算法：N 皇后问题](https://mp.weixin.qq.com/s/lU_QwCMj6g60nh8m98GAWg)也没那么难了，传说已经不是传说了，哈哈。

## [解数独问题](#TopicSummary)

在[回溯算法：解数独](https://mp.weixin.qq.com/s/eWE9TapVwm77yW9Q81xSZQ)中要征服回溯法的最后一道山峰。

解数独应该是棋盘很难的题目了，比 N 皇后还要复杂一些，但只要理解 “二维递归”这个过程，其实发现就没那么难了。

大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：[77.组合（组合问题）](https://mp.weixin.qq.com/s/OnBjbLzuipWz_u4QfmgcqQ)，[131.分割回文串（分割问题）](https://mp.weixin.qq.com/s/Pb1epUTbU8fHIht-g_MS5Q)，[78.子集（子集问题）](https://mp.weixin.qq.com/s/NNRzX-vJ_pjK4qxohd_LtA)，[46.全排列（排列问题）](https://mp.weixin.qq.com/s/SCOjeMX1t41wcvJq49GhMw)，以及[51.N 皇后（N 皇后问题）](https://mp.weixin.qq.com/s/lU_QwCMj6g60nh8m98GAWg)，其实这些题目都是一维递归。

其中[N 皇后问题](https://mp.weixin.qq.com/s/lU_QwCMj6g60nh8m98GAWg)是因为每一行每一列只放一个皇后，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。

本题就不一样了，**本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比 N 皇后更宽更深**。

因为这个树形结构太大了，我抽取一部分，如图所示：

![37.解数独](https://img-blog.csdnimg.cn/2020111720451790.png)

解数独可以说是非常难的题目了，如果还一直停留在一维递归的逻辑中，这道题目可以让大家瞬间崩溃。

**所以我在[回溯算法：解数独](https://mp.weixin.qq.com/s/eWE9TapVwm77yW9Q81xSZQ)中开篇就提到了二维递归，这也是我自创词汇**，希望可以帮助大家理解解数独的搜索过程。

一波分析之后，在看代码会发现其实也不难，唯一难点就是理解**二维递归**的思维逻辑。

**这样，解数独这么难的问题也被我们攻克了**。

# 性能分析

**关于回溯算法的复杂度分析在网上的资料鱼龙混杂，一些所谓的经典面试书籍不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界**。

**所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！**

以下在计算空间复杂度的时候我都把系统栈（不是数据结构里的栈）所占空间算进去。

子集问题分析：

- 时间复杂度：$O(n * 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为 $O(2^n)$，构造每一组子集都需要填进数组，又有需要 $O(n)$，最终时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$，递归深度为 n，所以系统栈所用空间为 $O(n)$，每一层递归所用的空间都是常数级别，注意代码里的 $result$ 和 $path$ 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 $O(n)$

排列问题分析：

- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为 n，第二层每一个分支都延伸了 n-1 个分支，再往下又是 n-2 个分支，所以一直到叶子节点一共就是 $n *n-1* n-2 * ..... 1 = n!。$
- 空间复杂度：O(n)，和子集问题同理。

组合问题分析：

- 时间复杂度：$O(n * 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：O(n)，和子集问题同理。

N 皇后问题分析：

- 时间复杂度：$O(n!)$ ，其实如果看树形图的话，直觉上是 $O(n^n)$，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是 O（n!），n!表示 $n *(n-1)* .... * 1$。
- 空间复杂度：O(n)，和子集问题同理。

解数独问题分析：

- 时间复杂度：$O(9^m)$， m 是 '.' 的数目。
- 空间复杂度：$O(n^2)$，递归的深度是 n^2

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！**

# 总结

**[「代码随想录」](https://img-blog.csdnimg.cn/20200815195519696.png)历时 21 天，14 道经典题目分析，20 张树形图，21 篇回溯法精讲文章，从组合到切割，从子集到排列，从棋盘问题到最后的复杂度分析**，至此收尾了。

这里的每一种问题，讲解的时候我都会和其他问题作对比，做分析，确保每一个问题都讲的通透。

可以说方方面面都详细介绍到了。

例如：

- 如何理解回溯法的搜索过程？
- 什么时候用 startIndex，什么时候不用？
- 如何去重？如何理解“树枝去重”与“树层去重”？
- 去重的几种方法？
- 如何理解二维递归？

**这里的每一个问题，网上几乎找不到能讲清楚的文章，这也是直击回溯算法本质的问题**。

相信一路坚持下来的录友们，对回溯算法已经都深刻的认识。

此时回溯算法系列就要正式告一段落了。

<a id="TopicSummary"></a>

> **题目汇总**
>
> - [组合问题](#combinatorialProblem)：`[1 2 3 4 5], [1 1 1 2 3]`
>   - **[Leetcode 77. 组合](https://leetcode-cn.com/problems/combinations//)** [速览题解](#77)
>     简评：可以结合树形图来理解代码
>   - **[Leetcode 216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)** [速览题解](#216)
>   - **[Leetcode 39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)** [速览题解](#39)
>   - **[Leetcode 17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)** [速览题解](#17)
>     简评：注意 string 对象可以进行 push_back()和 pop_back()操作
>   - **[Leetcode 40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/submissions/)** [速览题解](#40)
>   - 建议：组合总和的问题，可以用 `target - candidates[i]`，而不用另外再起一个变量 `sum`
> - [切割问题](#cuttingProblem)
>   - **[Leetcode 131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)** [速览题解](#131)
>     简评：这道题需要求回文串，可以使用动态规划先求一遍，所以看这道题之前，可以先看一下回文串那道题
>   - **[Leetcode 93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)** [速览题解](#93)
>     简评：这道题需要考虑 string 类对象的 insert 和 erase 操作的时间复杂度
>   - **[Leetcode 1593. 拆分字符串使唯一子字符串的数目最大](https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/)** [速览题解](#1593)
>   - **[Leetcode 22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)** [速览题解](#22)
>   - **[Leetcode 784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)** [速览题解](#784)
> - [子集问题](#subsetProblem)：`[1 2 3 4 5], [1 1 1 2 3]`
>   - **[Leetcode 78. 子集](https://leetcode-cn.com/problems/subsets/submissions/)** [速览题解](#78)
>   - **[Leetcode 90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)** [速览题解](#90)
>     简评：去重之前一定要先排序，同时注意：“树同枝重复” “树同层重复”的区别，以及相应的处理方式。
>   - **[Leetcode 491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/submissions/)** [速览题解](#491)
>     简评：这里不能去重，注意与上面的题的区别
> - [排列问题](#permutationProblem)：`[1 2 3 4 5], [1 1 1 2 3]`
>   - **[Leetcode 46. 全排列](https://leetcode-cn.com/problems/permutations/)** [速览题解](#46)
>   - **[Leetcode 47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/submissions/)** [速览题解](#47)
>     简评：在 46 题的基础之上，这里给出的数组中含有重复的元素，所以需要考虑去重，去重前一定要先排序。同时每个类型题的题目依据数组中是否有重复元素，而区分难度，如上面三种类型题目
>   - **[Leetcode 60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)** [速览题解](#60)
> - [行程安排](#scheduleIssues)
>   - **[Leetcode 332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/submissions/)** [速览题解](#332)
> - [棋盘问题](#chessboard)
>   - **[Leetcode 51. N 皇后](https://leetcode-cn.com/problems/n-queens/submissions/)** [速览题解](#51)
>   - **[Leetcode 52. N 皇后 II](https://leetcode-cn.com/problems/n-queens-ii/)** [速览题解](#52)
>     简评：这道题可以用位运算，后续再看
>   - **[Leetcode 37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)** [速览题解](#37)
>     简评：这道题可以用位运算，后续再看
> - [二维回溯问题](#c)
>   - **[Leetcode 733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)** [速览题解](#733)
>   - **[Leetcode 79. 单词搜索](https://leetcode-cn.com/problems/word-search/)** [速览题解](#79)
>   - **[Leetcode 130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)** [速览题解](#130)
>   - **[Leetcode 200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands)** [速览题解](#200)
>   - **[Leetcode 417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)** [速览题解](#417)
>   - **[Leetcode 1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)** [速览题解](#1020)
>   - **[Leetcode 1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)** [速览题解](#1245)
>   - **[Leetcode 1034. 边框着色](https://leetcode-cn.com/problems/coloring-a-border/)** [速览题解](#1034)
>   - **[Leetcode 279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)** [速览题解](#279)
>   - **[Leetcode 752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)** [速览题解](#752)
>   - **[Leetcode 365. 水壶问题](https://leetcode-cn.com/problems/water-and-jug-problem/)** [速览题解](#365)
>   - **[Leetcode 773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)** [速览题解](#773)
>   - **[Leetcode 785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)** [速览题解](#785)
>   - **[Leetcode 886. 可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)** [速览题解](#886)
>   - **[Leetcode 133. 克隆图](https://leetcode-cn.com/problems/clone-graph/)** [速览题解](#133)
>   - **[剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)** [速览题解](#13)
>   - **[Leetcode 695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)** [速览题解](#695)
>   - **[Leetcode 529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)** [速览题解](#529)
>   - **[Leetcode 994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)** [速览题解](#994)
>   - **[Leetcode 1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)** [速览题解](#1162)
>   - **[Leetcode 1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)** [速览题解](#1091)

---

<a id="77"></a>

### [77. 组合](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(int n, int k, int startIndex)
    {
        if(path.size() == k)
        {
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i <= n - (k - path.size()) + 1; i++)
        {
            path.push_back(i); // 取一个数字，可以看成是延伸出一个分支来
            backTracking(n, k, i + 1);
            path.pop_back();
        }

    }
    vector<vector<int>> combine(int n, int k) {
        backTracking(n, k, 1);
        return res;
    }
};
```

<a id="216"></a>

### [216. 组合总和 III](#TopicSummary)

```C++{.line-numbers}
// 未剪枝
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backTracking(int k, int remain, int startIndex)
    {
        if(path.size() == k && remain == 0)
        {
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i <= 9; i++)
        {
            path.push_back(i);
            backTracking(k, remain - i, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {

        backTracking(k, n, 1);
        return res;
    }
};

// 剪枝
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backTracking(int k, int remain, int startIndex)
    {
        if(remain < 0)
            return;
        if(path.size() == k && remain == 0)
        {
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i <= 9 - (k - path.size()) + 1; i++)
        {
            path.push_back(i);
            backTracking(k, remain - i, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {

        backTracking(k, n, 1);
        return res;
    }
};
```

<a id="39"></a>

### [39. 组合总和](#TopicSummary)

```C++{.line-numbers}
// 未剪枝
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& candidates, int target, int startIndex)
    {
        if(target == 0)
        {
            res.push_back(path);
            return;
        }
        else if(target < 0)
            return;

        for(int i = startIndex; i < candidates.size(); i++)
        {
            path.push_back(candidates[i]);
            backTracking(candidates, target - candidates[i], i);//不用i+1了，表示可以重复读取当前的数
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backTracking(candidates, target, 0);
        return res;
    }
};

// 剪枝：注意剪枝的前提是candidates数组有序
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& candidates, int target, int startIndex)
    {
        if(target == 0)
        {
            res.push_back(path);
            return;
        }
        else if(target < 0)
            return;

        for(int i = startIndex; i < candidates.size() && (target - candidates[i] >= 0); i++)
        //candidates必须有序，才能保证后面的都小于0
        {
            path.push_back(candidates[i]);
            backTracking(candidates, target - candidates[i], i);
            path.pop_back();
        }

    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 需要排序
        backTracking(candidates, target, 0);
        return res;
    }
};
```

<a id="17"></a>

### [17. 电话号码的字母组合](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    const string letterMap[10] =
    {
        "",
        "!@#",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz",
    };
    vector<string> res;
    string path;
    void backTracking(string &digits, int index)
    {
        if(digits.length() == index)
        {
            res.push_back(path);
            return;
        }

        int i = digits[index] - '0';
        string d = letterMap[i];
        for(int i = 0; i < d.length(); i++)
        {
            path.push_back(d[i]);
            backTracking(digits, index + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0)
            return res;

        backTracking(digits, 0);
        return res;
    }
};
```

<a id="40"></a>

### [40. 组合总和 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool> &used)
    {
        if(sum == target)
        {
            res.push_back(path);
            return;
        }

        for(int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
        {
            if(i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false)
                continue;
            path.push_back(candidates[i]);
            used[i] = true;
            backTracking(candidates, target, sum + candidates[i], i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);

        sort(candidates.begin(), candidates.end());
        backTracking(candidates, target, 0, 0, used);
        return res;
    }
};
```

<a id="131"></a>

### [131. 分割回文串](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;
    bool isPalindrome(string &s, int begin, int end)
    {
        while(begin < end)
        {
            if(s[begin] == s[end])
            {
                begin++;
                end--;
            }
            else
                return false;
        }
        return true;
    }
    void backTracking(string &s, int startIndex)
    {
        if(startIndex >= s.length())
        {
            res.push_back(path);
            return;
        }

        for(int i = startIndex; i < s.length(); i++)
        {
            if(isPalindrome(s, startIndex, i))
            {
                path.push_back(s.substr(startIndex, i - startIndex + 1));
                backTracking(s, i + 1);
                path.pop_back();
            }
        }
    }
    //测试用例： a  a  b
    vector<vector<string>> partition(string s) {
        backTracking(s, 0);
        return res;
    }
};

//使用动态规划进行预处理
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;
    vector<vector<int>> Palindrome;
    void isPalindrome(string &s)
    {
        int n = s.length();
        Palindrome.assign(n, vector<int>(n, true));

        //使用动态规划进行预处理，注意只计算二维矩阵的上三角
        for(int i = n - 1; i >= 0; i--)
            for(int j = i + 1; j < n; j++)
                Palindrome[i][j] = Palindrome[i + 1][j - 1] && s[i] == s[j];
    }
    void backTracking(string &s, int startIndex)
    {
        if(startIndex >= s.length())
        {
            res.push_back(path);
            return;
        }

        for(int i = startIndex; i < s.length(); i++)
        {
            if(Palindrome[startIndex][i])
            {
                path.push_back(s.substr(startIndex, i - startIndex + 1));
                backTracking(s, i + 1);
                path.pop_back();
            }
        }
    }
    //测试用例： a  a  b
    vector<vector<string>> partition(string s) {
        isPalindrome(s);
        backTracking(s, 0);
        return res;
    }
};
```

<a id="93"></a>

### [93. 复原 IP 地址](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<string> res;
    bool judge(string &s, int begin, int end)
    {
        if(begin > end)
            return false;
        if(begin != end && s[begin] == '0')
            return false;
        int num = 0;
        for(int i = begin; i <= end; i++)
        {
            if(s[i] > '9' && s[i] < '0')
                return false;
            num = num * 10 + (s[i] - '0');
            if(num > 255)
                return false;
        }
        return true;
    }

    void backTracking(string &s, int startIndex, int pointNum)
    {
        if(pointNum == 3)
        {
            if(judge(s, startIndex, s.length() - 1))
                res.push_back(s);
            return ;
        }

        for(int i = startIndex; i < s.length() && (i - startIndex < 3); i++)
        {
            if(judge(s, startIndex, i))
            {
                s.insert(s.begin() + i + 1 , '.');//注意这里的时间复杂度，可能会有点高
                backTracking(s, i + 2, pointNum + 1);
                s.erase(s.begin() + i + 1);
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        backTracking(s, 0, 0);
        return res;
    }
};
```

<a id="1593"></a>

### [1593. 拆分字符串使唯一子字符串的数目最大](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:

    void backTracking(string &s, int &res, unordered_set<string> &st, int index)
    {
        if(index == s.size())
        {
            int sz = st.size();
            res = max(res, sz);
            return;
        }

        for(int i = index; i < s.size(); i++)
        {
            string temp = s.substr(index, i - index + 1);
            if(st.find(temp) == st.end() && temp != s)
            {
                st.insert(temp);
                backTracking(s, res, st, i + 1);
                st.erase(temp);
            }
        }

    }
    int maxUniqueSplit(string s) {
        int res = 1;
        unordered_set<string> st;
        backTracking(s, res, st, 0);
        return res;
    }
};
```

<a id="22"></a>

### [22. 括号生成](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int left = n;
        int right = n;
        vector<string> res;

        backTracking(res, "", left, right);
        return res;
    }

    void backTracking(vector<string> &res, string path, int left, int right)
    {
        if(left == 0 && right == 0)
        {
            res.push_back(path);
            return;
        }
        if(left > 0)
            backTracking(res, path + '(', left - 1, right);

        if(left < right)
            backTracking(res, path + ')', left, right - 1);
    }
};
```

<a id="784"></a>

### [784. 字母大小写全排列](#TopicSummary)

```C++{.line-numbers}
// 时间复杂度很高
class Solution {
public:
    vector<string> letterCasePermutation(string s) {
        vector<string> res;

        backTracking(res, "", s, 0);
        return res;
    }
    void backTracking(vector<string> &res, string path, string &s, int index)
    {
        if(path.size() == s.size())
        {
            res.push_back(path);
            return;
        }

        for(int i = index; i < s.size(); i++)
        {
              if(isalpha(s[i]) == false)
                backTracking(res, path + s[i], s, i + 1);
            else
            {
                backTracking(res, path + (char)(toupper(s[i])), s, i + 1);
                backTracking(res, path + (char)(tolower(s[i])), s, i + 1);
            }
        }

    }
};

// 时间复杂度很好
class Solution {
public:
    vector<string> letterCasePermutation(string S) {
        vector<string> res;
        backTracking(res,S,0);
        return res;
    }

    void backTracking(vector<string> &res,string S,int i)
    {
        if(i==S.size())
        {
            res.push_back(S);
            return;
        }
        if(!isalpha(S[i]))
            backTracking(res,S,i+1);
        else
        {
            S[i]=tolower(S[i]);
            backTracking(res,S,i+1);
            S[i]=toupper(S[i]);
            backTracking(res,S,i+1);
        }
    }
};
```

<a id="78"></a>

### [78. 子集](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(vector<int> &nums, int startIndex)
    {
        res.push_back(path);
        if(startIndex >= nums.size())
            return;

        for(int i = startIndex; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backTracking(nums, 0);
        return res;
    }
};
```

<a id="90"></a>

### [90. 子集 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    void backTracking(vector<int> &nums, int startIndex, vector<bool> &used)
    {
        res.push_back(path);
        if(startIndex >= nums.size())
            return;

        for(int i = startIndex; i < nums.size(); i++)
        {
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)
                continue;
            used[i] = true;
            path.push_back(nums[i]);
            backTracking(nums, i + 1, used);
            path.pop_back();
            used[i] = false;
        }
    }

    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backTracking(nums, 0, used);
        return res;
    }
};
```

<a id="491"></a>

### [491. 递增子序列](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;

    void backTracking(vector<int> &nums, int startIndex)
    {
        if(path.size() > 1)
            res.push_back(path);

        int used[201] = {0};//注意这里是局部变量，不会在递归的过程中传递
        for(int i = startIndex; i < nums.size(); i++)
        {
            if((!path.empty() && nums[i] < path.back()) || used[nums[i] + 100] == 1)
                continue;

            used[nums[i] + 100] = 1;
            path.push_back(nums[i]);
            backTracking(nums, i + 1);
            path.pop_back();
        }

    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backTracking(nums, 0);
        return res;
    }
};
```

<a id="46"></a>

### [46. 全排列](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> vis;
    void backTracking(vector<int> &nums)
    {
        if(path.size() == nums.size())
        {
            res.push_back(path);
            return;
        }

        for(int i = 0; i < nums.size(); i++)
        {
            if(vis[i] == false)
            {
                vis[i] = true;
                path.push_back(nums[i]);
                backTracking(nums);
                path.pop_back();
                vis[i] = false;
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums)
    {
        vis.assign(nums.size(), false);
        backTracking(nums);
        return res;
    }
};
```

<a id="47"></a>

### [47. 全排列 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<bool> vis;

    void backTracking(vector<int> &nums)
    {

        if(path.size() == nums.size())
        {
            res.push_back(path);
            return;
        }

        for(int i = 0; i < nums.size(); i++)
        {
            if(i > 0 && nums[i] == nums[i - 1] && vis[i - 1] == false)
                continue;
            if(vis[i] == false)
            {
                vis[i] = true;
                path.push_back(nums[i]);
                backTracking(nums);
                path.pop_back();
                vis[i] = false;
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {

        vis.assign(nums.size(), false);
        sort(nums.begin(), nums.end());//注意这里的去重要先排序
        backTracking(nums);
        return res;
    }
};
```

<a id="60"></a>

### [60. 排列序列](#TopicSummary)

```C++{.line-numbers}
// 回溯，时间复杂度很高
class Solution {
public:
    void backTracking(string &res, string &path, vector<bool> &used, int n, int &k)
    {
        if(k == 0) return;
        if(path.length() == n)
        {
            k--;
            if(k == 0)
            {
                res = path;
                return;
            }
        }

        for(int i = 1; i <= n; i++)
        {
            if(used[i] == false)
            {
                used[i] = true;
                path.push_back(i + '0');
                backTracking(res, path, used, n, k);
                path.pop_back();
                used[i] = false;
            }
        }
    }
    string getPermutation(int n, int k) {
        string res, path;
        vector<bool> used(n + 1, false);
        backTracking(res, path, used, n, k);
        return res;
    }
};
```

<a id="332"></a>

### [332. 重新安排行程](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    unordered_map<string, map<string, int>> targets;
    vector<string> res;

    bool backTracking(int ticketsNum)
    {
        if(res.size() == ticketsNum + 1)
            return true;

        for(pair<const string, int> &target: targets[res[res.size() - 1]])
        {
            if(target.second > 0)
            {
                res.push_back(target.first);
                target.second--;
                if(backTracking(ticketsNum)) return true;
                target.second++;
                res.pop_back();
            }
        }
        return false;
    }

    vector<string> findItinerary(vector<vector<string>>& tickets)
    {
        for(int i = 0; i < tickets.size(); i++)
                targets[tickets[i][0]][tickets[i][1]]++;

        res.push_back("JFK");
        backTracking(tickets.size());

        return res;
    }
};
```

<a id="51"></a>

### [51. N 皇后](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<string>> res;

    bool isValid(int row, int col, vector<string>& chessboard, int n)
    {
        int count = 0;
        // 检查列
        for(int i = 0; i < row; i++)
            if(chessboard[i][col] == 'Q')
                return false;
        // 检查45度角是否有皇后
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
            if(chessboard[i][j] == 'Q')
                return false;
        // 检查135度角是否有皇后
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--,j++)
            if(chessboard[i][j] == 'Q')
                return false;

        return true;
    }

    void backTracking(int n , int row, vector<string>& chessboard)
    {
        if(row == n)
        {
            res.push_back(chessboard);
            return;
        }
        for(int col = 0; col < n; col++)
        {
            if(isValid(row,col,chessboard,n))
            {
                chessboard[row][col] = 'Q';
                backTracking(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    vector<vector<string>> solveNQueens(int n) {
        vector<string> chessboard(n, string(n, '.'));
        backTracking(n, 0, chessboard);
        return res;
    }
};
```

<a id="52"></a>

### [52. N 皇后 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool isValid(int row, int col, vector<vector<bool>> &location, int n)
    {
        for(int i = 0; i < row; i++)
            if(location[i][col])
                return false;
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--,j--)
            if(location[i][j])
                return false;
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--,j++)
            if(location[i][j])
                return false;
        return true;
    }
    void backTracking(int n, int row, int &sum, vector<vector<bool>> &location)
    {
        if(row == n)
        {
            sum++;
            return;
        }

        for(int i = 0; i < n; i++)
        {
            if(isValid(row, i, location, n))
            {
                location[row][i] = true;
                backTracking(n, row + 1, sum, location);
                location[row][i] = false;
            }
        }
    }
    int totalNQueens(int n) {
        int sum = 0;
        vector<vector<bool>> location(n, vector<bool>(n,false));
        backTracking(n, 0, sum, location);
        return sum;
    }
};
```

<a id="37"></a>

### [37. 解数独](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:

    bool isValid(int row, int col, char val, vector<vector<char>> &board)
    {
        for(int i = 0; i < 9; i++)
            if(board[i][col] == val || board[row][i] == val)
                return false;
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for(int i = startRow; i < startRow + 3; i++)
            for(int j = startCol; j < startCol + 3; j++)
                if(board[i][j] == val)
                    return false;
        return true;
    }
    bool backTracking(vector<vector<char>> &board)
    {
        for(int i = 0; i< board.size(); i++)
        {
            for(int j = 0; j < board.size(); j++)
            {
                if(board[i][j] != '.') continue;
                for(char k = '1'; k <= '9'; k++)
                {
                    if(isValid(i,j,k,board))
                    {
                        board[i][j] = k;
                        if(backTracking(board)) return true;
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        backTracking(board);
    }
};
```

<a id="733"></a>

### [733. 图像渲染](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
private:
    int direction[4][2] = {{0, 1},{1, 0}, {0, -1}, {-1, 0}};
public:
    void dfs(vector<vector<int>> &image, int sr, int sc, int originColor, int newColor)
    {
        image[sr][sc] = newColor;
        for(auto dir: direction)
        {
            int newX = sr + dir[0];
            int newY = sc + dir[1];
            if(inArea(newX, newY, image.size(), image[0].size()) && image[newX][newY] == originColor)
                dfs(image, newX, newY, originColor, newColor);
        }
    }
    bool inArea(int x, int y, int rows, int cols)
    {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        if(image[sr][sc] == newColor)
            return image;

        int originColor = image[sr][sc];
        dfs(image, sr, sc,originColor, newColor);
        return image;
    }
};

// 广度优先遍历
class Solution {
public:
    bool inArea(int x, int y, int rows, int cols)
    {
        return x >= 0 && x < rows && y >= 0 && y < cols;
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        int originColor = image[sr][sc];
        if(originColor == newColor)
            return image;

        int rows = image.size();
        int cols = image[0].size();

        int direction[4][2] = {{0, 1},{1, 0}, {0, -1}, {-1, 0}};
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        queue<vector<int>> q;
        q.push(vector<int>{sr, sc});
        visited[sr][sc] = true;
        while(q.empty() != true)
        {
            vector<int> head = q.front();
            q.pop();
            image[head[0]][head[1]] = newColor;
            for(auto dir: direction)
            {
                int newX = dir[0] + head[0];
                int newY = dir[1] + head[1];
                if(inArea(newX, newY, rows, cols) && visited[newX][newY] == false && image[newX][newY] == originColor)
                {
                    q.push(vector<int> {newX, newY});
                    visited[newX][newY] = true;
                }
            }
        }

        return image;
    }
};
```

<a id="79"></a>

### [79. 单词搜索](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
private:
    int direction[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
public:
    bool exist(vector<vector<char>>& board, string word) {
        int rows = board.size();
        if(rows == 0)
            return false;
        int cols = board[0].size();
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));

        for(int i = 0; i < rows; i++)
            for(int j = 0; j < cols; j++)
                if(dfs(board, word, visited, i, j, 0))
                    return true;
        return false;
    }

    bool dfs(vector<vector<char>>& board, string word, vector<vector<bool>> &visited, int i, int j, int begin)
    {
        if(begin == word.size() - 1)
            return board[i][j] == word[begin];

        if(board[i][j] == word[begin])
        {
            visited[i][j] = true;
            for(auto dir: direction)
            {
                int newX = dir[0] + i;
                int newY = dir[1] + j;
                if(inArea(newX, newY, board.size(), board[0].size()) && visited[newX][newY] == false)
                    if(dfs(board, word, visited, newX, newY, begin + 1))
                        return true;
            }
            visited[i][j] = false;
        }
        return false;
    }
    bool inArea(int i, int j, int rows, int cols)
    {
        return i >= 0 && j >= 0 && i < rows && j < cols;
    }
};
// 广度优先遍历

```

<a id="130"></a>

### [130. 被围绕的区域](#TopicSummary)

```C++{.line-numbers}
// 深度优先搜索
class Solution {
public:
    int n, m;

    void dfs(vector<vector<char>>& board, int x, int y) {
        if (x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }

    void solve(vector<vector<char>>& board) {
        n = board.size();
        if (n == 0) {
            return;
        }
        m = board[0].size();
        for (int i = 0; i < n; i++) {
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        }
        for (int i = 1; i < m - 1; i++) {
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
};

// 广度优先搜索
class Solution {
public:
    const int dx[4] = {1, -1, 0, 0};
    const int dy[4] = {0, 0, 1, -1};

    void solve(vector<vector<char>>& board) {
        int n = board.size();
        if (n == 0) {
            return;
        }
        int m = board[0].size();
        queue<pair<int, int>> que;
        for (int i = 0; i < n; i++) {
            if (board[i][0] == 'O') {
                que.emplace(i, 0);
            }
            if (board[i][m - 1] == 'O') {
                que.emplace(i, m - 1);
            }
        }
        for (int i = 1; i < m - 1; i++) {
            if (board[0][i] == 'O') {
                que.emplace(0, i);
            }
            if (board[n - 1][i] == 'O') {
                que.emplace(n - 1, i);
            }
        }
        while (!que.empty()) {
            int x = que.front().first, y = que.front().second;
            que.pop();
            board[x][y] = 'A';
            for (int i = 0; i < 4; i++) {
                int mx = x + dx[i], my = y + dy[i];
                if (mx < 0 || my < 0 || mx >= n || my >= m || board[mx][my] != 'O') {
                    continue;
                }
                que.emplace(mx, my);
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
};
```

<a id="200"></a>

### [200. 岛屿数量](#TopicSummary)

```C++{.line-numbers}
// 深度优先搜索
class Solution {
private:
    void dfs(vector<vector<char>>& grid, int r, int c) {
        int rows = grid.size();
        int cols = grid[0].size();

        grid[r][c] = '0';
        if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);
        if (r + 1 < rows && grid[r+1][c] == '1') dfs(grid, r + 1, c);
        if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);
        if (c + 1 < cols && grid[r][c+1] == '1') dfs(grid, r, c + 1);
    }

public:
    int numIslands(vector<vector<char>>& grid) {
        int rows = grid.size();
        if (!rows) return 0;
        int cols = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < rows; ++r) {
            for (int c = 0; c < cols; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
};

// 广度优先搜索遍历
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int nr = grid.size();
        if (!nr) return 0;
        int nc = grid[0].size();

        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    grid[r][c] = '0';
                    queue<pair<int, int>> neighbors;
                    neighbors.push({r, c});
                    while (!neighbors.empty()) {
                        auto rc = neighbors.front();
                        neighbors.pop();
                        int row = rc.first, col = rc.second;
                        if (row - 1 >= 0 && grid[row-1][col] == '1') {
                            neighbors.push({row-1, col});
                            grid[row-1][col] = '0';
                        }
                        if (row + 1 < nr && grid[row+1][col] == '1') {
                            neighbors.push({row+1, col});
                            grid[row+1][col] = '0';
                        }
                        if (col - 1 >= 0 && grid[row][col-1] == '1') {
                            neighbors.push({row, col-1});
                            grid[row][col-1] = '0';
                        }
                        if (col + 1 < nc && grid[row][col+1] == '1') {
                            neighbors.push({row, col+1});
                            grid[row][col+1] = '0';
                        }
                    }
                }
            }
        }

        return num_islands;
    }
};

```

<a id="417"></a>

### [417. 太平洋大西洋水流问题](#TopicSummary)

```C++{.line-numbers}
// 深度优先搜索——简洁版
class Solution {
public:
    vector<vector<int>> P, A, ans;
    int n, m;
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {
        n = M.size(), m = M[0].size();
        P = A = vector<vector<int>>(n, vector<int>(m, 0));
        //左右两边加上下两边出发深搜
        for(int i = 0; i < n; ++i) dfs(M, P, i, 0), dfs(M, A, i, m - 1);
        for(int j = 0; j < m; ++j) dfs(M, P, 0, j), dfs(M, A, n - 1, j);
        return ans;
    }
    void dfs(vector<vector<int>>& M, vector<vector<int>>& visited, int i, int j){
        if(visited[i][j]) return;
        visited[i][j] = 1;

        if(P[i][j] && A[i][j]) ans.push_back({i,j});

        //上下左右深搜
        if(i-1 >= 0 && M[i-1][j] >= M[i][j]) dfs(M, visited, i-1, j);
        if(i+1 < n && M[i+1][j] >= M[i][j]) dfs(M, visited, i+1, j);
        if(j-1 >= 0 && M[i][j-1] >= M[i][j]) dfs(M, visited, i, j-1);
        if(j+1 < m && M[i][j+1] >= M[i][j]) dfs(M, visited, i, j+1);
    }
};

// 深度优先搜索——扩展版
class Solution {
private:
    vector<vector<int>> res;
    int m, n;
    int dis[4][2] = { {1,0},{0,1},{-1,0},{0,-1} };
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return {};

        m = matrix.size(), n = matrix[0].size();
        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        vector<vector<bool>> atlantic(m, vector<bool>(n, false));
        // 从太平洋左边界流入 及 从大西洋右边界流入
        for (int i = 0; i < m; ++i) {
            dfs(matrix, pacific, INT_MIN, i, 0);
            dfs(matrix, atlantic, INT_MIN, i, n - 1);
        }

        // 从太平洋上边界流入 及 从大西洋下边界流入
        for (int i = 0; i < n; ++i) {
            dfs(matrix, pacific, INT_MIN, 0, i);
            dfs(matrix, atlantic, INT_MIN, m - 1, i);
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (pacific[i][j] && atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int pre, int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || matrix[i][j] < pre) {
            return;
        }

        visited[i][j] = true;
        for (int k = 0; k < 4; k++) {
            int newx = i + dis[k][0];
            int newy = j + dis[k][1];
            dfs(matrix, visited, matrix[i][j], newx, newy);
        }
    }
};

// 广度优先搜索
// 多源点BFS逆向思考，从大西洋和太平洋分别往里面层层流动，都能流到的即为合法结果点
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return {};

        m = matrix.size(), n = matrix[0].size();
        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        vector<vector<bool>> atlantic(m, vector<bool>(n, false));
        for (int i = 0; i < m; ++i) {
            bfs(matrix, pacific, i, 0); // from left Pacific
            bfs(matrix, atlantic, i, n - 1); // from right Atlantic
        }
        for (int i = 0; i < n; ++i) {
            bfs(matrix, pacific, 0, i); // from top Pacific
            bfs(matrix, atlantic, m - 1, i); // from bottom Atlantic
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (pacific[i][j] && atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }

private:
    vector<vector<int>> res;
    int m, n;
    int dirs[4][2] = { {1,0},{0,1},{-1,0},{0,-1}};
    void bfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int x, int y) {
        queue<vector<int>> q;
        q.push({x, y, INT_MIN});

        while (!q.empty()) {
           auto size = q.size();
           while (size--) {
               auto cur = q.front(); q.pop();
               auto i = cur[0];
               auto j = cur[1];
               auto curHeight = cur[2];
               if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || matrix[i][j] < curHeight) {
                  continue; // Don't use return!!!!　DFS return, BFS should only contine inside loop!!!
              }

              visited[i][j] = true;
              for (const auto& dir : dirs) {
                  auto ni = i + dir[0];
                  auto nj = j + dir[1];
                  q.push({ni, nj, matrix[i][j]});
              }
           }
        }
    }
};
```

<a id="1020"></a>

### [1020. 飞地的数量](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
public:
    int count = 0;
    void dfs(vector<vector<int>>& A, int i, int j) {
        if (!(i >= 0 && j >= 0 && i < A.size() && j < A[0].size()))
            return;
        if (A[i][j] == 1) {
            A[i][j] = -1;
        } else return;
        dfs(A, i - 1, j);
        dfs(A, i + 1, j);
        dfs(A, i, j - 1);
        dfs(A, i, j + 1);
    }
    int numEnclaves(vector<vector<int>>& A) {
        for (int i = 0; i < A.size(); i++)
            for (int j = 0; j < A[i].size(); j++)
                if ((i == 0 || j == 0 || i == A.size() - 1 || j == A[i].size() - 1) && A[i][j] == 1)
                    dfs(A, i, j);
        for (int i = 0; i < A.size(); i++)
            for (int j = 0; j < A[i].size(); j++)
                if (A[i][j] == 1) {
                    count++;
                }
        return count;
    }
};
```

<a id="1245"></a>

### [1254. 统计封闭岛屿的数目](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {
        int ret = 0;
        int ylen = grid.size();
        int xlen = grid[0].size();
        for (int i = 0; i < ylen; i++) {
            for (int j = 0; j < xlen; j++) {
                if (i == 0 || j == 0 || i == ylen-1 || j == xlen-1) {
                    bfs(j, i, grid);
                    //或者dfs(j, i, grid);
                }
            }
        }
        for (int i = 0; i < ylen; i++) {
            for (int j = 0; j < xlen; j++) {
                if (grid[i][j] == 0) {
                    ret++;
                    bfs(j, i, grid);
                    //或者dfs(j, i, grid);
                }
            }
        }
        return ret;
    }

    // 深度优先遍历
    void dfs(int x, int y, vector<vector<int>>& grid) {
        int xlen = grid[0].size();
        int ylen = grid.size();
        if (x >= xlen || y >= ylen || x < 0 || y < 0 || grid[y][x] == 1) {
            return;
        }
        grid[y][x] = 1;
        int vx[] = {0, 1, 0, -1};
        int vy[] = {1, 0, -1, 0};
        for (int i = 0; i < 4; i++) {
            dfs(x+vx[i], y+vy[i], grid);
        }
    }

    // 广度优先遍历
    void bfs(int x, int y, vector<vector<int>>& grid) {
        if (grid[y][x] == 1) {
            return;
        }
        int xlen = grid[0].size();
        int ylen = grid.size();
        queue<vector<int>> q;
        q.push({x, y});

        int vx[] = {0, 1, 0, -1};
        int vy[] = {1, 0, -1, 0};

        while (!q.empty()) {
            int curx = q.front()[0];
            int cury = q.front()[1];
            q.pop();
            grid[cury][curx] = 1;
            for (int i = 0; i < 4; i++) {
                int nextx = curx+vx[i];
                int nexty = cury+vy[i];
                if (nextx >= 0 && nextx < xlen && nexty >= 0 && nexty < ylen) {
                    if (grid[nexty][nextx] == 0) {
                        q.push({nextx, nexty});
                    }
                }
            }
        }
    }
};

// 深度优先遍历
class Solution {
public:
    vector<int> offsets = {-1, 0, 1, 0, -1};
    int closedIsland(vector<vector<int>>& grid) {
        // 这道题0表示陆地, 一个trick是遍历陆地后, 将0标记位2, 这样就不再需要一个visited数组
        int cnt = 0;
        int m = grid.size();
        if (m == 0) return 0;
        int n = grid[0].size();
        if (n == 0) return 0;
        // 记得先处理四条边界
        for (int i = 0; i < m; i++) {
            if (grid[i][0] == 0) dfs(grid, i, 0);
        }
        for (int i = 0; i < m; i++) {
            if (grid[i][n-1] == 0) dfs(grid, i, n-1);
        }
        for (int j = 0; j < n; j++) {
            if (grid[0][j] == 0) dfs(grid, 0, j);
        }
        for (int j = 0; j < n; j++) {
            if (grid[m-1][j] == 0) dfs(grid, m-1, j);
        }
        for (int i = 1; i < m - 1; i++) {
            for (int j = 1; j < n - 1; j++) {
                if (grid[i][j] == 0) {
                    dfs(grid, i, j);
                    ++cnt;
                }
            }
        }
        return cnt;
    }
    void dfs(vector<vector<int>>& grid, int i, int j) {
        if (grid[i][j] != 0) return; // 是水域或者是已经遍历过的陆地
        grid[i][j] = 2; // 表示已经遍历过
        for (int k = 0; k < 4; k++) {
            int x = offsets[k] + i, y = offsets[k+1] + j;
            if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size()) {
                // 越界了, 说明已经不是封闭的岛屿
                continue;
            }
            dfs(grid, x, y);
        }

    }
};
```

<a id="1034"></a>

### [1034. 边框着色](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
public:
    int dirs[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    bool valid(int r, int c, int R, int C) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }
    void dfs(vector<vector<int> >& grid, int r, int c, int R, int C, int color, vector<vector<int> >& res) {
        res[r][c] *= -1;
        bool is_edge = false;
        for (int k = 0; k < 4; ++k) {
            int nr = r + dirs[k][0];
            int nc = c + dirs[k][1];
            if (!valid(nr, nc, R, C) || grid[nr][nc] != grid[r][c]) {
                is_edge = true;
            }
            if (valid(nr, nc, R, C) && res[nr][nc] == grid[r][c]) {
                dfs(grid, nr, nc, R, C, color, res);
            }
        }
        res[r][c] *= -1;
        if (is_edge) {
            res[r][c] = color;
        }
    }
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {
        int R = grid.size();
        int C = grid[0].size();
        vector<vector<int> > res = grid;
        dfs(grid, r0, c0, R, C, color, res);
        return res;
    }
};
```

<a id="279"></a>

### [279. 完全平方数](#TopicSummary)

```C++{.line-numbers}
// 广度优先搜索
class Solution {
public:
    int numSquares(int n) {
        int min_sqrt_n = floor(sqrt(n));
        queue<int> Queue;
        Queue.push(0);
        int step = 0;

        while(!Queue.empty()){
            step ++;
            int size = Queue.size();
            for(int i = 0; i < size; i++){
                int front = Queue.front();
                Queue.pop();
                for(int j = 1; j <= min_sqrt_n; j++){
                    int sum = front + pow(j, 2);
                    if(sum == n) return step;
                    if(sum > n) continue;
                    Queue.push(sum);
                }
            }
        }
        return -1;
    }
};

```

<a id="752"></a>

### [752. 打开转盘锁](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    string plus1(string s, int j) //往上扭
    {
        if(s[j] == '9')
            s[j] = '0';
        else
            s[j] = s[j] + 1;
        return s;
    }

    string minus1(string s, int j) //往下扭
    {
        if(s[j] == '0')
            s[j] = '9';
        else
            s[j] = s[j] - 1;
        return s;
    }

    int openLock(vector<string>& deadends, string target) {
        string s = "0000"; //从0000开始扭
        unordered_set<string> visited; //去重hash
        for(auto &str: deadends) //把deadends写到visited中
            visited.insert(str);
        if(visited.count(s)) //特殊情况干掉
            return -1;
        queue<string> q; //队列走起
        q.push(s);
        int step = 0; //用于记录（层数）
        while(!q.empty())
        {
            auto sz = q.size(); //记录同一层的各种状态个数
            for(int i = 0; i < sz; ++i) //开始处理
            {
                string tmp = q.front();
                q.pop();
                if(tmp == target) //如果扭到了，那么就返回step
                    return step;
                for(int j = 0; j < 4; ++j) //没扭到，开始选路，4位上，每位都是2种潜在的扭法
                {
                    s = plus1(tmp, j);
                    if(!visited.count(s))
                    {
                        visited.insert(s);
                        q.push(s);
                    }
                    s = minus1(tmp, j);
                    if(!visited.count(s))
                    {
                        visited.insert(s);
                        q.push(s);
                    }
                }
            }
            ++step;
        }

        return -1;
    }
};
```

<a id="365"></a>

### [365. 水壶问题](#TopicSummary)

```C++{.line-numbers}
using PII = pair<int, int>;

class Solution {
public:
    bool canMeasureWater(int x, int y, int z) {
        stack<PII> stk;
        stk.emplace(0, 0);
        auto hash_function = [](const PII& o) {return hash<int>()(o.first) ^ hash<int>()(o.second);};
        unordered_set<PII, decltype(hash_function)> seen(0, hash_function);
        while (!stk.empty()) {
            if (seen.count(stk.top())) {
                stk.pop();
                continue;
            }
            seen.emplace(stk.top());

            auto [remain_x, remain_y] = stk.top();
            stk.pop();
            if (remain_x == z || remain_y == z || remain_x + remain_y == z) {
                return true;
            }
            // 把 X 壶灌满。
            stk.emplace(x, remain_y);
            // 把 Y 壶灌满。
            stk.emplace(remain_x, y);
            // 把 X 壶倒空。
            stk.emplace(0, remain_y);
            // 把 Y 壶倒空。
            stk.emplace(remain_x, 0);
            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。
            stk.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));
            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。
            stk.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));
        }
        return false;
    }
};

```

<a id="773"></a>

### [773. 滑动谜题](#TopicSummary)

```C++{.line-numbers}
const static int rows = 2;
const static int cols = 3;
// 记录当前状态信息
class Status
{
// 偷个懒，直接用公共了
public:
    // 记录唯一值
    int val;
    // 0所在的位置信息，用于下一轮的遍历
    int x;
    int y;
    // 记录步数
    int steps;
    int nums[rows*cols];
    Status(long val, int* input, int size, int x, int y, int steps) : val(val), x(x), y(y), steps(steps)
    {
        memcpy(nums, input, sizeof(int)*size);
    }
};

class Solution {
private:
    // 因为只有6个数字，采用十进制计算即可
    int Convert2String(int* nums, int size)
    {
        int res = 0;
        for (int i = 0; i < size; ++i)
        {
            res = res*10 + nums[i];
        }
        return res;
    }
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        // 直接用一维数组来保存来提速
        int nums[rows*cols];
        int srcX = 0;
        int srcY = 0;
        for (int i = 0; i < rows; ++i)
        {
            for (int j = 0; j < cols; ++j)
            {
                nums[i*cols + j]=board[i][j];
                if (nums[i*cols + j] == 0)
                {
                    srcX = i;
                    srcY = j;
                }
            }
        }
        // 目标值 (按照目前实现结尾额外会有一个空格)
        int target = 123450;

        // 四个遍历的方向
        int directions[] = {1, 0, -1, 0, 1};

        // 广度遍历使用的辅助queue
        queue<Status> q;

        //  初始化起点，steps为0
        Status start(Convert2String(nums, rows*cols), nums, rows*cols, srcX, srcY, 0);

        // 记录哪些状态被遍历过了
        unordered_set<int> visited;

        visited.insert(start.val);
        q.emplace(start);

        // 保存临时状态用于生产下一个状态status信息
        while (!q.empty())
        {
            Status& curr = q.front();
            if (curr.val == target)
            {
                return curr.steps;
            }

            int steps = curr.steps;
            int x = curr.x;
            int y = curr.y;
            memcpy(nums, curr.nums, sizeof(int)*rows*cols);
            q.pop();
            // 四个方向去遍历
            for (int i = 0; i < 4; ++i)
            {
                int nX = x + directions[i];
                int nY = y + directions[i+1];
                if (nX >= 0 && nX < rows && nY >=0 && nY < cols)
                {
                    // 创建临时状态
                    int tempNums[rows*cols];
                    memcpy(tempNums, nums, sizeof(int)*rows*cols);
                    swap(tempNums[x*cols+y], tempNums[nX*cols + nY]);
                    // cout << x << "," << y << " to " << nX << "," << nY << " " << x*cols+y << " to " << nX*cols + nY << endl;

                    int nextStr = Convert2String(tempNums, rows*cols);
                    // 忽略已经遍历的点
                    if (visited.find(nextStr) == visited.end())
                    {
                        q.emplace(nextStr, tempNums, rows*cols, nX, nY, steps+1);
                        visited.emplace(nextStr);
                    }
                }
            }
            
        }

        return -1;
    }
};
```

<a id="785"></a>

### [785. 判断二分图](#TopicSummary)

```C++{.line-numbers}
// 深度优先搜索
class Solution {
private:
    static constexpr int UNCOLORED = 0;
    static constexpr int RED = 1;
    static constexpr int GREEN = 2;
    vector<int> color;
    bool valid;

public:
    void dfs(int node, int c, const vector<vector<int>>& graph) {
        color[node] = c;
        int cNei = (c == RED ? GREEN : RED);
        for (int neighbor: graph[node]) {
            if (color[neighbor] == UNCOLORED) {
                dfs(neighbor, cNei, graph);
                if (!valid) {
                    return;
                }
            }
            else if (color[neighbor] != cNei) {
                valid = false;
                return;
            }
        }
    }

    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        valid = true;
        color.assign(n, UNCOLORED);
        for (int i = 0; i < n && valid; ++i) {
            if (color[i] == UNCOLORED) {
                dfs(i, RED, graph);
            }
        }
        return valid;
    }
};

// 广度优先搜索
class Solution {
private:
    static constexpr int UNCOLORED = 0;
    static constexpr int RED = 1;
    static constexpr int GREEN = 2;
    vector<int> color;

public:
    bool isBipartite(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> color(n, UNCOLORED);
        for (int i = 0; i < n; ++i) {
            if (color[i] == UNCOLORED) {
                queue<int> q;
                q.push(i);
                color[i] = RED;
                while (!q.empty()) {
                    int node = q.front();
                    int cNei = (color[node] == RED ? GREEN : RED);
                    q.pop();
                    for (int neighbor: graph[node]) {
                        if (color[neighbor] == UNCOLORED) {
                            q.push(neighbor);
                            color[neighbor] = cNei;
                        }
                        else if (color[neighbor] != cNei) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
};
```

<a id="886"></a>

### [886. 可能的二分法](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    bool paint(int x, int c, vector<vector<int>>& edges, vector<int>& colors) {
        if (colors[x] == c) return true;
        else if (colors[x] != 0 && colors[x] != c) return false;
        colors[x] = c;
        int reversed = (c == 1 ? 2 : 1);
        for (auto& e : edges[x]) {
            if (!paint(e, reversed, edges, colors)) {
                colors[x] = 0;
                return false;
            }
        }
        return true;
    }
    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {
        vector<vector<int>> edges(N);
        for (auto e : dislikes) {
            edges[e[0]-1].push_back(e[1]-1);
        }
        vector<int> colors(N, 0);
        for (int i = 0; i < N; ++i) {
            if(!paint(i, 1, edges, colors) && !paint(i, 2, edges, colors)) {
                return false;
            }
        }
        return true;
    }
};
```

<a id="133"></a>

### [133. 克隆图](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
public:
    unordered_map<Node*, Node*> visited;
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        // 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回
        if (visited.find(node) != visited.end()) {
            return visited[node];
        }

        // 克隆节点，注意到为了深拷贝我们不会克隆它的邻居的列表
        Node* cloneNode = new Node(node->val);
        // 哈希表存储
        visited[node] = cloneNode;

        // 遍历该节点的邻居并更新克隆节点的邻居列表
        for (auto& neighbor: node->neighbors) {
            cloneNode->neighbors.emplace_back(cloneGraph(neighbor));
        }
        return cloneNode;
    }
};

// 广度优先遍历
class Solution {
public:
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        unordered_map<Node*, Node*> visited;

        // 将题目给定的节点添加到队列
        queue<Node*> Q;
        Q.push(node);
        // 克隆第一个节点并存储到哈希表中
        visited[node] = new Node(node->val);

        // 广度优先搜索
        while (!Q.empty()) {
            // 取出队列的头节点
            auto n = Q.front();
            Q.pop();
            // 遍历该节点的邻居
            for (auto& neighbor: n->neighbors) {
                if (visited.find(neighbor) == visited.end()) {
                    // 如果没有被访问过，就克隆并存储在哈希表中
                    visited[neighbor] = new Node(neighbor->val);
                    // 将邻居节点加入队列中
                    Q.push(neighbor);
                }
                // 更新当前节点的邻居列表
                visited[n]->neighbors.emplace_back(visited[neighbor]);
            }
        }

        return visited[node];
    }
};
```

<a id="13"></a>

### [13. 机器人的运动范围](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visited(m, vector<bool>(n, 0));
        return dfs(0, 0, 0, 0, visited, m, n, k);
    }
private:
    int dfs(int i, int j, int si, int sj, vector<vector<bool>> &visited, int m, int n, int k) {
        if(i >= m || j >= n || k < si + sj || visited[i][j]) return 0;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj, visited, m, n, k) +
                   dfs(i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8, visited, m, n, k);
    }
};

// 广度优先遍历
class Solution {
    // 计算 x 的数位之和
    int get(int x) {
        int res=0;
        for (; x; x /= 10) {
            res += x % 10;
        }
        return res;
    }
public:
    int movingCount(int m, int n, int k) {
        if (!k) return 1;
        queue<pair<int,int> > Q;
        // 向右和向下的方向数组
        int dx[2] = {0, 1};
        int dy[2] = {1, 0};
        vector<vector<int> > vis(m, vector<int>(n, 0));
        Q.push(make_pair(0, 0));
        vis[0][0] = 1;
        int ans = 1;
        while (!Q.empty()) {
            auto [x, y] = Q.front();
            Q.pop();
            for (int i = 0; i < 2; ++i) {
                int tx = dx[i] + x;
                int ty = dy[i] + y;
                if (tx < 0 || tx >= m || ty < 0 || ty >= n || vis[tx][ty] || get(tx) + get(ty) > k) continue;
                Q.push(make_pair(tx, ty));
                vis[tx][ty] = 1;
                ans++;
            }
        }
        return ans;
    }
};
```

<a id="695"></a>

### [695. 岛屿的最大面积](#TopicSummary)

```C++{.line-numbers}
// 深度优先搜索
class Solution {
    int dfs(vector<vector<int>>& grid, int cur_i, int cur_j) {
        if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {
            return 0;
        }
        grid[cur_i][cur_j] = 0;
        int di[4] = {0, 0, 1, -1};
        int dj[4] = {1, -1, 0, 0};
        int ans = 1;
        for (int index = 0; index != 4; ++index) {
            int next_i = cur_i + di[index], next_j = cur_j + dj[index];
            ans += dfs(grid, next_i, next_j);
        }
        return ans;
    }
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i) {
            for (int j = 0; j != grid[0].size(); ++j) {
                ans = max(ans, dfs(grid, i, j));
            }
        }
        return ans;
    }
};

// 深度优先搜索 + 栈
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i) {
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                stack<int> stacki;
                stack<int> stackj;
                stacki.push(i);
                stackj.push(j);
                while (!stacki.empty()) {
                    int cur_i = stacki.top(), cur_j = stackj.top();
                    stacki.pop();
                    stackj.pop();
                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {
                        continue;
                    }
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        stacki.push(next_i);
                        stackj.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};

// 广度优先搜索
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
        for (int i = 0; i != grid.size(); ++i) {
            for (int j = 0; j != grid[0].size(); ++j) {
                int cur = 0;
                queue<int> queuei;
                queue<int> queuej;
                queuei.push(i);
                queuej.push(j);
                while (!queuei.empty()) {
                    int cur_i = queuei.front(), cur_j = queuej.front();
                    queuei.pop();
                    queuej.pop();
                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {
                        continue;
                    }
                    ++cur;
                    grid[cur_i][cur_j] = 0;
                    int di[4] = {0, 0, 1, -1};
                    int dj[4] = {1, -1, 0, 0};
                    for (int index = 0; index != 4; ++index) {
                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];
                        queuei.push(next_i);
                        queuej.push(next_j);
                    }
                }
                ans = max(ans, cur);
            }
        }
        return ans;
    }
};
```

<a id="529"></a>

### [529. 扫雷游戏](#TopicSummary)

```C++{.line-numbers}
// 深度优先遍历
class Solution {
public:
    int dir_x[8] = {0, 1, 0, -1, 1, 1, -1, -1};
    int dir_y[8] = {1, 0, -1, 0, 1, -1, 1, -1};

    void dfs(vector<vector<char>>& board, int x, int y) {
        int cnt = 0;
        for (int i = 0; i < 8; ++i) {
            int tx = x + dir_x[i];
            int ty = y + dir_y[i];
            if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size()) {
                continue;
            }
            // 不用判断 M，因为如果有 M 的话游戏已经结束了
            cnt += board[tx][ty] == 'M';
        }
        if (cnt > 0) {
            // 规则 3
            board[x][y] = cnt + '0';
        } else {
            // 规则 2
            board[x][y] = 'B';
            for (int i = 0; i < 8; ++i) {
                int tx = x + dir_x[i];
                int ty = y + dir_y[i];
                // 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了
                if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size() || board[tx][ty] != 'E') {
                    continue;
                }
                dfs(board, tx, ty);
            }
        }
    }

    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
        } else {
            dfs(board, x, y);
        }
        return board;
    }
};

// 广度优先遍历
class Solution {
public:
    int dir_x[8] = {0, 1, 0, -1, 1, 1, -1, -1};
    int dir_y[8] = {1, 0, -1, 0, 1, -1, 1, -1};

    void bfs(vector<vector<char>>& board, int sx, int sy) {
        queue<pair<int, int>> Q;
        vector<vector<int>> vis(board.size(), vector<int>(board[0].size(), 0));
        Q.push({sx, sy});
        vis[sx][sy] = true;
        while (!Q.empty()) {
            auto pos = Q.front();
            Q.pop();
            int cnt = 0, x = pos.first, y = pos.second;
            for (int i = 0; i < 8; ++i) {
                int tx = x + dir_x[i];
                int ty = y + dir_y[i];
                if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size()) {
                    continue;
                }
                // 不用判断 M，因为如果有 M 的话游戏已经结束了
                cnt += board[tx][ty] == 'M';
            }
            if (cnt > 0) {
                // 规则 3
                board[x][y] = cnt + '0';
            } else {
                // 规则 2
                board[x][y] = 'B';
                for (int i = 0; i < 8; ++i) {
                    int tx = x + dir_x[i];
                    int ty = y + dir_y[i];
                    // 这里不需要在存在 B 的时候继续扩展，因为 B 之前被点击的时候已经被扩展过了
                    if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size() || board[tx][ty] != 'E' || vis[tx][ty]) {
                        continue;
                    }
                    Q.push(make_pair(tx, ty));
                    vis[tx][ty] = true;
                }
            }
        }
    }

    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
        } else {
            bfs(board, x, y);
        }
        return board;
    }
};
```

<a id="994"></a>

### [994. 腐烂的橘子](#TopicSummary)

```C++{.line-numbers}
// 广度优先搜索
class Solution {
    int cnt;
    int dis[10][10];
    int dir_x[4]={0, 1, 0, -1};
    int dir_y[4]={1, 0, -1, 0};
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int,int> >Q;
        memset(dis, -1, sizeof(dis));
        cnt = 0;
        int n=(int)grid.size(), m=(int)grid[0].size(), ans = 0;
        for (int i = 0; i < n; ++i){
            for (int j = 0; j < m; ++j){
                if (grid[i][j] == 2){
                    Q.push(make_pair(i, j));
                    dis[i][j] = 0;
                }
                else if (grid[i][j] == 1) cnt += 1;
            }
        }
        while (!Q.empty()){
            pair<int,int> x = Q.front();Q.pop();
            for (int i = 0; i < 4; ++i){
                int tx = x.first + dir_x[i];
                int ty = x.second + dir_y[i];
                if (tx < 0|| tx >= n || ty < 0|| ty >= m|| ~dis[tx][ty] || !grid[tx][ty]) continue;
                dis[tx][ty] = dis[x.first][x.second] + 1;
                Q.push(make_pair(tx, ty));
                if (grid[tx][ty] == 1){
                    cnt -= 1;
                    ans = dis[tx][ty];
                    if (!cnt) break;
                }
            }
        }
        return cnt ? -1 : ans;
    }
};
```

<a id="1162"></a>

### [1162. 地图分析](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    static constexpr int MAX_N = 100 + 5;

    struct Coordinate {
        int x, y, step;
    };

    int n, m;
    vector<vector<int>> a;

    bool vis[MAX_N][MAX_N];

    int findNearestLand(int x, int y) {
        memset(vis, 0, sizeof vis);
        queue <Coordinate> q;
        q.push({x, y, 0});
        vis[x][y] = 1;
        while (!q.empty()) {
            auto f = q.front(); q.pop();
            for (int i = 0; i < 4; ++i) {
                int nx = f.x + dx[i], ny = f.y + dy[i];
                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= m - 1)) {
                    continue;
                }
                if (!vis[nx][ny]) {
                    q.push({nx, ny, f.step + 1});
                    vis[nx][ny] = 1;
                    if (a[nx][ny]) {
                        return f.step + 1;
                    }
                }
            }
        }
        return -1;
    }
    
    int maxDistance(vector<vector<int>>& grid) {
        this->n = grid.size();
        this->m = grid.at(0).size();
        a = grid;
        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (!a[i][j]) {
                    ans = max(ans, findNearestLand(i, j));
                }
            }
        }
        return ans;
    }
};
```

<a id="1091"></a>

### [1091. 二进制矩阵中的最短路径](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        // 所给的地图为空
        if(grid.size() == 0) {
            return -1;
        }
        // 确定方向
        int direction[8][2] = {{1, -1}, {1, 0}, {1, 1}, {0, 1}, {0, -1}, {-1, -1}, {-1, 0}, {-1, 1}};
        int m = grid.size(), n = grid[0].size();
        // 用队列存储每一轮能够经过的地方
        queue<vector<int>> q;   
        // 把第一个点放进去    
        q.push({0, 0});
        int length = 0;
        // 如果队列不为空，说明还能走，空了说明走不下去了直接返回-1
        while(!q.empty()) {
            // 每一轮步长+1
            length ++;
            int size = q.size();
            // 遍历每一轮中能够走到的位置
            while(-- size >= 0) {
                vector<int> site = q.front();
                q.pop();
                int x = site[0], y = site[1];
                // 如果不能走
                if(grid[x][y] == 1) {
                    continue;
                }
                // 如果走到右下角
                if(x == m - 1 && y == n - 1) {
                    return length;
                }
                // 走过的位置标记为不能走
                grid[x][y] = 1;
                // 八个方向遍历下一步能走的位置
                for(auto d : direction) {
                    int x1 = x + d[0], y1 = y + d[1];
                    if(x1 < 0 || x1 >= m || y1 < 0 || y1 >= n) {
                        continue;
                    }
                    if(grid[x1][y1] == 1) {
                        continue;
                    }
                    q.push({x1, y1});
                }
            }
        }
        return -1;
    }
};
```
