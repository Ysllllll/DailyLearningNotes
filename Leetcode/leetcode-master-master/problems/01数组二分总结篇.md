<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >
</p>
<p align="center">
  <a href="https://github.com/youngyangyang04/leetcode-master"><img src="https://img.shields.io/badge/Github-leetcode--master-lightgrey" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201115103410182.png"><img src="https://img.shields.io/badge/刷题-微信群-green" alt=""></a>
  <a href="https://img-blog.csdnimg.cn/20201210231711160.png"><img src="https://img.shields.io/badge/公众号-代码随想录-brightgreen" alt=""></a>
  <a href="https://space.bilibili.com/525438321"><img src="https://img.shields.io/badge/B站-代码随想录-orange" alt=""></a>
  <a href="https://www.zhihu.com/people/sun-xiu-yang-64"><img src="https://img.shields.io/badge/知乎-代码随想录-blue" alt=""></a>
  <a href="https://www.toutiao.com/c/user/60356270818/#mid=1633692776932365"><img src="https://img.shields.io/badge/头条-代码随想录-red" alt=""></a>
</p>

# 数组理论基础

数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力

也就是说，想法很简单，但实现起来 可能就不是那么回事了。

首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以方便的通过下表索引的方式获取到下表下对应的数据。

举一个字符数组的例子，如图所示：

![算法通关数组](https://img-blog.csdnimg.cn/2020121411152849.png)

需要两点注意的是

* **数组下表都是从0开始的。**
* **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

例如删除下表为3的元素，需要对下表为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://img-blog.csdnimg.cn/2020121411155232.png)

而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。

**数组的元素是不能删的，只能覆盖。**

那么二维数组直接上图，大家应该就知道怎么回事了

![算法通关数组2](https://img-blog.csdnimg.cn/20201214111612863.png)

**那么二维数组在内存的空间地址是连续的么？**

我们来举一个例子，例如： `int[][] rating = new int[3][4];` ， 这个二维数据在内存空间可不是一个 `3*4` 的连续地址空间

看了下图，就应该明白了：

![算法通关数组3](https://img-blog.csdnimg.cn/20201214111631844.png)

所以**二维数据在内存中不是 `3*4` 的连续地址空间，而是四条连续的地址空间组成！**

# 数组的经典题目

在面试中，数组是必考的基础数据结构。

其实数据的题目在思想上一般比较简单的，但是如果想高效，并不容易。

我们之前一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。

## 二分法

[数组：每次遇到二分法，都是一看就会，一写就废](https://mp.weixin.qq.com/s/fCf5QbPDtE6SSlZ1yh_q8Q) <font color = 'red'>2021/02/23</font>

这道题目呢，考察的数据的基本操作，思路很简单，但是在通过率在简单题里并不高，不要轻敌。

可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目

暴力解法时间复杂度：O(n)
二分法时间复杂度：O(logn)

在这道题目中我们讲到了**循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

**二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力**。

## 双指针法

* [数组：就移除个元素很难么？](https://mp.weixin.qq.com/s/wj0T-Xs88_FHJFwayElQlA) <font color = 'red'>2021/02/23</font>

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**  

暴力解法时间复杂度：O(n^2)
双指针时间复杂度：O(n)

这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为一下两点：

* 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。
* C++中vector和array的区别一定要弄清楚，vector的底层实现是array，所以vector展现出友好的一些都是因为经过包装了。

双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。

## 滑动窗口

* [数组：滑动窗口拯救了你](https://mp.weixin.qq.com/s/UrZynlqi4QpyLlLhBPglyg) <font color = 'red'>2021/02/23</font>

本题介绍了数组操作中的另一个重要思想：滑动窗口。

暴力解法时间复杂度：O(n^2)
滑动窗口时间复杂度：O(n)

本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。

## 模拟行为

* [数组：这个循环可以转懵很多人！](https://mp.weixin.qq.com/s/KTPhaeqxbMK9CxHUUgFDmg) <font color = 'red'>2021/02/23</font>

模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。

在这道题目中，我们再一次介绍到了**循环不变量原则**，其实这也是写程序中的重要原则。

相信大家又遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，踩了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实**真正解决题目的代码都是简洁的，或者有原则性的**，大家可以在这道题目中体会到这一点。

# 总结

从二分法到双指针，从滑动窗口到螺旋矩阵，相信如果大家真的认真做了「代码随想录」每日推荐的题目，定会有所收获。

推荐的题目即使大家之前做过了，再读一遍的文章，也会帮助你提炼出解题的精髓所在。

如果感觉有所收获，希望大家多多支持，打卡转发，点赞在看 都是对我最大的鼓励！

最后，大家周末愉快！

<a id="TopicSummary"></a>

> **题目汇总**
>
> * 数组：每次遇到二分法，都是一看就会，一写就废
>   * **[Leetcode 35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/submissions/)** [速览题解](#35)
> * 数组：就移除个元素很难么？
>   * **[Leetcode 27. 移除元素](https://leetcode-cn.com/problems/remove-element/submissions/)** [速览题解](#27)
> * 数组：滑动窗口拯救了你
>   * **[Leetcode 209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)** [速览题解](#209)
> * 数组：这个循环可以转懵很多人！
>   * **[Leetcode 54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)** [速览题解](#54)
>   * **[Leetcode 59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)** [速览题解](#59-2)
>
>+++++++++++++++++++++++++++++++++++++++++++++++++++++++
>
> * 附加题：
>
>   * **[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)** [速览题解](#1)
>     * 简评：这道题不能用双指针法，因为双指针要求数组排序，但是我们数组排序后下标就变了。另外注意哈希碰撞，虽然这里哈希碰撞没有影响
>   * **[15. 三数之和](https://leetcode-cn.com/problems/3sum/)** [速览题解](#15)
>     * 简评：这道题与下标无关，所以可以排序。然后固定一边，剩下的变换成求**两数之和**的问题，注意当nums[i]>0后可以直接返回了，另外要注意去重
>   * **[18. 四数之和](https://leetcode-cn.com/problems/4sum/)** [速览题解](#18)
>     * 简评：三数之和的基础上再套一层循环，但是要注意剪枝！！如何剪枝参考第二种代码
>   * **总评**：1. 注意 target 为一个负得更小的值时，不能单纯的用nums[i] > target来剪枝。2. 将问题逐渐简化为**两数之和**，变为两数之和后，由于有序，就是一个简单的**双指针问题**。**但是为什么这里第一题不用双指针呢？**，因为它要的是下标，没办法对数组排序
>   * **[88. 合并两个有序数组](https://leetcode-cn.com/problems/4sum/)** [速览题解](#88)
>     * 简评：三个指针倒序合并。其它思路就是先合并再排序，但是时间复杂度不好
>
> * **以下为二分专区**
> 一个很好的汇总帖子[写对二分查找不能靠模板，需要理解加练习](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)
>   * **[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)** [速览题解](#704)
>     * 简评：二分查找 target，主要关注如下几个方面：
`while(left < right)`
`int mid = left + (right - left + 1) / 2` 搭配`right = mid - 1`
`int mid = left + (right - left) / 2`搭配 `left = mid + 1`
上面的两个搭配最简单直观的想法是:`mid = left`, 下次一定是 `left = mid + 1`，不能是 `left = mid`，这样就没有更新 `left`
`if(nums[mid] < target) ~ left = mid + 1`
`if(target < nums[mid]) ~ left = mid`
>   * **[374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)** [速览题解](#374)
>   * **[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)** [速览题解](#34)
>     * 简评：这道题整合了 **`lowerBound()`**，**`upperBound()`**，**`searchInsertPosition()`**
>   * **[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)** [速览题解](#153)
>     * 简评：这道题，数组中的元素**没有重复**，搜索**最小**
画图然后分情况讨论即可。**判断 `mid` 处于第一个排序数组还是第二个排序数组**
>   * **[154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)** [速览题解](#154)
>     * 简评：这道题，数组中的元素**有重复**，搜索**最小**
注意下面的示例，这时没有办法确定 **`mid` 在第一个排序数组还是在第二个排序数组**。解决办法就是消除这种歧义，**找到第一个比 `nums[0]` 小的`right`**，然后就可以用153的解法了。
`[left=0,0,mid=0,-1,0,right=0] [left=0,-1,mid=0,0,right=0]`
>   * **[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)** [速览题解](#33)
>     * 简评：这道题，数组中的元素**没有重复**，搜索**给定值**
**第一种思路**：做这道题的时候最好脑海中要有**一幅数组高度的图**，然后判断 `mid` 在**第一排序数组**还是在**第二排序数组**；然后判断：**若之前判断 `mid` 在第一排序数组中时**， 则判断 `target` 是否在有序区间 `[left, mid]` 中；**若之前判断 `mid` 在第二排序数组中时**，则判断 `target` 是否在有序区间 `[mid, right]` 中。
**第二种思路**：`mid` 将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环。
>   * **[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)** [速览题解](#81)
>     * 简评：这道题，数组中的元素**有重复**，搜索**给定值**
思路参考33题的第二种思路，当中有些变化见代码
>   * **[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)** [速览题解](#278)
>     * 简评：这道题，**虽然数组中只有两个值 `[false, true]`**，但是依然可以用二分法，相当于找数组中 `target = true`的下界
>   * **[852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)** [速览题解](#852)
>     * 简评：关键在**转换为单调问题**
我们对问题进行转换，转换为一个单调的规律，我们发现数组的差值组成的数组保证了单调递增的部分差值均为正数，单调递减的部分差值均为负数，整个数组呈现 [正数，正数，正数，...，负数，负数] 这样前半部分均为正数，后半部分均为负数的性质，**满足单调性，因此我们可以使用二分查找**
>   * **[1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)** [速览题解](#1095)
>     * 简评：先找到峰值，在找target，即：
1、获取山顶的index
2、上山部分，递增二分查找，如果找不到。下山部分，递减二分查找
>   * **[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)** [速览题解](#69)
>     * 简评：1.注意数组越界问题；2.注意 `if(x <= 1) return x;` 这样的特例；3.注意将这个问题转换为二分问题；3.可以了解下**牛顿迭代法**，数学方法
>   * **[287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)** [速览题解](#287)
>     * 简评：1.将问题转换为二分查找，这里涉及到抽屉原理，这里二分查找条件的获取有一个遍历循环；2.可以用双指针来做 **[后面再看]**
>   * **[1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/)** [速览题解](#1300)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；2.这道题也可以不用二分查找来做 **[后面再看]**
>
> * **以下是二分升级版**
>   * **[875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/submissions/)** [速览题解](#1300)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；
>   * **[410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/solution/)** [速览题解](#410)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；2.这道题也可以用动态规划来做 **[后面再看]**
>   * **[1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/submissions/)** [速览题解](#1011)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；2.这道题和 **875、410** 都是一个思路
>   * **[1482. 制作 m 束花所需的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/)** [速览题解](#1482)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；
>   * **[LCP 12. 小张刷题计划](https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/solution/xiao-zhang-shua-ti-ji-hua-er-fen-cha-zhao-by-leetc/)** [速览题解](#12)
>     * 简评：1.将问题转换为二分查找，这里二分查找条件的获取有一个遍历循环；

<a id="35"></a>

### [35. 搜索插入位置](#TopicSummary)

```C++{.line-numbers}
// 迭代：将区间分为三个部分
class Solution
{
public:
    int searchInsert(vector<int> &nums, int target)
    {
        //左闭右闭[left, right]
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) // 当left==right，区间[left, right]依然有效
        {                                          
            int mid = left + ((right - left) / 2); // 防止溢出 等同于(left + right)/2
            if (target < nums[mid])
                right = mid - 1; // target 在左区间，所以[left, mid - 1]
            else if (nums[mid] < target)
                left = mid + 1; // target 在右区间，所以[mid + 1, right]
            else
                return mid; // nums[mid] == target
        }
        return left;
    }
};

// 迭代：将区间分为三个部分
class Solution
{
public:
    int searchInsert(vector<int> &nums, int target)
    {
        //左闭右开[left, right)
        int n = nums.size();
        int left = 0;
        int right = n; // 定义target在左闭右开的区间里，[left, right)  target
        while (left < right) // 因为left == right的时候，在[left, right)是无效的空间
        { 
            int mid = left + ((right - left) >> 1);
            if (target < nums[mid])
                right = mid; // target 在左区间，在[left, mid)中
            else if (nums[mid] < target)
                left = mid + 1; // target 在右区间，在 [mid+1, right)中
            else
                // nums[mid] == target
                return mid; // 数组中找到目标值的情况，直接返回下标
        }
        return left;
    }
};

// 迭代：将区间分为两个部分
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        // 注意这里为什么要取[left, right)开区间
        // 因为答案的存在区间就是[left, right)，如果取闭区间就将答案给排除了一部分
        int left = 0, right = nums.size();

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] < target)
                // 这里是正确的 nums[mid] < target < nums[mid + 1]时，我们取 mid + 1，向上取整
                left = mid + 1;
            else
                right = mid;
        }

        return left;
    }
};

// 迭代：将区间分为两个部分,注意以下的写法是错误的
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        // 注意这里为什么要取[left, right)开区间
        // 因为答案的存在区间就是[left, right)，如果取闭区间就将答案给排除了一部分
        int left = 0, right = nums.size();

        while(left < right)
        {
            int mid = left + (right - left + 1) / 2;
            if(target < nums[mid])
                // 错误就错误在这里，因为 nums[mid - 1] < target < nums[mid]，这里就是向下取整
                right = mid - 1; 
            else
                left = mid;
        }

        return left;
    }
};
```

<a id="27"></a>

### [27. 移除元素](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        //头尾指针
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right)
        {
            while(left <= right && nums[right] == val)
                right--;
            while(left <= right && nums[left] != val)
                left++;
            if(left <= right && left < nums.size() && right > 0)//注意这里要有left <= right
                swap(nums[left], nums[right]);
        }
        return right + 1;
    }
};

class Solution {
public:
    int removeElement(vector<int>& nums, int val) 
    {
        //快慢指针
        int slow = 0; 
        for (int fast = 0; fast < nums.size(); fast++)  
            if (val != nums[fast])
                nums[slow++] = nums[fast]; 
        return slow;
    }
};
```

<a id="209"></a>

### [209. 长度最小的子数组](#TopicSummary)

```C++{.line-numbers}
class Solution
{
public:
    int minSubArrayLen(int s, vector<int> &nums)
    {
        int result = INT32_MAX;
        int sum = 0;       // 滑动窗口数值之和
        int i = 0;         // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++)
        {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s)
            {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

<a id="54"></a>

### [54. 螺旋矩阵](#TopicSummary)

```C++{.line-numbers}
//54. 螺旋矩阵
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};

```

<a id="59-2"></a>

### [59-II. 螺旋矩阵II](#TopicSummary)

```C++{.line-numbers}
//59-II. 螺旋矩阵II
class Solution
{
public:
    vector<vector<int>> generateMatrix(int n)
    {
        if (!n) return {}; //若数组为空，直接返回答案
        vector<vector<int>> matrix(n, vector<int>(n));
        int u = 0; //赋值上下左右边界
        int d = n - 1;
        int l = 0;
        int r = n - 1;
        int num = 1;
        while (true)
        {
            for (int i = l; i <= r; ++i) matrix[u][i] = num++; //向右移动直到最右
            if (++u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同

            for (int i = u; i <= d; ++i) matrix[i][r] = num++; //向下
            if (--r < l) break; //重新设定有边界

            for (int i = r; i >= l; --i) matrix[d][i] = num++; //向左
            if (--d < u) break; //重新设定下边界

            for (int i = d; i >= u; --i) matrix[i][l] = num++; //向上
            if (++l > r) break; //重新设定左边界
        }
        return matrix;
    }
};
```

<a id="1"></a>

### [1. 两数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mp;
        for(int i = 0; i < nums.size(); i++)
        {
            if(mp.find(target - nums[i]) != mp.end())
                return {i, mp[target - nums[i]]};
            mp[nums[i]] = i;
        }
        return {};
    }
};
```

<a id="15"></a>

### [15. 三数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 已经排好序了，如果首个都大于0，left-right一定大于0
            // 这样剪枝可能出现的问题参考 "四数之和"
            if (nums[i] > 0)
            {
                return result;
            }

            // 注意去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
               if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    
                    //这里尤其注意
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

<a id="18"></a>

### [18. 四数之和](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if(nums.size() < 4) return {};

        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int left = 0, right = 0, sum = 0;
        for(int i = 0; i < nums.size() - 3; i++)
        {
            // 剪枝错误，当target为负数时就会直接返回
            // if (nums[i] > target) return res;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            for(int j = i + 1; j < nums.size(); j++)
            {
                // 注意了，这里也不能这样去重，因为 j 会循环到nums.size() - 2处，
                // 但是这些都是错误组合，不能提前返回
                // if (nums[i] + nums[j] > target) return res;
                if(j > i + 1 && nums[j] == nums[j - 1]) continue;
                
                left = j + 1, right = nums.size() - 1;
                while(left < right)
                {
                    sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if(sum == target)
                    {
                        res.push_back(vector<int>{nums[i],nums[j], nums[left], nums[right]});
                        while(left < right && nums[left] == nums[left + 1]) left++;
                        while(left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    }
                    else if(sum > target)
                        right--;
                    else
                        left++;
                }
            }
        }
        return res;
    }
};

// 剪枝详细
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) 
    {
       vector<vector<int> > res;
       int n = nums.size();
       if (n < 4)   return res; // 特判
       sort(nums.begin(), nums.end()); // 排序
       // 选取第一个数
       for (int i = 0; i < n - 3; i++)
       {
            if (i > 0 && nums[i] == nums[i-1])  // 去重
                continue;
            if (nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target) // 剪枝
                break;
            if (nums[i] + nums[n-3] + nums[n-2] + nums[n-1] < target) // 剪枝
                continue;
            // 选取第二个数
            for (int j = i+1; j < n - 2; j++)
            {
                if (j > i+1 && nums[j] == nums[j-1]) // 去重
                    continue;
                if (nums[i] + nums[j] + nums[j+1] + nums[j+2] > target) // 剪枝
                    break;
                if (nums[i] + nums[j] + nums[n-2] + nums[n-1] < target) // 剪枝
                    continue;               
                // 通过双指针取第三个和第四个数
                int left = j + 1;
                int right = n - 1;
                while (left < right)
                {
                    if (nums[left] + nums[right] < target - nums[i] - nums[j])
                        left++;     // 此两数之和太小，左指针右移
                    else if (nums[left] + nums[right] > target - nums[i] - nums[j])
                        right--;    // 此两数之和太大，右指针左移
                    else
                    {
                        // 找到一组解，左右指针内缩，继续寻找
                        res.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
                        
                        // 去重
                        while (left < right && nums[left] == nums[left+1])   left++;
                        while (left < right && nums[right] == nums[right-1])   right--;
                        left++; right--;
                    }
                }
            }
       } 
       return res;
    }
};

```

<a id="88"></a>

### [88. 合并两个有序数组](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        if(n == 0) return;
        if(m == 0) 
        {
            for(int i = 0; i < n; i++)
                nums1[i] = nums2[i];
            return;
        }

        int j1 = m - 1, j2 = n - 1, i = 0;
        for(i = m + n - 1; (i >= 0) && (j1 >= 0) && (j2 >= 0); i--)
        {
            if(nums1[j1] < nums2[j2])
            {
                nums1[i] = nums2[j2];
                j2--;
            }
            else
            {
                nums1[i] = nums1[j1];
                j1--;
            }
        }

        while(i >= 0 && j1 >= 0)
            nums1[i--] = nums1[j1--];
        while(i >= 0 && j2 >= 0)
            nums1[i--] = nums2[j2--];

        return;
    }
};

// 极简写法
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = nums1.size() - 1;
        m--;
        n--;
        while (n >= 0) {
            while (m >= 0 && nums1[m] > nums2[n]) {
                swap(nums1[i--], nums1[m--]);
            }
            swap(nums1[i--], nums2[n--]);
        }
    }
};
```

<a id="704"></a>

### [704. 二分查找](#TopicSummary)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int searchHelper(vector<int> &nums, int left, int right, int target)
    {
        if(left > right) return -1;
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid;
        else if(nums[mid] < target)
            return searchHelper(nums, mid + 1, right, target);
        else
            return searchHelper(nums, left, mid - 1, target);
    }
    int search(vector<int>& nums, int target) {
        return searchHelper(nums, 0, nums.size() - 1, target);
    }
};

// 迭代版本一：将区间分为三个部分（if-elseif-else）
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() < 1) return -1;

        int left = 0, right = nums.size() - 1;
        while(left <= right) // 1
        {
            int mid = left + (right - left) / 2; // 2
            if(target == nums[mid]) // 3
                return mid;
            else if(target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1; // 4
        }
        return -1;
    }
};

// 迭代版本二：将区间分为两个部分（if-else）
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right) // 1
        {
            int mid = left + (right - left) / 2; // 2
            if(nums[mid] < target) // 3
                left = mid + 1; // 4
            else
                right = mid;
        }
        if(nums[left] == target)
            return left;
        else
            return -1;
    }
};

// 迭代版本三：将区间分为两个部分（if-else）
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right) // 1
        {
            int mid = left + (right - left + 1) / 2; // 2
            if(target < nums[mid]) // 3
                right = mid - 1;
            else
                left = mid; // 4
        }
        if(nums[left] == target)
            return left;
        else
            return -1;
    }
};
```

<a id="374"></a>

### [374. 猜数字大小](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int guessNumber(int n) {
        if(n < 1) return 0;

        int left = 1, right = n;
        while(left <= right)
        {
            int mid = left + (right - left) / 2;
            int isRes = guess(mid);
            if(isRes == 0)
                return mid;
            else if(isRes == -1)
                right = mid - 1;
            else
                left = mid + 1;
        }
        return -1;
    }
};
```

<a id="34"></a>

### [34. 在排序数组中查找元素的第一个和最后一个位置](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int searchLow(vector<int> &nums, int target)
    {
        // 如果取值范围 包含 nums.size()，则是right = nums.size()
        // 如果取值范围 不包含 nums.size()，则是right = nums.size() - 1
        // 这里属于第二种情况
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] < target)
                left = mid + 1; // 先上取整，从if语句出发思考较为简单
            else
                right = mid;// 思考极端情况[1,1,1,1,1],target = 1
        }
        if(nums[left] == target)
            return left;
        else
            return -1;
    }
    int searchHigh(vector<int> &nums, int target)
    {
        // 如果取值范围 包含 nums.size()，则是right = nums.size()
        // 如果取值范围 不包含 nums.size()，则是right = nums.size() - 1
        // 这里属于第二种情况
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left + 1) / 2;
            if(target < nums[mid])
                right = mid - 1; // 向下取整
            else
                left = mid; // 思考极端情况[1,1,1,1,1],target = 1
        }
        if(nums[left] == target)
            return left;
        else
            return -1;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};

        int low = searchLow(nums, target);
        int high = searchHigh(nums, target);
        return {low, high};
    }
};
```

<a id="153"></a>

### [153. 寻找旋转排序数组中的最小值](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[left] > nums[right])
            {
                if(nums[mid] > nums[right]) // 处于第一个排序区间
                    left  = mid + 1;
                else // 处于第二个排序区间，不能是right = mid - 1
                    right = mid;
            }
            // 一定处于第一个排序区间，此时的left一定指向最小值
            // 所以这里可以有三种写法：
            // right = mid - 1;
            // return nums[left];
            // break;
            else
                break;
        }
        return nums[left];
    }
};

// 比较统一的写法：将区间分成两个部分
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) 
            {          
                left = mid + 1;
            } 
            else 
            {                               
                right = mid;
            }
        }
        return nums[left];
    }
};
```

<a id="154"></a>

### [154. 寻找旋转排序数组中的最小值 II](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        // 相比于 153 多余的一步
        while(right > 0 && nums[right] == nums[0])
            right--;

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[left] > nums[right])
            {
                if(nums[mid] > nums[right])
                    left = mid + 1;
                else
                    right = mid;
            }
            else
                break;
        }
        return nums[left];
    }
};

// 比较统一的写法：将区间分成两个部分
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(right > 0 && nums[right] == nums[0])
            right--;
        while (left < right) 
        {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) 
            {          
                left = mid + 1;
            } 
            else 
            {                               
                right = mid;
            }
        }
        return nums[left];
    }
};

```

<a id="33"></a>

### [33. 搜索旋转排序数组](#TopicSummary)

```C++{.line-numbers}
// 第一种思路的写法：将区间分成三部分
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0) return -1;

        int left = 0, right = nums.size() - 1;
        while(left <= right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] >= nums[left])
            {
                if(nums[mid] > target && target >= nums[left])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else
            {
                if(nums[mid] < target && target <= nums[right])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
};

// 第二种思路写法：比较统一的写法，将区间分成两部分
class Solution
{
public:
    int search(vector<int> &nums, int target)
    {
        if (nums.size() == 0)
            return -1;

        int left = 0, right = nums.size() - 1;
        while (left < right)
        {
            // 根据分支的逻辑将中间数改成上取整
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] < nums[right])
            {
                // 此时 [mid..right] 有序
                if (nums[mid] <= target && target <= nums[right])
                {
                    // 如果 target 的值落在这个区间里，下一轮搜索区间是 [mid..right]，此时设置 left = mid;
                    left = mid;
                }
                else
                {
                    // 否则，下一轮搜索区间是 [left..mid - 1]，此时设置 right = mid - 1;
                    right = mid - 1;
                }
            }
            else
            {
                // 此时 nums[mid] >= nums[right]，能否说明 [left, mid] 是有序的？
                // 答案是：不能
                // 举出一个例子：当区间中只有两个元素时，如[3, 1]。由于中间数向上取整，mid 和 right 重合，进入该逻辑分支。
                // 此时[left, mid] 不是有序的，而是[left, mid - 1]才是有序的。所以我们不能直接说[left, mid]有序
                // 另外这里不可以写成 nums[left] <= target && target < nums[mid]
                if (nums[left] <= target && target <= nums[mid - 1])
                {
                    // 如果 target 的值落在区间 [left..mid - 1] 里，设置 right = mid - 1;
                    right = mid - 1;
                }
                else
                {
                    // 否则，下一轮搜索区间是 [mid..right]，此时设置 left = mid;
                    left = mid;
                }
            }
        }
        if (nums[left] == target)
        {
            return left;
        }
        return -1;
    }
};
```

<a id="81"></a>

### [81. 搜索旋转排序数组 II](#TopicSummary)

```C++{.line-numbers}
class Solution
{
public:
    int search(vector<int> &nums, int target)
    {
        if (nums.size() == 0)  return -1;

        int left = 0, right = nums.size() - 1;

        while (left < right)
        {  
            // 变为 33 题的情况，防止[3,1,1,1]情况进入else语句，然后left = mid，将正确答案排除掉
            while((right - 1 > left) && nums[right] == nums[right - 1]) right--;
            int mid = left + (right - left + 1) / 2;
            if (nums[mid] < nums[right])
            {
                if (nums[mid] <= target && target <= nums[right])
                    left = mid;
                else
                    right = mid - 1;
            }
            else
            {
                if (nums[left] <= target && target <= nums[mid - 1])
                    right = mid - 1;
                else
                    left = mid;
            }
        }
        return nums[left] == target;
    }
};
```

<a id="278"></a>

### [278. 第一个错误的版本](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int firstBadVersion(int n) {
        if(n < 1) return -1;

        int left = 0, right = n;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            bool version = isBadVersion(mid);
            if(version == false)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};
```

<a id="852"></a>

### [852. 山脉数组的峰顶索引](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        
        int left = 0, right = arr.size() - 1;

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(arr[mid] < arr[mid + 1])
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};
```

<a id="1095"></a>

### [1095. 山脉数组中查找目标值](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findInMountainArray(int target, MountainArray &mountainArr) {
        int size = mountainArr.length() - 1;

        // 1. 找到峰值
        int left = 0, right = size;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(mountainArr.get(mid) < mountainArr.get(mid + 1))
                left = mid + 1;
            else
                right = mid;
        }
        int mountainPeak = left;

        // 2. 在递增序列找target
        left = 0, right = mountainPeak;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(mountainArr.get(mid) < target)
                left = mid + 1;
            else
                right = mid;
        }
        if(mountainArr.get(left) == target)
            return left;

        // 2. 在递减序列找target
        left = mountainPeak, right = size;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(target < mountainArr.get(mid))
                left = mid + 1;
            else
                right = mid;
        }
        if(mountainArr.get(left) == target)
            return left;
        else
            return -1;
    }
};
```

<a id="69"></a>

### [69. x 的平方根](#TopicSummary)

```C++{.line-numbers}
// 暴力解法
class Solution {
public:
    int mySqrt(int x) {

        if(x <= 1) return x;

        int i = 1;
        for(; i <= x / i; i++);
        return i - 1;
    }
};

// 二分查找法
class Solution {
public:
    int mySqrt(int x) {
        if(x < 1) return 0;
        if(x == 1) return 1;

        int left = 0, right = x / 2;
        while(left < right)
        {
            int mid = left + (right - left + 1) / 2;
            if(x / mid < mid)
                right = mid - 1;
            else
                left = mid;
        }
        return left;
    }
};
```

<a id="287"></a>

### [287. 寻找重复数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int findDuplicate(vector<int> &nums) {
        int left = 1, right = nums.size() - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;

            int cnt = 0;
            for (int num:nums)
                if (num <= mid)
                    cnt++;

            // 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，
            // 此时重复元素一定出现在 [1, 4] 区间里
            if (cnt > mid) {
                // 重复的元素一定出现在 [left, mid] 区间里
                right = mid;
            } else {
                // if 分析正确了以后，else 搜索的区间就是 if 的反面
                // [mid + 1, right]
                // 注意：此时需要调整中位数的取法为上取整
                left = mid + 1;
            }
        }
        return left;
    }
};
```

<a id="1300"></a>

### [1300. 转变数组后最接近目标值的数组和](#TopicSummary)

```C++{.line-numbers}
// 向上取
class Solution {
public:
    int calSum(vector<int>& arr, int threshold)
    {
        int sum = 0;
        for(int num: arr)
            sum += min(num, threshold);
        return sum;
    }
    int findBestValue(vector<int>& arr, int target) {
        int left = 0, right = *max_element(arr.begin(), arr.end());

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int sum = calSum(arr, mid);
            if(sum < target) // 注意是向上取，在 34 题中有介绍
                left = mid + 1;
            else
                right = mid;
        }

        // 注意下面，究竟是对比 left 和 left - 1 还是对比 left 和 left + 1
        // 要根据if(sum < target)是向上取还是向下取
        // if(sum < target) 向上取，比较 left 和 left - 1
        // if(target < sum) 向下取，比较 left 和 left + 1
        int sum1 = calSum(arr, left - 1);
        int sum2 = calSum(arr, left);
        if(abs(target - sum1) <= abs(sum2 - target))
            return left - 1;
        else
            return left;
    }
};

// 向下取
class Solution {
public:
    int calSum(vector<int>& arr, int threshold)
    {
        int sum = 0;
        for(int num: arr)
            sum += min(num, threshold);

        return sum;
    }
    int findBestValue(vector<int>& arr, int target) {
        int left = 0, right = *max_element(arr.begin(), arr.end());

        while(left < right)
        {
            int mid = left + (right - left + 1) / 2;
            int sum = calSum(arr, mid);
            if(target < sum)
                right = mid - 1;
            else
                left = mid;
        }

        int sum1 = calSum(arr, left);
        int sum2 = calSum(arr, left + 1);
        // 注意：这里必须加绝对值，因为有可能出现 sum1 == sum2 < target 的情况
        if(abs(target - sum1) <= abs(sum2 - target))
            return left;
        else
            return left + 1;
    }
};
```

<a id="875"></a>

### [875. 爱吃香蕉的珂珂](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int left = 1, right = *max_element(piles.begin(), piles.end());

        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int cnt = 0;
            for(int pile: piles)
                cnt += ((pile / mid) + (int)(pile % mid != 0));
            
            // 按照之前的套路来，这里应该是 cnt < h
            // 但是这里 h < cnt 的含义其实是一致的
            // cnt 太大，说明吃得太慢了，需要吃多一点
            if(h < cnt)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};
```

<a id="410"></a>

### [410. 分割数组的最大值](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int split(vector<int>& nums, int maxSum) {
        int res = 1, sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            if(sum > maxSum)
            {
                sum = nums[i];
                res++;
            }
        }
        return res;
    }
    int splitArray(vector<int>& nums, int m) {
        int max = *max_element(nums.begin(), nums.end());
        int sum = accumulate(nums.begin(), nums.end(), 0);

        int left = max, right = sum;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int splits = split(nums, mid);

            // 如果 splits 分割次数为100次，而目标次数是1次，显然当前的mid太小了
            if(m < splits)
                left = mid + 1;
            else
                right = mid;
        }

        return left;
    }
};
```

<a id="1011"></a>

### [1011. 在 D 天内送达包裹的能力](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int getDay(vector<int>& weights, int capacity)
    {
        int res = 1, sum = 0;
        for(int weight: weights)
        {
            sum += weight;
            if(sum > capacity)
            {
                sum = weight;
                res++;
            }
        }
        return res;
    }
    int shipWithinDays(vector<int>& weights, int D) {

        int left = *max_element(weights.begin(), weights.end());
        int right = accumulate(weights.begin(), weights.end(), 0);
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int day = getDay(weights, mid);

            // 当前的运输能力要运送10000天，说明运输能力小了，需要变大
            if(D < day)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};
```

<a id="1482"></a>

### [1482. 制作 m 束花所需的最少天数](#TopicSummary)

```C++{.line-numbers}
class Solution {
public:
    int minDays(vector<int>& bloomDay, int m, int k) {
        if(m * k > bloomDay.size()) return -1;

        int left = 1, right = *max_element(bloomDay.begin(), bloomDay.end());
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            int numMake = 0, numBloom = 0;
            for(int x: bloomDay)
            {
                numBloom = x <= mid? numBloom + 1: 0;
                // 注意是连续
                if(numBloom == k)
                {
                    ++numMake;
                    numBloom = 0;
                }
            }

            // 如果当前的时间可以做0多花，说明等待的时间少了
            if(numMake < m)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};
```

<a id=""></a>

### [59-II. 螺旋矩阵II](#TopicSummary)

```C++{.line-numbers}

```
