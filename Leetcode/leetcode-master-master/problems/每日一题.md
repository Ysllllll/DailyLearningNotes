<a id="top"></a>
[toc]

<a id="27"></a>

### [27. 移除元素](#top)

```C++{.line-numbers}
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right)
        {
            if(nums[left] == val)
            {
                swap(nums[left], nums[right]);
                right--;
            }
            else
            {
                left++;
            }
        }
        return right + 1;
    }
};
```

<a id="1011"></a>

### [1011. 在 D 天内送达包裹的能力](#top)

```C++{.line-numbers}
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int D) {
        // 确定二分查找左右边界
        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right) {
            int mid = (left + right) / 2;
            // need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            int need = 1, cur = 0;
            for (int weight: weights) {
                if (cur + weight > mid) {
                    ++need;
                    cur = 0;
                }
                cur += weight;
            }
            if (need <= D) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

<a id="875"></a>

### [875. 爱吃香蕉的珂珂](#top)

```C++{.line-numbers}
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int right = *max_element(piles.begin(), piles.end());
        int left = 1;

        while(left < right)
        {
            int mid = left + (right - left) / 2;

            int need = 0;
            for(int pile: piles)
            {
                if(pile % mid > 0)
                    need++;
                need += pile / mid;
            }

            if(need <= h)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

<a id="1011"></a>

### [1011. 在 D 天内送达包裹的能力](#top)

```C++{.line-numbers}
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int D) {
        // 确定二分查找左右边界
        int left = *max_element(weights.begin(), weights.end()), right = accumulate(weights.begin(), weights.end(), 0);
        while (left < right) {
            int mid = (left + right) / 2;
            // need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            int need = 1, cur = 0;
            for (int weight: weights) {
                if (cur + weight > mid) {
                    ++need;
                    cur = 0;
                }
                cur += weight;
            }
            if (need <= D) {
                right = mid;
            }
            else {
                left = mid + 1;
            }
        }
        return left;
    }
};
```

<a id="633"></a>

### [633. 平方数之和](#top)

```C++{.line-numbers}
class Solution {
public:
    bool judgeSquareSum(int c) {
        long low = 0;
        long high = sqrt(c);
        while(low <= high)
        {
            long sum = low * low + high * high;
            if(sum == c)
                return true;
            else if(sum < c)
                low++;
            else
                high--;
        }
        return false;
    }
};
```

<a id="136"></a>

### [136. 只出现一次的数字](#top)

```C++{.line-numbers}
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int e: nums) res ^= e;
        return res;
    }
};
```

<a id="137"></a>

### [137. 只出现一次的数字 II](#top)

```C++{.line-numbers}
// 状态机思想
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones = 0, twos = 0;
        for(int num: nums)
        {
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
        }
        return ones;
    }
};

// 位运算
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (int i = 0; i < 32; i++) { // 因为nums[i]是32位整数，
        // 所以针对每一位的对应二进制数值求和
            int sum = 0;
            for (int num : nums) {
                sum += ((num >> i) & 1); // 提取从右往左数第i位的数值，将所有nums[i]
                // 二进制下的第i位数值进行求和
            }
            if (sum % 3 == 1) { // 如果没办法被3整除，那么说明落单的那个数的第i位是1不是0
                res |= (1 << i);
            }
        }
        return res; // 输出结果
    }
};
```

<a id="260"></a>

### [260. 只出现一次的数字 III](#top)

```C++{.line-numbers}
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int x = 0, y = 0, n = 0, m = 1;
        for(int num : nums)         // 1. 遍历异或
            n ^= num;
        while((n & m) == 0)         // 2. 循环左移，计算 m
            m <<= 1;
        for(int num : nums) {       // 3. 遍历 nums 分组
            if(num & m) x ^= num;   // 4. 当 num & m != 0
            else y ^= num;          // 4. 当 num & m == 0
        }
        return vector<int> {x, y};  // 5. 返回出现一次的数字
    }
};
```

<a id="690"></a>

### [690. 员工的重要性](#top)

```C++{.line-numbers}
class Solution {
public:
    int getImportance(vector<Employee*> employees, int id) {
        int idFind = 0;
        for(; idFind < employees.size(); idFind++)
        {
            if(employees[idFind]->id == id)
                break;
        }
        if(idFind == employees.size())
            return 0;

        
        if(employees[idFind]->subordinates.size() == 0) return employees[idFind]->importance;
        
        int res = employees[idFind]->importance;
        for(int i = 0; i < employees[idFind]->subordinates.size(); i++)
        {
            res += getImportance(employees, employees[idFind]->subordinates[i]);
        }

        return res;
    }
};
```
