<p align='center'>
<img src="https://img-blog.csdnimg.cn/20201215214102642.png" width=400 >

# 二叉树的理论基础

- [关于二叉树，你该了解这些！](https://mp.weixin.qq.com/s/_ymfWYvTNd2GvWvC5HOE4A)：二叉树的种类、存储方式、遍历方式、定义方式

# 二叉树的遍历方式

- 深度优先遍历
  - [二叉树：前中后序递归法](https://mp.weixin.qq.com/s/PwVIfxDlT3kRgMASWAMGhA)：递归三部曲初次亮相 <font color= 'red'>2021/02/20</font>
  - [二叉树：前中后序迭代法（一）](https://mp.weixin.qq.com/s/c_zCrGHIVlBjUH_hJtghCg)：通过栈模拟递归 <font color= 'red'>2021/02/20</font>
  - [二叉树：前中后序迭代法（二）](https://mp.weixin.qq.com/s/WKg0Ty1_3SZkztpHubZPRg)：统一风格 <font color= 'red'>2021/02/20</font>
- 广度优先遍历
  - [二叉树的层序遍历](https://mp.weixin.qq.com/s/Gb3BjakIKGNpup2jYtTzog)：通过队列模拟 <font color= 'red'>2021/02/20</font>

<a id="traversal"></a>

> **题目汇总**
>
> - 深度优先遍历
>   - **[Leetcode 144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)** [速览题解](#144)
>   - **[Leetcode 145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)** [速览题解](#145)
>   - **[Leetcode 94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)** [速览题解](#94)
>     简评：[Morris 迭代](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/cqian-zhong-hou-xu-bian-li-de-san-chong-fang-fa-di/)
>   - **[Leetcode 589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)** [速览题解](#589)
>   - **[Leetcode 590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)** [速览题解](#590)
> - 广度优先遍历
>   - **[Leetcode 102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)** [速览题解](#102)
>   - **[Leetcode 107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)** [速览题解](#107)
>     简评：这道题就是 102 结果的倒序，但是不知道这种做法是否合适，在面试的时候可能会要求不能用 reverse。这道题的另外一个思路就是递归，还没有看这种解法
>   - **[Leetcode 199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)** [速览题解](#199)
>   - **[Leetcode 637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)** [速览题解](#637)
>   - **[Leetcode 429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)** [速览题解](#429)
>   - **[剑指 Offer 32-I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)** [速览题解](#32-1)
>   - **[剑指 Offer 32-II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)** [速览题解](#32-2)
>   - **[剑指 Offer 32-III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)** [速览题解](#32-3)

# 求二叉树的属性

- [二叉树：是否对称](https://mp.weixin.qq.com/s/Kgf0gjvlDlNDfKIH2b1Oxg) <font color= 'red'>2021/02/20</font>
  - 递归：后序，比较的是根节点的左子树与右子树是不是相互翻转
  - 迭代：使用队列/栈将两个节点顺序放入容器中进行比较
- [二叉树：求最大深度](https://mp.weixin.qq.com/s/guKwV-gSNbA1CcbvkMtHBg) <font color= 'red'>2021/02/20</font>
  - 递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值作计算树的高度
    - 自上而下：前序遍历
    - 自下而上：后序遍历
  - 迭代：层序遍历
- [二叉树：求最小深度](https://mp.weixin.qq.com/s/BH8-gPC3_QlqICDg7rGSGA) <font color= 'red'>2021/02/20</font>
  - 递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义
    - 自上而下：前序遍历
    - 自下而上：后序遍历
  - 迭代：层序遍历
- [二叉树：求有多少个节点](https://mp.weixin.qq.com/s/2_eAjzw-D0va9y4RJgSmXw) <font color= 'red'>2021/02/20</font>
  - 递归：后序，通过递归函数的返回值计算节点数量
  - 迭代：层序遍历
- [二叉树：是否平衡](https://mp.weixin.qq.com/s/isUS-0HDYknmC0Rr4R8mww) <font color= 'red'>2021/02/20</font>
  - 递归：后序，注意后序求高度和前序求深度，递归过程判断高度差
    - 自顶向下：前序遍历，效率很差，因为有很多重复的计算
    - 自底向上：后序遍历，效率好
  - 迭代：效率很低，不推荐
- [二叉树：找所有路径](https://mp.weixin.qq.com/s/Osw4LQD2xVUnCJ-9jrYxJA) <font color= 'red'>2021/02/21</font>
  - 递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径
  - 迭代：一个栈模拟递归，一个栈来存放对应的遍历路径
- [二叉树：递归中如何隐藏着回溯](https://mp.weixin.qq.com/s/ivLkHzWdhjQQD1rQWe6zWA)
  - 详解[二叉树：找所有路径](https://mp.weixin.qq.com/s/Osw4LQD2xVUnCJ-9jrYxJA)中递归如何隐藏着回溯
- [二叉树：求路径总和](https://mp.weixin.qq.com/s/6TWAVjxQ34kVqROWgcRFOg)
  - 递归：顺序无所谓，递归函数返回值为 bool 类型是为了搜索一条边，没有返回值是搜索整棵树。
  - 迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和
- [二叉树：求左叶子之和](https://mp.weixin.qq.com/s/gBAgmmFielojU5Wx3wqFTA) <font color= 'red'>2021/02/21</font>
  - 递归：后序，必须三层约束条件，才能判断是否是左叶子，这道题前序中序后序层序遍历都可以：这道题的关键点在于在遍历的过程中如何识别出左叶子，至于怎么遍历不是重点。所以如果有了清晰的左叶子定义，然后再用任意遍历方式遍历整棵树的过程中将这些左叶子加起来即可。
  - 迭代：直接模拟后序遍历
- [二叉树：求左下角的值](https://mp.weixin.qq.com/s/MH2gbLvzQ91jHPKqiub0Nw) <font color= 'red'>2021/02/21</font>
  - 递归：前序自顶向下，优先左孩子搜索，同时找深度最大的叶子节点。链接中的递归写法中关于层次的问题，在遍历的时候 leftLen 是 0，但是按照逻辑应该是 1，毕竟根结点所在深度为 1。但是这里其实是 0 是 1 无所谓，它始终是相对的
  - 迭代：层序遍历找最后一行最左边

<a id="attribute"></a>

> **题目汇总**
>
> - 二叉树：是否对称
>   - **[Leetcode 101.对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)** [速览题解](#101)
>   - **[剑指 offer 28.对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)** [速览题解](#101)
> - 二叉树：求最大深度
>   - **[Leetcode 104.二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)** [速览题解](#104)
>   - **[剑指 Offer 55-I.二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)** [速览题解](#104)
>   - **[Leetcode 559.N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)** [速览题解](#559)
>     简评：求深度是前序遍历，求高度是后序遍历。深度还可以用层序遍历来求
> - 二叉树：求最小深度
>   - **[Leetcode 111.二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)** [速览题解](#111)
> - 二叉树：求有多少个节点
>   - **[Leetcode 222.完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)** [速览题解](#222)
> - 二叉树：是否平衡
>   - **[Leetcode 110.平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)** [速览题解](#110)
>   - **[剑指 Offer 55-II.平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)** [速览题解](#110)
>     简评：求高度用后序遍历，高度不能再用层序遍历来求。迭代法较为复杂，可以不管
> - 二叉树：找所有路径
>   - **[Leetcode 257.二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)** [速览题解](#257)
>     简评：先序遍历。另外注意在函数定义的时候，是用的`string s`，而不能用`string &s`，每次都是复制赋值，不能使用引用，否则就无法做到回溯的效果
> - 二叉树：求路径总和
>   - **[Leetcode 112.路径总和](https://leetcode-cn.com/problems/path-sum/)** [速览题解](#112)
>   - **[Leetcode 113.路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)** [速览题解](#113)
>   - **[剑指 Offer 34.二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)** [速览题解](#113)
>   - **[Leetcode 129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)** [速览题解](#129)
>   - **[Leetcode 124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)** [速览题解](#124)
>   - **[Leetcode 543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)** [速览题解](#543)
> - 二叉树：求左叶子之和
>   - **[Leetcode 404.左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)** [速览题解](#404)
> - 二叉树：求左下角的值
>   - **[Leetcode 513.找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value//)** [速览题解](#513)

# 二叉树的修改与构造

- [翻转二叉树](https://mp.weixin.qq.com/s/6gY1MiXrnm-khAAJiIb5Bg) <font color= 'red'>2021/02/22</font>
  - 递归：前序，交换左右孩子
  - 迭代：直接模拟前序遍历
- [构造二叉树](https://mp.weixin.qq.com/s/7r66ap2s-shvVvlZxo59xg) <font color= 'red'>2021/02/22</font>
  - 递归：前序，重点在于找分割点，分左右区间构造，区间左闭右开
  - 迭代：比较复杂，意义不大，后续再看
- [构造最大的二叉树](https://mp.weixin.qq.com/s/1iWJV6Aov23A7xCF4nV88w) <font color= 'red'>2021/02/22</font>
  - 递归：前序，分割点为数组最大值，分左右区间构造,区间左闭右开
  - 迭代：比较复杂，意义不大，后续再看
- [合并两个二叉树](https://mp.weixin.qq.com/s/3f5fbjOFaOX_4MXzZ97LsQ) <font color= 'red'>2021/02/22</font>
  - 递归：前序，同时操作两个树的节点，注意合并的规则
  - 迭代：使用队列，类似层序遍历，后续再看

<a id="modify"></a>

> **题目汇总**
>
> - 翻转二叉树
>   - **[Leetcode 226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)** [速览题解](#226)
>   - **[剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/comments/)** [速览题解](#226)
> - 构造二叉树
>   - **[Leetcode 105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/dong-hua-yan-shi-105-cong-qian-xu-yu-zhong-xu-bian/)** [速览题解](#105)
>   - **[Leetcode 106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/)** [速览题解](#106)
>   - **[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)** [速览题解](#105)
> - 构造最大的二叉树
>   - **[Leetcode 654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/solution/)** [速览题解](#654)
>   - 收获：一般情况来说：如果让空节点（空指针）进入递归，就不加 if，如果不让空节点进入递归，就加 if 限制一下， 终止条件也会相应的调整
> - 合并两个二叉树
>   - **[Leetcode 617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/)** [速览题解](#617)

# 求二叉搜索树的属性

- [二叉搜索树中的搜索](https://mp.weixin.qq.com/s/vsKrWRlETxCVsiRr8v_hHg) <font color= 'red'>2021/02/22</font>
  - 递归：二叉搜索树的递归是有方向的
  - 迭代：因为有方向，所以迭代法很简单
- [是不是二叉搜索树](https://mp.weixin.qq.com/s/8odY9iUX5eSi0eRFSXFD4Q) <font color= 'red'>2021/02/22</font>
  - 递归：中序，相当于变成了判断一个序列是不是递增的
  - 迭代：模拟中序，逻辑相同
- [求二叉搜索树的最小绝对差](https://mp.weixin.qq.com/s/Hwzml6698uP3qQCC1ctUQQ) <font color= 'red'>2021/02/22</font>
  - 递归：中序，双指针操作
  - 迭代：模拟中序，逻辑相同
- [求二叉搜索树的众数](https://mp.weixin.qq.com/s/KSAr6OVQIMC-uZ8MEAnGHg) <font color= 'red'>2021/02/22</font>
  - 递归：中序，清空结果集的技巧，遍历一遍便可求众数集合
  - 迭代：模拟中序，逻辑相同
- [二叉搜索树转成累加树](https://mp.weixin.qq.com/s/hZtJh4T5lIGBarY-lZJf6Q) <font color= 'red'>2021/02/22</font>
  - 递归：中序，双指针操作累加
  - 迭代：模拟中序，逻辑相同

<a id="binarySearchTreeProperties"></a>

> **题目汇总**
>
> - 二叉搜索树中的搜索
>   - **[Leetcode 700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/submissions/)** [速览题解](#700)
> - 是不是二叉搜索树
>   - **[Leetcode 98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/)** [速览题解](#98)
> - 求二叉搜索树的最小绝对差
>   - **[Leetcode 530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/submissions/)** [速览题解](#530)
> - 求二叉搜索树的众数
>   - **[Leetcode 501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/submissions/)** [速览题解](#501)
> - 二叉搜索树转成累加树
>   - **[Leetcode 538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/submissions/)** [速览题解](#538)
> - 附加题
>   - **[Leetcode 1373. 二叉搜索子树的最大键值和](https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/)** [速览题解](#1373)
>   - **[Leetcode 653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)** [速览题解](#653)
>   - **[Leetcode 230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)** [速览题解](#230)
>   - **[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)** [速览题解](#54)
>   - **[Leetcode 1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)** [速览题解](#1305)

# 二叉搜索树的修改与构造

- [二叉搜索树中的插入操作](https://mp.weixin.qq.com/s/lwKkLQcfbCNX2W-5SOeZEA) <font color= 'red'>2021/02/23</font>
  - 递归：顺序无所谓，通过递归函数返回值添加节点
  - 迭代：按序遍历，需要记录插入父节点，这样才能做插入操作
- [二叉搜索树中的删除操作](https://mp.weixin.qq.com/s/-p-Txvch1FFk3ygKLjPAKw) <font color= 'red'>2021/02/23</font>
  - 递归：前序，想清楚删除非叶子节点的情况
  - 迭代：有序遍历，较复杂，待看
- [修剪二叉搜索树](https://mp.weixin.qq.com/s/QzmGfYUMUWGkbRj7-ozHoQ) <font color= 'red'>2021/02/23</font>
  - 递归：前序，通过递归函数返回值删除节点
  - 迭代：有序遍历，较复杂，待看
- [构造二叉搜索树](https://mp.weixin.qq.com/s/sy3ygnouaZVJs8lhFgl9mw) <font color= 'red'>2021/02/23</font>
  - 递归：前序，数组中间节点分割
  - 迭代：较复杂，通过三个队列来模拟，待看

<a id="binarySearchTreeModify"></a>

> **题目汇总**
>
> - 二叉搜索树中的插入操作
>   - **[Leetcode 701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/)** [速览题解](#701)
> - 二叉搜索树中的删除操作
>   - **[Leetcode 450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/)** [速览题解](#450)
> - 修剪二叉搜索树
>   - **[Leetcode 669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/submissions/)** [速览题解](#669)
>   - **[Leetcode 938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)** [速览题解](#938)
> - 构造二叉搜索树
>   - **[Leetcode 108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/submissions/)** [速览题解](#108)
>   - **[Leetcode 109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)** [速览题解](#109)
> - 附加
>   - **[897. 递增顺序搜索树](https://leetcode-cn.com/problems/increasing-order-search-tree/)** [速览题解](#897)
>   - **[173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)** [速览题解](#173)

# 二叉树公共祖先问题

- [二叉树的公共祖先问题](https://mp.weixin.qq.com/s/n6Rk3nc_X3TSkhXHrVmBTQ) <font color= 'red'>2021/02/23</font>
  - 递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。自底向上
  - 迭代：不适合模拟回溯
- [二叉搜索树的公共祖先问题](https://mp.weixin.qq.com/s/Ja9dVw2QhBcg_vV-1fkiCg) <font color= 'red'>2021/02/23</font>
  - 递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先，自上而下
  - 迭代：按序遍历

> **题目汇总**
>
> - 二叉树的公共祖先问题
>   - **[Leetcode 236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/)** [速览题解](#236)
>   - **[剑指 Offer 68 - II. 二叉树的最近公共祖先（迭代版）](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)** [速览题解](#236)
> - 二叉搜索树的公共祖先问题
>   - **[Leetcode 235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)** [速览题解](#235)
>   - **[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)** [速览题解](#235)

# 阶段总结

大家以上题目都做过了，也一定要看如下阶段小结。

**每周小结都会对大家的疑问做统一解答，并且对每周的内容进行拓展和补充，所以一定要看，将细碎知识点一网打尽！**

- [本周小结！（二叉树系列一）](https://mp.weixin.qq.com/s/JWmTeC7aKbBfGx4TY6uwuQ)
- [本周小结！（二叉树系列二）](https://mp.weixin.qq.com/s/QMBUTYnoaNfsVHlUADEzKg)
- [本周小结！（二叉树系列三）](https://mp.weixin.qq.com/s/JLLpx3a_8jurXcz6ovgxtg)
- [本周小结！（二叉树系列四）](https://mp.weixin.qq.com/s/CbdtOTP0N-HIP7DR203tSg)

# 最后总结

**在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl 给大家大体分分类**。

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。

- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。

- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序， [二叉树：找所有路径](https://mp.weixin.qq.com/s/Osw4LQD2xVUnCJ-9jrYxJA)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

**最后，二叉树系列就这么完美结束了，估计这应该是最长的系列了，感谢大家 33 天的坚持与陪伴，接下来我们又要开始新的系列了「回溯算法」！**

---

<a id="144"></a>

### [144. 二叉树的前序遍历](#traversal)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<int> res;
    void preorderTraversalHelper(TreeNode *root)
    {
        if(root == nullptr) return;

        res.push_back(root->val);
        if(root->left != nullptr) preorderTraversal(root->left);
        if(root->right != nullptr) preorderTraversal(root->right);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        preorderTraversalHelper(root);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty())
        {
            root = s.top();
            s.pop();
            res.push_back(root->val);
            if(root->right) s.push(root->right);
            if(root->left) s.push(root->left);
        }
        return res;
    }
};

// 迭代的统一写法
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;
        s.push(root);

        while(!s.empty())
        {
            root = s.top();
            if(root != nullptr)
            {
                s.pop();
                if(root->right) s.push(root->right);
                if(root->left) s.push(root->left);
                s.push(root);
                s.push(nullptr);
            }
            else
            {
                s.pop();
                root = s.top();
                s.pop();
                res.push_back(root->val);
            }
        }

        return res;
    }
};

// Morris迭代
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> results;
        TreeNode* cur = root,*mostRight=NULL;
        while(cur){
            if(cur->left ==NULL){
                results.push_back(cur->val);
                cur = cur->right;
            }else{
                mostRight = cur->left;
                while(mostRight->right&&mostRight->right!=cur){
                    mostRight=mostRight->right;
                }
                if(mostRight->right==NULL){
                    results.push_back(cur->val);
                    mostRight->right = cur;
                    cur = cur->left;
                }else{

                    mostRight->right = NULL;
                    cur = cur->right;
                }
            }
        }
        return results;
    }
};
```

<a id="94"></a>

### [94. 二叉树的中序遍历](#traversal)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<int> res;
    void inorderTraversalHelper(TreeNode* root)
    {
        if(root == nullptr) return;

        if(root->left != nullptr) inorderTraversalHelper(root->left);
        res.push_back(root->val);
        if(root->right != nullptr) inorderTraversalHelper(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        inorderTraversalHelper(root);
        return res;
    }
};

// 迭代1
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;

        while(root != nullptr || !s.empty())
        {
            while(root)
            {
                s.push(root);
                root = root->left;
            }
            root = s.top();
            s.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};

// 迭代2
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (cur != NULL || !s.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                s.push(cur); // 讲访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = s.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                s.pop();
                res.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return res;
    }
};

// 迭代的统一写法
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        stack<TreeNode*> s;
        s.push(root);

        while(!s.empty()){
            root = s.top();
            if(root != nullptr)
            {
                s.pop();
                if(root->right) s.push(root->right);
                s.push(root);
                s.push(nullptr);
                if(root->left) s.push(root->left);
            }
            else
            {
                s.pop();
                root = s.top();s.pop();
                res.push_back(root->val);
            }
        }

        return res;
    }
};

// Morris遍历
class Solution{
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> results;
        TreeNode* cur = root,*mostRight=NULL;
        while(cur){
            if(cur->left ==NULL){
                results.push_back(cur->val);
                cur = cur->right;
            }else{
                mostRight = cur->left;
                while(mostRight->right&&mostRight->right!=cur){
                    mostRight=mostRight->right;
                }
                if(mostRight->right==NULL){
                    mostRight->right = cur;
                    cur = cur->left;
                }else{
                    results.push_back(cur->val);
                    mostRight->right = NULL;
                    cur = cur->right;
                }
            }
        }
        return results;
    }
};
```

<a id="145"></a>

### [145. 二叉树的后序遍历](#traversal)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<int> res;
    void preorderTraversalHelper(TreeNode *root)
    {
        if(root == nullptr) return;

        if(root->left != nullptr) preorderTraversal(root->left);
        if(root->right != nullptr) preorderTraversal(root->right);
        res.push_back(root->val);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        preorderTraversalHelper(root);
        return res;
    }
};

// 迭代
class Solution {
public:

    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            if (node != NULL) result.push_back(node->val);
            else continue;
            st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序
            st.push(node->right);
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};

//迭代的统一写法
class Solution {
public:

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;

        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty())
        {
            root = s.top();
            if(root != nullptr)
            {
                s.pop();
                s.push(root);
                s.push(nullptr);
                if(root->right) s.push(root->right);
                if(root->left) s.push(root->left);
            }
            else
            {
                s.pop();
                root = s.top();
                s.pop();
                res.push_back(root->val);
            }
        }
        return res;
    }
};

// Morris遍历

```

<a id="589"></a>

### [589. N 叉树的前序遍历](#traversal)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<int> res;
    void preorderHelper(Node *root)
    {
        if(root == nullptr) return;
        res.push_back(root->val);
        int numChild = root->children.size();
        for(int i = 0; i < numChild; i++)
        {
            preorderHelper(root->children[i]);
        }
    }
    vector<int> preorder(Node* root) {
        if(root == nullptr) return {};
        preorderHelper(root);

        return res;
    }
};

// 迭代
class Solution {
public:
    vector<int> preorder(Node* root) {
        if(root == nullptr) return {};
        vector<int> res;
        stack<Node*> s;
        s.push(root);

        while(!s.empty())
        {
            root = s.top();
            s.pop();
            res.push_back(root->val);
            int numChild = root->children.size();
            for(int i = numChild - 1; i >= 0; i--)
            {
                s.push(root->children[i]);
            }
        }

        return res;
    }
};

// 迭代的统一写法
class Solution {
public:
    vector<int> res;
    vector<int> preorder(Node* root) {
        if(root == nullptr) return {};
        stack<Node*> s;
        s.push(root);

        while(!s.empty())
        {
            root = s.top();
            if(root != nullptr)
            {
                s.pop();
                int numChild = root->children.size();
                for(int i = numChild - 1; i >= 0; i--)
                {
                    s.push(root->children[i]);
                }
                s.push(root);
                s.push(nullptr);
            }
            else
            {
                s.pop();
                root = s.top();
                s.pop();
                res.push_back(root->val);
            }
        }

        return res;
    }
};
```

<a id="590"></a>

### [590. N 叉树的后序遍历](#traversal)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<int> res;
    void postorderHelper(Node *root)
    {
        if(root == nullptr) return;
        int numChlid = root->children.size();
        for(int i = 0; i < numChlid; i++)
        {
            postorderHelper(root->children[i]);
        }
        res.push_back(root->val);
    }
    vector<int> postorder(Node* root) {
        if(root == nullptr) return {};

        postorderHelper(root);
        return res;
    }
};
// 迭代
class Solution {
public:
    vector<int> res;
    vector<int> postorder(Node* root) {
        if(root == nullptr) return {};
        stack<Node*> s;
        s.push(root);

        while(!s.empty())
        {
            root = s.top();
            if(root != nullptr)
            {
                s.pop();
                s.push(root);
                s.push(nullptr);
                int numChild = root->children.size();
                for(int i = numChild - 1; i >= 0; i--)
                {
                    s.push(root->children[i]);
                }
            }
            else
            {
                s.pop();
                root = s.top();
                s.pop();
                res.push_back(root->val);
            }
        }
        return res;
    }
};
```

<a id="102"></a>

### [102. 二叉树的层序遍历](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == nullptr) return {};
        vector<vector<int>> res;

        queue<TreeNode*> s;
        s.push(root);
        while(!s.empty())
        {
            vector<int>temp;
            int num = s.size();
            for(int i = 0; i < num; i++)
            {
                root = s.front();
                s.pop();
                if(root->left != nullptr) s.push(root->left);
                if(root->right != nullptr) s.push(root->right);
                temp.push_back(root->val);
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

<a id="107"></a>

### [107. 二叉树的层序遍历 II](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        if(root == nullptr) return {};
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty())
        {
            vector<int> temp;
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                temp.push_back(root->val);
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            res.push_back(temp);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

<a id="199"></a>

### [199. 二叉树的右视图](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if(root == nullptr) return {};
        vector<int> res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                if(i == num - 1) res.push_back(root->val);
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
        }

        return res;
    }
};
```

<a id="637"></a>

### [637. 二叉树的层平均值](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        if(root == nullptr) return {};
        vector<double> res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            double total = 0.0;
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                total += root->val;
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            res.push_back(total / num);
        }

        return res;
    }
};
```

<a id="429"></a>

### [429. N 叉树的层序遍历](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        queue<Node*> q;
        q.push(root);

        while(!q.empty())
        {
            vector<int> temp;
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                temp.push_back(root->val);
                for(int j = 0; j < root->children.size(); j++)
                {
                    q.push(root->children[j]);
                }
            }
            res.push_back(temp);
        }

        return res;
    }
};
```

<a id="32-1"></a>

### [32 - I. 从上到下打印二叉树](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> res;
        if(root == nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                res.push_back(root->val);
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
        }
        return res;
    }
};
```

<a id="32-2"></a>

### [32 - II. 从上到下打印二叉树 II](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            vector<int> temp;
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                temp.push_back(root->val);
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            res.push_back(temp);
        }

        return res;
    }
};
```

<a id="32-3"></a>

### [32 - III. 从上到下打印二叉树 III](#traversal)

```C++{.line-numbers}
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root == nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        bool flag = false;
        while(!q.empty())
        {
            int num = q.size();
            vector<int> temp(num, 0);
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                if(!flag) temp[i] = root->val;
                else temp[num - i - 1] = root->val;
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            flag = !flag;
            res.push_back(temp);
        }
        return res;
    }
};
```

<a id="101"></a>

### [101. 对称二叉树](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    bool isSymmetric(TreeNode* left, TreeNode* right)
    {
        if(left == nullptr && right == nullptr) return true;
        if(left == nullptr && right != nullptr) return false;
        if(left != nullptr && right == nullptr) return false;
        if(left->val != right->val) return false;

        bool bLeft = isSymmetric(left->left, right->right);
        bool bRight = isSymmetric(left->right, right->left);
        return bLeft && bRight;
    }
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;

        return isSymmetric(root->left, root->right);
    }
};

// 使用栈的迭代
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;

        stack<TreeNode*> s;
        s.push(root->left);
        s.push(root->right);
        TreeNode* s1 = nullptr;
        TreeNode* s2 = nullptr;

        while(!s.empty())
        {
            s1 = s.top(); s.pop();
            s2 = s.top(); s.pop();
            if(s1 == nullptr && s2 == nullptr) continue;
            if(s1 == nullptr && s2 != nullptr) return false;
            if(s1 != nullptr && s2 == nullptr) return false;
            if(s1->val != s2->val) return false;

            s.push(s1->left);
            s.push(s2->right);
            s.push(s1->right);
            s.push(s2->left);
        }
        return true;
    }
};

// 使用队列的迭代
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        while (!que.empty()) {  // 接下来就要判断这这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```

<a id="104"></a>

### [104. 二叉树的最大深度](#attribute)

```C++{.line-numbers}
// 后序递归
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;

        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return max(left, right) + 1;
    }
};

// 前序递归
class Solution {
public:
    int result;
    void getDepth(TreeNode* node, int depth) {
        result = depth > result ? depth : result; // 中
        if (node->left == NULL && node->right == NULL) return ;
        if (node->left) { // 左
            getDepth(node->left, depth + 1);
        }
        if (node->right) { // 右
            getDepth(node->right, depth + 1);
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == 0) return result;
        getDepth(root, 1);
        return result;
    }
};

// 层序遍历
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 0;
        if(root == nullptr) return 0;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            res++;
        }

        return res;
    }
};
```

<a id="559"></a>

### [559. N 叉树的最大深度](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr) return 0;
        int depth = 0;
        for(int i = 0; i < root->children.size(); i++)
        {
            depth = max(depth, maxDepth(root->children[i]));
        }
        return depth + 1;
    }
};

// 迭代
class Solution {
public:
    int maxDepth(Node* root) {
        if(root == nullptr) return 0;
        int depth = 0;

        queue<Node*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                for(int i = 0; i < root->children.size(); i++)
                {
                    q.push(root->children[i]);
                }
            }
            depth++;
        }

        return depth;
    }
};
```

<a id="111"></a>

### [111. 二叉树的最小深度](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        if(root->left == nullptr && root->right == nullptr) return 1;
        if(root->left == nullptr) return minDepth(root->right) + 1;
        if(root->right == nullptr) return minDepth(root->left) + 1;
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
};

// 层序遍历迭代
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> q;
        int depth = 1;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                if(root->left == nullptr && root->right == nullptr) return depth;
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
            depth++;
        }
        return depth;
    }
};
```

<a id="222"></a>

### [222. 完全二叉树的节点个数](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int left = countNodes(root->left);
        int right = countNodes(root->right);
        return left + right + 1;
    }
};

// 层序遍历迭代
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int depth = 0;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();
                depth++;
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
        }
        return depth;
    }
};
```

<a id="110"></a>

### [110. 平衡二叉树](#attribute)

```C++{.line-numbers}
class Solution {
public:
    int isBalancedHelper(TreeNode* root)
    {
        if(root == nullptr) return 0;
        //if(root->left == nullptr && root->right == nullptr) return 1;

        int left = isBalancedHelper(root->left);
        if(left == -1) return -1;
        int right = isBalancedHelper(root->right);
        if(right == -1) return -1;
        return abs(left - right) > 1? -1: (max(left, right) + 1);

    }
    bool isBalanced(TreeNode* root) {
        return isBalancedHelper(root) != -1;
    }
};
```

<a id="257"></a>

### [257. 二叉树的所有路径](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<string> res;
    void getPath(TreeNode* root, string s)
    {
        s += to_string(root->val);
        if(root->left == nullptr && root->right == nullptr)
        {
            res.push_back(s);
            return ;
        }
        if(root->left) getPath(root->left, s + "->");
        if(root->right) getPath(root->right, s + "->");
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        if(root == nullptr) return {};
        string s = "";
        getPath(root, s);
        return res;
    }
};

// 迭代
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        if(root == nullptr) return {};
        vector<string> res;
        stack<TreeNode*> st;
        stack<string> ss;
        st.push(root);
        ss.push(to_string(root->val));
        while(!ss.empty())
        {
            root = st.top(); st.pop();
            string path = ss.top(); ss.pop();

            if(root->left == nullptr && root->right == nullptr)
            {
                res.push_back(path);
            }

            if(root->left)
            {
                st.push(root->left);
                ss.push(path + "->" + to_string(root->left->val));
            }
            if(root->right)
            {
                st.push(root->right);
                ss.push(path + "->" + to_string(root->right->val));
            }
        }
        return res;
    }
};
```

<a id="112"></a>

### [112. 路径总和](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;

        if(root != nullptr && root->val == targetSum && root->left == nullptr && root->right == nullptr)
        {
            return true;
        }

        bool left = false;
        if(root->left) left = hasPathSum(root->left, targetSum - root->val);
        bool right = false;
        if(root->right) right = hasPathSum(root->right, targetSum - root->val);

        return left || right;
    }
};

// 缩减版递归
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;

        if(root->left == nullptr && root->right == nullptr && root->val == targetSum)
        {
            return true;
        }

        bool left = hasPathSum(root->left, targetSum - root->val);
        bool right = hasPathSum(root->right, targetSum - root->val);

        return left || right;
    }
};

// 迭代
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;

        stack<pair<TreeNode* , int>> s;
        s.push(pair<TreeNode*, int>(root, targetSum));
        while(!s.empty())
        {
            pair<TreeNode*, int> node = s.top();
            s.pop();
            if(node.first->left == nullptr && node.first->right == nullptr && node.first->val == node.second)
            {
                return true;
            }

            if(node.first->left)
            {
                s.push(pair<TreeNode*, int>(node.first->left, node.second - node.first->val));
            }
            if(node.first->right)
            {
                s.push(pair<TreeNode*, int>(node.first->right, node.second - node.first->val));
            }
        }
        return false;
    }
};
```

<a id="113"></a>

### [113. 路径总和 II](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void getPath(TreeNode* root, int targetSum)
    {
        if(root == nullptr) return;
        if(root->left == nullptr && root->right == nullptr && root->val == targetSum)
        {
            path.push_back(root->val);
            res.push_back(path);
            path.pop_back();
            return;
        }

        if(root->left)
        {
            path.push_back(root->val);
            getPath(root->left, targetSum - root->val);
            path.pop_back();
        }
        if(root->right)
        {
            path.push_back(root->val);
            getPath(root->right, targetSum - root->val);
            path.pop_back();
        }
    }
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        getPath(root, targetSum);
        return res;
    }
};
```

<a id="129"></a>

### [129. 求根节点到叶节点数字之和](#attribute)

```C++{.line-numbers}
class Solution {
public:
    vector<string> res;
    void backTracking(TreeNode* root, vector<string> &vec, string path)
    {
        if(root == nullptr) return;
        if(root->left == nullptr && root->right == nullptr)
        {
            vec.push_back(path + (char)(root->val + '0'));
            return;
        }
        if(root->left != nullptr)
            backTracking(root->left, vec, path + (char)(root->val + '0'));
        if(root->right != nullptr)
            backTracking(root->right, vec, path + (char)(root->val + '0'));
    }
    int sumNumbers(TreeNode* root) {
        if(root == nullptr) return 0;
        vector<string> vec;
        string path;
        backTracking(root, vec, path);

        int res = 0;
        for(string s: vec)
            res += stoi(s);
        return res;
    }
};

// 精简版
class Solution {
public:
    int sumNumbersHelper(TreeNode* root, int sum) {
        if(root == nullptr) return 0;
        if(root->left == nullptr && root->right == nullptr)
            return sum * 10 + root->val;
        int left = sumNumbersHelper(root->left, sum * 10 + root->val);
        int right = sumNumbersHelper(root->right, sum * 10 + root->val);
        return left + right;
    }
    int sumNumbers(TreeNode* root) {
        if(root == nullptr) return 0;
        return sumNumbersHelper(root, 0);
    }
};
```

<a id="124"></a>

### [124. 二叉树中的最大路径和](#attribute)

```C++{.line-numbers}
class Solution {
public:
    int maxPathSumHelper(TreeNode *root, int &val)
    {
        if(root == nullptr) return 0;
        int left = maxPathSumHelper(root->left, val);
        int right = maxPathSumHelper(root->right, val);
        int lmr = root->val + max(0, left) + max(0, right);
        int ret = root->val + max(0, max(left, right));
        val = max(val, max(lmr, ret));
        return ret;
    }
    int maxPathSum(TreeNode* root) {
        int val = INT_MIN;
        maxPathSumHelper(root, val);
        return val;
    }
};
```

<a id="404"></a>

### [404. 左叶子之和](#attribute)

```C++{.line-numbers}
class Solution {
public:
    int diameterOfBinaryTreeHelper(TreeNode* root, int &val) {
        if(root == nullptr) return 0;
        if(root->left == nullptr && root->right == nullptr) return 1;

        int left = diameterOfBinaryTreeHelper(root->left, val);
        int right = diameterOfBinaryTreeHelper(root->right, val);
        int lmr = 1 + left + right;
        int ret = 1 + max(left, right);
        val = max(val, max(lmr, ret));

        return ret;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        if(root == nullptr) return 0;
        int val = 1;
        diameterOfBinaryTreeHelper(root, val);
        return val - 1;
    }
};
```

<a id="404"></a>

### [404. 左叶子之和](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;

        int left = sumOfLeftLeaves(root->left);
        int right = sumOfLeftLeaves(root->right);

        if(root->left != nullptr && root->left->left == nullptr && root->left->right == nullptr)
            return root->left->val + left + right;
        else
            return left + right;
    }
};
```

<a id="513"></a>

### [513. 找树左下角的值](#attribute)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int maxDepth = INT_MIN;
    int leftValue;

    void helper(TreeNode *root, int depth)
    {
        if(root->left == nullptr && root->right == nullptr)
        {
            if(depth > maxDepth)
            {
                maxDepth = depth;
                leftValue = root->val;
            }
            return;
        }

        if(root->left) helper(root->left, depth + 1);
        if(root->right) helper(root->right, depth + 1);
    }
    int findBottomLeftValue(TreeNode* root) {
        if(root == nullptr) return 0;
        helper(root, 2);
        return leftValue;
    }
};

// 迭代
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 0;
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();q.pop();
                if(i == 0) res = root->val;
                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
        }
        return res;
    }
};
```

<a id="226"></a>

### [226. 翻转二叉树](#modify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;

        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        if(root->left) invertTree(root->left);
        if(root->right) invertTree(root->right);
        return root;
    }
};

// 迭代
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;
        TreeNode* res = root;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int num = q.size();
            for(int i = 0; i < num; i++)
            {
                root = q.front();
                q.pop();

                TreeNode* temp = root->left;
                root->left = root->right;
                root->right = temp;

                if(root->left) q.push(root->left);
                if(root->right) q.push(root->right);
            }
        }
        return res;
    }
};
```

<a id="105"></a>

### [105. 从前序与中序遍历序列构造二叉树](#modify)

```C++{.line-numbers}
class Solution {
public:
    TreeNode* buildTreeHelper(vector<int> &preorder, int pleft, int pright, vector<int>& inorder, int ileft, int iright)
    {
        if(pleft > pright)
            return nullptr;

        TreeNode* root = new TreeNode(preorder[pleft]);
        int i = ileft;
        while(i <= iright)
        {
            if(inorder[i] == root->val)
                break;
            i++;
        }

        root->left = buildTreeHelper(preorder, pleft + 1, pleft + i - ileft, inorder, ileft, i - 1);
        root->right = buildTreeHelper(preorder, pleft + i - ileft + 1, pright, inorder, i + 1, iright);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTreeHelper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
    }
};
```

<a id="106"></a>

### [106. 从中序与后序遍历序列构造二叉树](#modify)

```C++{.line-numbers}
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, int ileft, int iright, vector<int>& postorder, int pleft, int pright)
    {
        if(ileft > iright)
        {
            return nullptr;
        }

        TreeNode* root = new TreeNode(postorder[pright]);
        int i = ileft;
        while(i <= iright)
        {
            if(inorder[i] == root->val)
                break;
            i++;
        }

        root->left = buildTree(inorder, ileft, i - 1, postorder, pleft, pleft + i - ileft - 1);
        root->right = buildTree(inorder, i + 1, iright, postorder, pleft + i - ileft, pright - 1);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1);
    }
};
```

<a id="654"></a>

### [654. 最大二叉树](#modify)

```C++{.line-numbers}
class Solution {
public:
    TreeNode* constructMaximumBinaryTreeHelper(vector<int>& nums, int left, int right)
    {
        if(left > right) return nullptr;

        int maxIndex = left;
        for(int i = left; i <= right; i++)
        {
            if(nums[maxIndex] < nums[i])
            {
                maxIndex = i;
            }
        }

        TreeNode* root = new TreeNode(nums[maxIndex]);
        root->left = constructMaximumBinaryTreeHelper(nums, left, maxIndex - 1);
        root->right = constructMaximumBinaryTreeHelper(nums, maxIndex + 1, right);
        return root;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.size() == 0) return nullptr;
        return constructMaximumBinaryTreeHelper(nums, 0, nums.size() - 1);
    }
};
```

<a id="617"></a>

### [617. 合并二叉树](#modify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr) return root2;
        if(root2 == nullptr) return root1;

        root1->val = root1->val + root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};

// 迭代
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // 此时两个节点一定不为空，val相加
            node1->val += node2->val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```

<a id="700"></a>

### [700. 二叉搜索树中的搜索](#binarySearchTreeProperties)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr) return nullptr;

        if(root->val == val)
            return root;
        else if(root->val < val)
            return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
    }
};

// 迭代
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while(root != nullptr)
        {
            if(root->val == val)
                return root;
            else if(root->val < val)
                root = root->right;
            else
                root = root->left;
        }
        return root;
    }
};
```

<a id="98"></a>

### [98. 验证二叉搜索树](#binarySearchTreeProperties)

```C++{.line-numbers}
// 递归
class Solution {
public:
    bool isValidBSTHelper(TreeNode* root, TreeNode* &prev)
    {
        if(root == nullptr) return true;

        bool left = isValidBSTHelper(root->left, prev);
        if(prev != nullptr && prev->val >= root->val)
            return false;
        prev = root;
        bool right = isValidBSTHelper(root->right, prev);

        return left && right;
    }
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        TreeNode* prev = nullptr;
        return isValidBSTHelper(root, prev);
    }
};

// 递归简洁版
class Solution {
public:
    TreeNode* pre = NULL; // 用来记录前一个节点
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);

        if (pre != NULL && pre->val >= root->val) return false;
        pre = root; // 记录前一个节点

        bool right = isValidBST(root->right);
        return left && right;
    }
};

// 迭代
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        stack<TreeNode*> s;
        TreeNode *prev = nullptr, *cur = root;
        while(cur != nullptr || !s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->left;
            }
            root = s.top();
            s.pop();

            if(prev != nullptr && prev->val >= root->val)
                return false;
            prev = root;
            cur = root->right;
        }
        return true;
    }
};
```

<a id="530"></a>

### [530. 二叉搜索树的最小绝对差](#binarySearchTreeProperties)

```C++{.line-numbers}
// 递归
class Solution {
public:
    void getMinimumDifferenceHelper(TreeNode* root, TreeNode* &prev, int& minValue)
    {
        if(root == nullptr) return;

        getMinimumDifferenceHelper(root->left, prev, minValue);
        if(prev != nullptr && root->val - prev->val < minValue)
        {
            minValue = root->val - prev->val;
        }
        prev = root;

        getMinimumDifferenceHelper(root->right, prev, minValue);
    }
    int getMinimumDifference(TreeNode* root) {
        TreeNode* prev = NULL;
        int minValue = INT_MAX;
        getMinimumDifferenceHelper(root, prev, minValue);
        return minValue;
    }
};

// 迭代
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        if(root == nullptr) return 0;
        stack<TreeNode*> s;
        TreeNode *prev = nullptr, *cur = root;
        int minValue = INT_MAX;
        while(cur != nullptr || !s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->left;
            }
            root = s.top();
            s.pop();
            if(prev != nullptr && root->val - prev->val < minValue)
            {
                minValue = root->val - prev->val;
            }
            prev = root;
            cur = root->right;
        }
        return minValue;
    }
};
```

<a id="538"></a>

### [538. 把二叉搜索树转换为累加树](#binarySearchTreeProperties)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* prev = nullptr;
    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr) return root;

        root->right = convertBST(root->right);

        if(prev != nullptr)
        {
            root->val += prev->val;
        }
        prev = root;

        root->left = convertBST(root->left);
        return root;
    }
};

// 迭代
class Solution {
public:

    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr) return root;
        TreeNode* prev = nullptr, *cur = root, *newRoot = root;
        stack<TreeNode*> s;

        while(cur != nullptr || !s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->right;
            }
            root = s.top();
            s.pop();
            if(prev != nullptr)
            {
                root->val += prev->val;
            }
            prev = root;
            cur = root->left;
        }
        return newRoot;
    }
};
```

<a id="1373"></a>

### [1373. 二叉搜索子树的最大键值和](#binarySearchTreeProperties)

```C++{.line-numbers}
class Solution {
public:
    int maxSum = 0;
    vector<int> maxSumBSTHelper(TreeNode* root)
    {
        if(root == nullptr)
            return {true, INT_MAX, INT_MIN, 0};

        vector<int> leftValue = maxSumBSTHelper(root->left);
        vector<int> rightValue = maxSumBSTHelper(root->right);

        if(leftValue[0] == false || rightValue[0] == false || root->val >= rightValue[1] || root->val <= leftValue[2])
            return {false, 0, 0, max(leftValue[3], rightValue[3])};

        int curMin = root->left ? leftValue[1]: root->val;
        int curMax = root->right ? rightValue[2]: root->val;
        int sum = root->val + leftValue[3] + rightValue[3];
        maxSum = max(maxSum, sum);
        return {true, curMin, curMax, sum};
    }
    int maxSumBST(TreeNode* root) {
        vector<int> res = maxSumBSTHelper(root);
        return maxSum;
    }
};
```

<a id="653"></a>

### [653. 两数之和 IV - 输入 BST](#binarySearchTreeProperties)

```C++{.line-numbers}
class Solution {
public:
    bool findTwoNum (TreeNode* cur , int &k, stack<int> &arr)
    {
        if (!cur) return false;
        bool left = findTwoNum(cur->left, k, arr);
        if (2 * cur->val < k) arr.push(cur->val);
        else
        {
            while(!arr.empty() && arr.top() + cur->val > k) arr.pop();
            if (!arr.empty() && arr.top() + cur->val == k) return true;
        }
        bool right = findTwoNum(cur->right, k, arr);
        return left || right;
    }
    bool findTarget(TreeNode* root, int k) {
        stack<int> arr;
        return findTwoNum(root, k, arr);
    }
};
```

<a id="230"></a>

### [230. 二叉搜索树中第K小的元素](#binarySearchTreeProperties)

```C++{.line-numbers}
class Solution {
public:
    void kthSmallestHelper(TreeNode *root, int &k, int &ret)
    {
        if(root == nullptr) return;

        if(root->left != nullptr && ret == 0) kthSmallestHelper(root->left, k, ret);
        k--;
        if(k == 0)
        {
            ret = root->val;
            return;
        }
        if(root->right != nullptr && ret == 0) kthSmallestHelper(root->right, k, ret);
    }
    int kthSmallest(TreeNode* root, int k) {
        int ret = 0;
        kthSmallestHelper(root, k, ret);
        return ret;
    }
};
```

<a id="54"></a>

### [54. 二叉搜索树的第k大节点](#binarySearchTreeModify)

```C++{.line-numbers}
class Solution {
public:
    void kthLargestHelper(TreeNode *root, int &k, int &ret)
    {
        if(root == nullptr) return;

        if(root->right != nullptr && ret == 0) kthLargestHelper(root->right, k, ret);
        k--;
        if(k == 0)
        {
            ret = root->val;
            return;
        }
        if(root->left != nullptr && ret == 0) kthLargestHelper(root->left, k, ret);
    }
    int kthLargest(TreeNode* root, int k) {
        int ret = 0;
        kthLargestHelper(root, k, ret);
        return ret;
    }
};
```

<a id="701"></a>

### [701. 二叉搜索树中的插入操作](#binarySearchTreeModify)

```C++{.line-numbers}
// 复杂版本
class Solution {
public:
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
        stack<TreeNode*> s1;
        stack<TreeNode*> s2;
        vector<int> res;
        TreeNode* cur1 = root1;
        TreeNode* cur2 = root2;
        while(cur1 != nullptr || cur2 != nullptr || s1.empty() != true || s2.empty() != true)
        {
            while(cur1)
            {
                s1.push(cur1);
                cur1 = cur1->left;
            }
            while(cur2)
            {
                s2.push(cur2);
                cur2 = cur2->left;
            }
            if(s1.empty() != true && s2.empty() != true)
            {
                cur1 = s1.top();
                cur2 = s2.top();
                if(cur1->val < cur2->val)
                {
                    res.push_back(cur1->val);
                    s1.pop();
                    cur1 = cur1->right;
                    cur2 = nullptr;
                }
                else
                {
                    res.push_back(cur2->val);
                    s2.pop();
                    cur2 = cur2->right;
                    cur1 = nullptr;
                }
            }
            else if(s1.empty() != true)
            {
                cur1 = s1.top();
                res.push_back(cur1->val);
                s1.pop();
                cur1 = cur1->right;
                cur2 = nullptr;
            }
            else
            {
                cur2 = s2.top();
                res.push_back(cur2->val);
                s2.pop();
                cur2 = cur2->right;
                cur1 = nullptr;
            }
        }

        return res;
    }
};

// 简化版
class Solution {
public:
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
        stack<TreeNode*> s1;
        stack<TreeNode*> s2;
        vector<int> res;
        TreeNode* cur1 = root1;
        TreeNode* cur2 = root2;
        while(cur1 != nullptr || cur2 != nullptr || s1.empty() != true || s2.empty() != true)
        {
            while(cur1)
            {
                s1.push(cur1);
                cur1 = cur1->left;
            }
            while(cur2)
            {
                s2.push(cur2);
                cur2 = cur2->left;
            }
            
            if(s1.empty() != true) cur1 = s1.top();
            if(s2.empty() != true) cur2 = s2.top();

            // 注意，在循环里 cur1 和 cur2 中最多只有一个为空
            // 首先，while 中 nullptr 不会入栈
            // 其次，在 1 的情况下，cur1 和 cur2 都为 nullptr 时不会进入该循环
            if(cur2 == nullptr || cur1 != nullptr && cur1->val < cur2->val)
            {
                res.push_back(cur1->val);
                s1.pop();
                // 这里 cur1 虽然可能令为 nullptr
                // 但是下一次一定会被赋值一个 cur = s.top()
                // 因为若两个栈都为空，会直接退出循环
                cur1 = cur1->right;
                cur2 = nullptr;
            }
            else
            {
                res.push_back(cur2->val);
                s2.pop();
                cur2 = cur2->right;
                cur1 = nullptr;
            }
        }

        return res;
    }
};
```

<a id="701"></a>

### [701. 二叉搜索树中的插入操作](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr)
        {
            root = new TreeNode(val);
            return root;
        }

        if(root->val < val)
            root->right = insertIntoBST(root->right, val);
        else
            root->left = insertIntoBST(root->left, val);

        return root;
    }
};

// 迭代
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr)
        {
            root = new TreeNode(val);
            return root;
        }

        TreeNode *newRoot = root;
        while(root)
        {
            if(root->val > val)
            {
                if(root->left == nullptr)
                {
                    root->left = new TreeNode(val);
                    return newRoot;
                }
                root = root->left;
            }
            else
            {
                if(root->right == nullptr)
                {
                    root->right = new TreeNode(val);
                    return newRoot;
                }
                root = root->right;
            }
        }

        return newRoot;
    }
};
```

<a id="450"></a>

### [450. 删除二叉搜索树中的节点](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return root;

        if(root->val == key)
        {
            if(root->left == nullptr) return root->right;
            else if(root->right == nullptr) return root->left;
            else
            {
                TreeNode* cur = root->right;
                while(cur->left != nullptr)
                    cur = cur->left;
                cur->left = root->left;
                TreeNode* tmp = root;
                root = root->right;
                delete tmp;
                return root;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left, key);
        if(root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};

// 另一种递归，区别在于将等于key的节点值与顺序上的下一个节点值进行交换，反复交换后，
// 最后key值节点会变为左右子树必有一个为空，或者两个均为空的简单情况。
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        if (root->val == key) {
            if (root->right == nullptr) { // 这里第二次操作目标值：最终删除的作用
                return root->left;
            }
            TreeNode *cur = root->right;
            while (cur->left) {
                cur = cur->left;
            }
            swap(root->val, cur->val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。
        }
        // 注意没有(root->val < key) 和 (root->val > key)
        root->left = deleteNode(root->left, key);
        root->right = deleteNode(root->right, key);
        return root;
    }
};

// 迭代
class Solution {
public:
    TreeNode* deleteOneNode(TreeNode* root)
    {
        if(root == nullptr) return root;
        if(root->right == nullptr) return root->left;
        TreeNode* cur = root->right;
        while(cur->left)
            cur = cur->left;
        cur->left = root->left;
        return root->right;

    }

    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;

        TreeNode* cur = root, *pre = nullptr;
        while(cur)
        {
            if(cur->val == key) break;
            pre = cur;
            if(cur->val > key) cur = cur->left;
            else cur = cur->right;
        }

        if(pre == nullptr) return deleteOneNode(cur);
        if(pre->left && pre->left->val == key) pre->left = deleteOneNode(cur);
        if(pre->right && pre->right->val == key) pre->right = deleteOneNode(cur);

        return root;
    }
};
```

<a id="669"></a>

### [669. 修剪二叉搜索树](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == nullptr) return root;
        if(root->val < low) return trimBST(root->right, low, high);
        if(root->val > high) return trimBST(root->left, low, high);
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};

// 迭代
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == nullptr) return nullptr;

        while((root != nullptr) && ((root->val < low) || (root->val > high)))
        {
            if(root->val < low) root = root->right;
            else root = root->left;
        }

        TreeNode *cur = root;
        while(cur != nullptr)
        {
            while(cur->left && cur->left->val < low)
                cur->left = cur->left->right;
            cur = cur->left;
        }

        cur = root;
        while(cur != nullptr)
        {
            while(cur->right && cur->right->val > high)
                cur->right = cur->right->left;
            cur = cur->right;
        }
        return root;
    }
};
```

<a id="938"></a>

### [938. 二叉搜索树的范围和](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root == nullptr) return 0;

        if(root->val < low)
            return rangeSumBST(root->right, low, high);

        if(root->val > high)
            return rangeSumBST(root->left, low, high);

        int left = rangeSumBST(root->left, low, high);
        int right = rangeSumBST(root->right, low, high);
        return root->val + left + right;
    }
};

// 迭代：中序遍历
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root == nullptr) return 0;
        int ans = 0;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while(cur != nullptr || !s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->left;
            }
            root = s.top();
            s.pop();
            if(root->val > high)
                return ans;
            if(root->val >= low && root->val <= high)
                ans += root->val;

            cur = root->right;
        }


        return ans;
    }
};

// 迭代：层序遍历
class Solution {
public:
    int rangeSumBST(TreeNode *root, int low, int high) {
        int sum = 0;
        queue<TreeNode*> q({root});
        while (!q.empty()) {
            auto node = q.front();
            q.pop();
            if (node == nullptr) {
                continue;
            }
            if (node->val > high) {
                q.push(node->left);
            } else if (node->val < low) {
                q.push(node->right);
            } else {
                sum += node->val;
                q.push(node->left);
                q.push(node->right);
            }
        }
        return sum;
    }
};
```

<a id="108"></a>

### [108. 将有序数组转换为二叉搜索树](#binarySearchTreeModify)

```C++{.line-numbers}
class Solution {
public:
    TreeNode* sortedArrayToBSTHelper(vector<int>& nums, int left, int right)
    {
        if(left > right) return nullptr;

        int mid = left + (right - left) / 2;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = sortedArrayToBSTHelper(nums, left, mid - 1);
        root->right = sortedArrayToBSTHelper(nums, mid + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return sortedArrayToBSTHelper(nums, 0, nums.size() - 1);
    }
};
```

<a id="109"></a>

### [109. 有序链表转换二叉搜索树](#binarySearchTreeModify)

```C++{.line-numbers}
// 先转换为数组再做
class Solution {
public:
    TreeNode* sortedArrayToBSTHelper(vector<int>& nums, int left, int right)
    {
        if(left > right) return nullptr;

        int mid = left + (right - left) / 2;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = sortedArrayToBSTHelper(nums, left, mid - 1);
        root->right = sortedArrayToBSTHelper(nums, mid + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(ListNode* head) {
        vector<int> nums;
        while(head != nullptr)
        {
            nums.push_back(head->val);
            head = head->next;
        }
        return sortedArrayToBSTHelper(nums, 0, nums.size() - 1);
    }
};

// 用快慢指针找到链表的中位节点
class Solution {
public:
    ListNode* getMid(ListNode* left, ListNode* right)
    {
        ListNode* slow = left, *fast = left;
        while(fast != right && fast->next != right)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    TreeNode* buildTree(ListNode* left, ListNode* right)
    {
        if(left == right) return nullptr;
        ListNode* mid = getMid(left, right);
        TreeNode* root = new TreeNode(mid->val);
        root->left = buildTree(left, mid);
        root->right = buildTree(mid->next, right);
        return root;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        return buildTree(head, nullptr);
    }
};

// 在中序遍历的过程中先构造节点，到访问节点的 "值" 时再赋值
class Solution {
public:
    TreeNode* buildTree(ListNode*& head, int left, int right) {
        if (left > right) {
            return nullptr;
        }
        int mid = left + (right - left) / 2;
        TreeNode* root = new TreeNode();
        root->left = buildTree(head, left, mid - 1);

        // 中序遍历，开始访问节点值的时候才开始赋值
        root->val = head->val;
        head = head->next;
        root->right = buildTree(head, mid + 1, right);
        return root;
    }

    TreeNode* sortedListToBST(ListNode* head) {
        int length = 0;
        ListNode* cur = head;
        for(; cur != nullptr; ++length, cur = cur->next);
        return buildTree(head, 0, length - 1);
    }
};
```

<a id="897"></a>

### [897. 递增顺序搜索树](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归
class Solution {
public:
    void increasingBSTHelper(TreeNode* root, TreeNode* &pre, TreeNode* &newHeader)
    {
        if(root == nullptr) return;
        increasingBSTHelper(root->left, pre, newHeader);

        if(pre == nullptr)
        {
            newHeader = root;
        }
        if(pre != nullptr)
        {
            pre->right = root;
        }
        root->left = nullptr;
        pre = root;
        increasingBSTHelper(root->right, pre, newHeader);
    }
    TreeNode* increasingBST(TreeNode* root) {
        TreeNode* pre = nullptr;
        TreeNode* newHeader = nullptr;
        increasingBSTHelper(root, pre, newHeader);
        return newHeader;
    }
};

// 迭代
class Solution {
public:
    TreeNode* increasingBST(TreeNode* root) {
        if(root == nullptr) return nullptr;
        TreeNode* pre = nullptr, *cur = root;
        TreeNode* res = nullptr;
        stack<TreeNode*> s;
        while(cur != nullptr || !s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->left;
            }
            root = s.top();
            s.pop();
            if(res == nullptr)
                res = root;
            if(pre != nullptr)
                pre->right = root;
            root->left = nullptr;
            pre = root;
            cur = root->right;
        }

        return res;
    }
};
```

<a id="173"></a>

### [173. 二叉搜索树迭代器](#binarySearchTreeModify)

```C++{.line-numbers}
class BSTIterator {
public:
    stack<TreeNode *> s;
    BSTIterator(TreeNode* root) {
        if(root == nullptr) return;
        while(root)
        {
            s.push(root);
            root = root->left;
        }
    }

    int next() {
        TreeNode *root = s.top();
        s.pop();
        int ret = root->val;

        root = root->right;
        while(root)
        {
            s.push(root);
            root = root->left;
        }
        return ret;
    }

    bool hasNext() {
        return s.size() > 0;
    }
};
```

<a id="236"></a>

### [236. 二叉树的最近公共祖先](#binarySearchTreeModify)

```C++{.line-numbers}
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return root;
        if(root->val == p->val) return p;
        else if(root->val == q->val) return q;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if(left != nullptr && right != nullptr)
            return root;
        else if(left == nullptr)
            return right;
        else
            return left;
    }
};
```

<a id="235"></a>

### [235. 二叉搜索树的最近公共祖先](#binarySearchTreeModify)

```C++{.line-numbers}
// 递归版
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;
        if(root != nullptr && p->val < root->val && q->val < root->val)
            return lowestCommonAncestor(root->left, p, q);
        else if(root != nullptr && p->val > root->val && q->val > root->val)
            return lowestCommonAncestor(root->right, p, q);
        else
            return root;
    }
};

// 迭代版
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr) return nullptr;

        while(true)
        {
            if(root != nullptr && p->val < root->val && q->val < root->val)
                root = root->left;
            else if(root != nullptr && p->val > root->val && q->val > root->val)
                root = root->right;
            else
                break;
        }
        return root;
    }
};
```
