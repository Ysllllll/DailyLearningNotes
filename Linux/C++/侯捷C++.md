## 基于对象编程

- 琐碎前述
  - c++文件布局：头文件`(.h)` + 实现文件`(.cc)`
  - 头文件布局：前置声明、类声明、类定义
  - 核心内容是：**类成员函数设计**
  - 可参考：《Effective C++》、标准库实现

- class without pointer member（complex实现）
  - 构造函数
    - 实现为 `public` 成员
      - 可重载多个构造函数：`new classtype[n]` 创建一个对象数组，要求 `classtype` 必须有默认构造函数，此时无法给定每个对象初值。`const` 也是重载关键字，`static`不是
      - 默认实参：从右至左
      - 初始列：调用类成员对象的**构造函数**
      - 函数体：调用类成员对象的**拷贝构造函数**和**拷贝赋值函数**
      - 构造函数必须初始化所有类成员对象
    - 实现为 `private` 成员
      - `singleton` 设计模式
      - 无法构造栈对象：`classtype tmp;`报错
      - 可以构造堆对象：`classtype *tmp = classtype::create();`。`create()` 为类中 `static` 函数，函数主体 `{return new classtype;}`
  - 成员函数
    - `const` 成员函数：保证不会改变**对象的数据**，普通成员函数则会改变数据
    - `const` 参数
      - 传入 `pass`：保证在函数体内不会改变**该参数**
      - 传出 `return`：保证在函数体外不会改变**该参数**
    - 参数传递
      - `pass by value (to const)`：非内置类型会调用拷贝构造函数
      - `pass by reference (to const)`：多态时需要注意对象切割问题
      - `return by value (to const)`：非内置类型会调用拷贝构造函数
      - `return by reference (to const)`：不能 `return` 一个局部变量的引用。`return` 的可以是一个指针所指对象
    - `friend`：可直接访问 `private`数据成员
      - 对象之间的互为 `friend`：一个对象的成员函数可以直接访问另一个对象的私有数据成员
      - 具体参考 `complex` 实现
    - 隐含的第一个参数为 `this` 指针，指代当前对象
  - `static` 成员函数
    - 无 `this` 指针，使用范围为**当前类域**
    - 不可操作普通成员变量，只能操作 **`static`成员变量**。考虑类域在最开始时没有一个对象存在，`static` 函数自然不能操作这些不存在的东西。`static` 成员仅仅表明可见域，不表明访问权限
  - 函数重载
    - 操作符重载 为成员函数：有 `this` 指针
    - 操作符重载 为非成员函数：无 `this` 指针

- class with pointer member（String实现）
  - `big three`
    - 拷贝构造函数：自我验证，深拷贝
    - 拷贝赋值函数：自我验证，深拷贝
    - 析构函数：一定要有，用于 `delete pointer` 指向的对象，有继承体系时一定要写为虚析构函数
  - 小记：注意 `this` 指代的是什么，拷贝赋值和拷贝构造函数里面的自我验证 `if(this == &s) return`

- `object` 的生命周期
  - **栈对象**：离开作用域时 **自动** 调用析构函数
  - **`static local` 对象**：整个程序结束时 **自动** 调用析构函数
  - **`global` 对象**：离开作用域时（是整个程序） **自动** 调用析构函数
  - **堆对象**：调用 `delete` 时 **主动** 调用析构函数（指向堆对象的指针为栈对象）
  - 常量对象：只能调用**常量成员函数**
  - 非常量对象：可以调用常量成员函数，也可以调用非常量成员函数
  - 临时对象

- `new` 与 `delete`
  - `new` 分解

    ```C++
    complex *pc = new complex(1, 2);
    //分解
    void *mem = operator new(sizeof(complex));//分配内存
    pc = static_cast<complex*>(mem);//转型
    pc->complex::complex(1, 2);//构造函数
    ```
  
  - `delete` 分解

    ```C++
    delete pc;
    //分解
    complex::~complex(pc);//析构函数
    operator delete(pc);//释放内存
    ```

  - `new` 和 `delete` 是关键字，不是运算符，编译器会将这个关键字修饰的语句分解为三个执行语句。`new` 和 `delete` 操作的对象都堆对象
    - 堆对象和栈对象的构造函数的调用都由编译器产生，并自动调用。具体点，堆对象会在**堆中开辟一个空间**，然后在这个空间上创建对象。而栈对象只需要**移动程序栈的栈顶指针，以预留出能够容纳对象的空间**，然后在这个空间上创建对象
    - 堆对象和栈对象的析构函数的调用存在区别，堆对象需要**主动调用**，如果不调用堆对象会一直存在。而栈对象会**自动调用**，因为**栈回滚**，会在离开这个作用域（程序**自动**移动栈顶指针）的时候清除这个作用域所占用内存的内容
  - `array new` 和 `array delete`
    - 若类含有指针数据成员，同时没有搭配使用，会造成内存泄露。这里的内存泄露在**第二级的 `new`**（第一级 `new` 为用户调用：`string *p = new string[3]`，第二级 `new` 为构造函数内部调用：`char *m_str = new char[strlen(str)+1]`;）

- 进一步补充
  - static：仅仅表明可见域，不表明访问权限，或者你可以这样考虑，共享范围
  - 模板
    - 缺点：会造成代码膨胀
    - 类模板：需要**显式指定模板参数**，`vector<int> a;`
    - 函数模板：不需要显式指定模板参数，编译器会自动推导，`reverse(a.begin(), a.end());`
  - `namespace`

## 面向对象编程

- 复合（`has-a`）
  - 数据成员中有**非基本类型**
  - 构造与析构顺序：由编译器来做
    - 构造由内而外
    - 析构由外而内
  - 设计模式：`Adapter`
- 委托
  - 数据成员中有**非基本类型指针**
  - 构造与析构顺序
  - 设计模式：`Handle/Body`
- 继承（`is-a`）
  - 类继承
    - 继承的数据成员：占用内存
    - 继承的函数成员：继承的是调用权，而不能从内存的角度去考虑
    - 继承的核心问题是子类是否可以重新定义继承来的函数。
    - `non-virtual`：不希望 `derived class` 重新定义它
    - `virtual`：希望 `derived class` 重新定义它，且已经有默认定义
    - `pure virtual`：希望 `derived class` 一定要重新定义它，且没有默认定义
  - 构造与析构顺序：
    - 构造由内而外
    - 析构由外而内
  - 设计模式：`Template method` （与虚函数搭配）
- 复合 + 继承
  - 构造与析构顺序
  - 设计模式：无
- 委托 + 继承
  - 构造与析构顺序
  - 设计模式：`Observer、Composite、Prototype`
