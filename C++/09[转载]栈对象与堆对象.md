#### 转载自

- [C++ 栈对象 堆对象 理解](https://blog.csdn.net/sdnu111111111/article/details/38707923)

- [汇编学习与gdb调试-疑惑与解答与日志](https://blog.csdn.net/wjh2622075127/article/details/88363569)

#### 1. 建立类对象的两种方式

在C++中，类的对象建立分为两种，一种是静态建立，如 `A a;`，另一种是动态建立，如 `A* ptr=new A;`这两种方式是有区别的。

- 静态建立类对象：是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。

- 动态建立类对象，是使用 `new` 运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行 `operator new()` 函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

初始化两种方法：

- 第一种初始化方法：`Object object(初始化参数);`
- 第二种初始化方法：`Object object=new Object();`

两种初始化方法的区别：

- 第一种初始化方法：在 `Stack` 栈里面分配空间，自动释放。
- 第二种初始化方法：在 `heap` 堆里面分配空间，要手动释放。

#### 2. 建立两种对象的汇编指令

接下来我们看看编译器生成的可执行文件中，生成这两个对象的指令。下面的代码段会产生一个栈对象和堆对象。

```C++{.line-numbers}
class Object
{
public:
    Object(int t) : i(t) {}
    ~Object() {}

private:
    int i;
};

int main()
{
    Object object(16);
    Object *object_p = new Object(32);
    delete object_p;
    return 0;
}
```

针对这段源代码，我们使用objdump查看编译器输出的结果：

```bash
[/mnt/shared/testt]
moocos-> g++ test.cpp -g -o test
[/mnt/shared/testt]
moocos-> objdump -dS test
```

```bash
int main()
{
  40084d:   55                      push   %rbp
  40084e:   48 89 e5                mov    %rsp,%rbp
  400851:   53                      push   %rbx
  400852:   48 83 ec 18             sub    $0x18,%rsp
    Object object(16);
  400856:   48 8d 45 e0             lea    -0x20(%rbp),%rax #在栈空间里为对象分配空间
  40085a:   be 10 00 00 00          mov    $0x10,%esi #Object(16)：构造函数的参数为16
  40085f:   48 89 c7                mov    %rax,%rdi #将对象地址存储在rdi中
  400862:   e8 bf 00 00 00          callq  400926 <_ZN6ObjectC1Ei>#调用构造函数
    Object *object_p = new Object(32);
  400867:   bf 04 00 00 00          mov    $0x4,%edi #operator new参数：分配$0x4个字节空间
  40086c:   e8 cf fe ff ff          callq  400740 <_Znwm@plt>#调用operator new()：在堆空间里为对象分配空间
  400871:   48 89 c3                mov    %rax,%rbx #operator new()返回：分配空间的首地址
  400874:   be 20 00 00 00          mov    $0x20,%esi #Object(32)：构造函数的参数为32
  400879:   48 89 df                mov    %rbx,%rdi #将对象地址存储在rdi中
  40087c:   e8 a5 00 00 00          callq  400926 <_ZN6ObjectC1Ei>#在这个空间上调用构造函数
  400881:   48 89 5d e8             mov    %rbx,-0x18(%rbp)
    delete object_p;
  400885:   48 8b 5d e8             mov    -0x18(%rbp),%rbx
  400889:   48 85 db                test   %rbx,%rbx
  40088c:   74 10                   je     40089e <main+0x51>
  40088e:   48 89 df                mov    %rbx,%rdi
  400891:   e8 a6 00 00 00          callq  40093c <_ZN6ObjectD1Ev> #调用析构函数
  400896:   48 89 df                mov    %rbx,%rdi
  400899:   e8 42 fe ff ff          callq  4006e0 <_ZdlPv@plt> #调用operator delete()函数
    return 0;
  40089e:   bb 00 00 00 00          mov    $0x0,%ebx
  4008a3:   48 8d 45 e0             lea    -0x20(%rbp),%rax
  4008a7:   48 89 c7                mov    %rax,%rdi
  4008aa:   e8 8d 00 00 00          callq  40093c <_ZN6ObjectD1Ev>
  4008af:   89 d8                   mov    %ebx,%eax
  4008b1:   eb 1a                   jmp    4008cd <main+0x80>
  4008b3:   48 89 c3                mov    %rax,%rbx
  4008b6:   48 8d 45 e0             lea    -0x20(%rbp),%rax
  4008ba:   48 89 c7                mov    %rax,%rdi
  4008bd:   e8 7a 00 00 00          callq  40093c <_ZN6ObjectD1Ev> #为何有两个析构函数调用？？？不懂
  4008c2:   48 89 d8                mov    %rbx,%rax
  4008c5:   48 89 c7                mov    %rax,%rdi
  4008c8:   e8 83 fe ff ff          callq  400750 <_Unwind_Resume@plt>
}
```

可以看见在面对静态对象的生成的时候，通过指令修改栈顶指针，然后在该区域调用构造函数即可初始化对象。而在面对动态对象的生成的时候，需要先调用另外一个函数来获取空间，然后在该空间中调用构造函数来初始化对象。

#### 3. 栈对象与堆对象归纳

什么时候该用 `Object  object;`，什么时候该用 `Object  *object = new  Object();`，结合上面的 `bash` 输出归纳栈对象与堆对象。

##### **栈对象**

栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用 `operator new` 操作，`operator new` 会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。

##### **堆对象**

其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。

#### 4. 限制建立类对象的方式

那么如何限制类对象只能在堆或者栈上建立呢？下面分别进行讨论。

##### a、只能在堆上分配类对象

此时不允许静态建立类对象，即不能直接调用类的构造函数，容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，也就是说在上面的汇编代码中，原来可以调用构造函数的地方将无法调用，因为那个区域是类外区域。

此时就只能使用 `new` 运算符来建立对象。然而，前面已经说过，`new` 运算符的执行过程分为两步，C++提供 `new` 运算符的重载，其实是只允许重载 `operator new()` 函数，而 `operatornew()` 函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。代码如下：

```c++{.line-numbers}
class A
{
public:
    A(){}
    void destory(){delete this;}
private:
    ~A(){}
};
```

试着使用 `A a;` 来建立对象，编译报错，提示析构函数无法访问。这样就只能使用 `new` 操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个 `destory` 函数，来进行内存空间的释放。类对象使用完成后，必须调用 `destory` 函数。

上述方法的缺点：

- 无法解决继承问题。如果 `A` 作为其它类的基类，则析构函数通常要设为 `virtual`，然后在子类重写，以实现多态。因此析构函数不能设为 `private`。还好C++提供了第三种访问控制：`protected`。将析构函数设为 `protected` 可以有效解决这个问题，类外无法访问 `protected` 成员，子类则可以访问。

- 类的使用很不方便，使用 `new` 建立对象，却使用 `destory` 函数释放对象，而不是使用 `delete`。（使用 `delete` 会报错，因为 `delete` 对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为 `protected`，然后提供一个 `public` 的 `static` 函数来完成构造，这样不使用 `new`，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于单例模式：

```c++{.line-numbers}
class A
{
protected:
    A(){}
    ~A(){}
public:
    static A* create()
    {
        return new A();
    }
    void destory()
    {
        delete this;
    }
};
```

这样，调用 `create()` 函数在堆上创建类 `A` 对象，调用 `destory()` 函数释放内存。

##### b、只能在栈上分配类对象

只有使用 `new` 运算符，对象才会建立在堆上，因此，只要禁用 `new` 运算符就可以实现类对象只能建立在栈上。虽然你不能影响 `new operator` 的能力（因为那是C++语言内建的），但是你可以利用一个事实：`new operator` 总是先调用 `operator new`，而后者我们是可以自行声明重写的。因此，将 `operator new()` 设为私有即可禁止对象被 `new` 在堆上。代码如下：

```C++{.line-numbers}
class A
{
private:
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void* ptr){} // 重载了new就需要重载delete
public:
    A(){}
    ~A(){}
};
```
