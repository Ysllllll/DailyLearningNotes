> 条款1：视C++为一个语言联邦
> - C++高效编程守则视状况而变化，取决于你使用C++的哪一部分

> 条款2：尽量以 const，enum，inline 替换 #define
>
> - 对于单纯常量，最好以 const 对象或 enums 替换 #define。
> - 对于形似函数的宏（macros），最好改用 inline 函数替换 #define。

> 条款3：尽可能使用 const
>
> - 将某些东西声明为 const 可帮助编译器侦测出错误用法。const 可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
> - 编译器强制实施 bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。
> - 当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可避免重复代码。

> 条款4：确定对象被使用前已先被初始化
>
> - 对内置型对象进行手工初始化，因为 C++ 不保证初始化它们。
> - 构造函数最好使用成员初始列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。
> - 为免除“跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。

> 条款5：了解 C++ 默默编写并调用那些函数
>
> - 编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数

> 条款6：若不想使用编译器自动生成的函数，就该明确拒绝。
> **即**：为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不允实现，使用像Uncopy这样的base class也是一种做法。

在我们自己定义的类型中，如果我们没有声明ctor、copy ctor、copy assignment ctor。但是我们在程序中使用的它们，那么**编译器**会以public的方式为我们声明它们，我们的程序不会报出任何错误。

但是如果我们的需求是：我们不能让这些自定义类型的对象（object）之间进行拷贝构造（copy ctor）或者拷贝赋值（copy assignment ctor），那么除了自己不主动的定义这两个函数之外，我们还得阻止编译器这么做，这样使得我们的程序中如果出现上述两种行为的时候，在编译阶段程序就能报错。

- 方式1：可以将它们声明（不进行定义）为private以阻止它们被调用（private属性的数据成员（data member）和函数成员（function member）都不能通过对象进行访问）。这样，我们在程序中出现了上述两种行为的时候，编译器进行编译的时候就会报错。那当编译器没有报错的时候就一定能够保证我们的程序中没有这两种行为吗？不，我们的private成员还有可能被两类函数调用：member函数和friend函数，针对这种行为，编译器在编译的时候不会报错，但是连接器在连接的时候会报错。
- 方式2：为了完全解决掉方式1中的最后一种情况（member函数和friend函数中出现上述两种行为），同时也是将这种错误从连接阶段提前到编译阶段。我们可以让自定义类型以private的方式继承一个base class（Uncopyable），我们依旧在member函数或者friend函数中调用上述两种行为，当编译器尝试生成一个copy ctor和copy assignment ctor操作符时，会首先调用base class对应的这两个操作符，由于base class的拷贝函数为private，当然这些调用会被拒绝你。其实也就是Uncopyable类型绝不会有member函数和friend函数。
  - `class Myclass: private Uncopyable{}`    **public？**

C++ iostream程序库中阻止copying行为，就是将copy ctor、copy assignment ctor函数声明为private而且故意不实现它。

>条款7：为多态基类声明virtual析构函数

>条款8：别让异常逃离析构函数

>条款9：绝不在构造和析构过程中调用virtual函数

>条款10：令operator=返回一个reference to *this

>条款11：在operator=中处理自我赋值

>条款12：复制对象时勿忘其每一个成分

>条款13：以对象管理资源

> 条款13：以对象管理资源
> 
> - 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。
> - 两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它（被复制物）指向null。

> 条款14：在资源管理类中小心copying行为
>
> - 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
> - 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法（reference counting）.不过其它行为也都可能被实现。

> 条款15：在资源管理类中提供对原始资源的访问
>
> - APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。  
> - 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。  

> 条款16：成对使用new和delete时要采取相同形式  
>
> - 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要再相应的delete表示式中使用[]。

> 条款17：以独立语句将newed对象置入智能指针
>
> - 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。

> 条款18：让接口容易被正确使用，不易被误用
> 
> - 未看完，转至条款4

> 条款4：确定对象被使用前已被初始化
>
> - 为内置型对象进行手工初始化，因为C++不保证初始化它们。
> - 构造函数最好使用成员初始列（member initialization list），而不要再构造函数本体内使用赋值操作（assignment）。初始列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。
> - 为避免“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。

> 条款 18：让接口容易被正确使用，不易被误用
>
> - 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。
> - “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
> - “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
> - tr1::shared_ptr支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexex；见条款14）等等。

> 条款19：设计class犹如设计type
>
> - Class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。

> 条款20：宁以pass-by-reference-to-const替换pass-by-value
>
> - 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）。
> - 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。

> 条款21：必须返回对象时，别妄想返回其reference
>
> - 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。

> 条款22：将成员变量声明为private
>
> - 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。
> - protected并不比public更具封装性。

***《Effective C++》已经看完了25个条款，今天开始对这25个条款进行总结，然后再开始学习最后25个条款。***

> 条款1：视C++为一个语言联邦
>
> - C++ 高效编程守则视状况而变化，取决于你使用 C++ 的哪一部分

C++最初的名称是 C with classes，那时的它只是比C多了一些面向对象的特性。经过发展，现在 C++ 已经是一个多重范型编程语言，同时支持过程式、函数式、面向对象、泛型编程、元编程。  
在编程的过程中，我们往往会遵循一些守则让程序变得更加高效规范，这时问题就出现了，C++的多重性使得它并没有一个统一的守则来让我们在使用不同范型编程的时候，程序依然保持高效规范。这时我们就最好不要再将 C++ 视为一个带有一组守则的一体语言了，而是由多个子语言（不同的子语言有其独特的范型编程模式）组成的联邦政府，每个子语言都有自己的守则。
C++ 的子语言总共只有4个：

- C：C++是以C为基础的，你完全可以只适用C++中C的那部分语法。但是此时你会发现你的程序就只反映了C的特征：没有模板、没有异常、没有重载。
- 面向对象（Object-Oriented C++）：面向对象程序设计的初衷，即构造函数和析构函数，封装，继承，多态性，虚函数等等。
- Template C++：这是C++的泛型编程部分，多数程序员很少涉及，但模板在很多情况下仍然很方便。另外模板元编程（template metaprogramming）也是一个新兴的程序设计范式。
- STL：这是一个特殊的模板库，它的容器、迭代器和算法优雅地结合在一起，只是在使用时你需要遵循它的程序设计守则。当然你也可以基于其它想法来构建模板库。  

设计高效规范的 C++ 程序的守则并非一成不变，而是取决于你使用C++语言的哪一部分。例如，在基于C语言的程序设计中，对基本类型，传参时传值比传引用更有效率。然而当你接触Object-Oriented C++时会发现，对用户自定义类型，传参时传常量指针是更好的选择。但是你如果又碰到了STL，其中的迭代器和函数对象都是基于C语言的指针而设计的，这时又回到了原来的守则：传值比传引用更好。

> 条款2：尽量以 const，enum，inline 替换 #define
>
> - 对于单纯常量，最好以 const 对象或 enums 替换 #define。
> - 对于形似函数的宏（macros），最好改用 inline 函数替换 #define。

>在编译器对代码处理前，预处理器会先对代码处理，预处理器根据以字符#开头的命令修改原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。例如"#include < iostream >"、"#define"、"#ifdef/#ifndef"都会在这个阶段进行处理，这是背景。  

这里我们主要考虑的是 ```PI 3.14``` 是以**宏的形式**出现在代码中还是以**常量的形式**出现在代码中：

1) 如果以宏的形式：```#define PI 3.14```。在预处理阶段，预处理器将代码中符号（PI）出现的地方全部替换为对应的值（3.14），如果预处理器将PI移除掉了，自然进入编译阶段时，编译器看不到这个符号，也就不会在记号表中创建相关的内容。
2) 如果以常量的形式：```const int PI = 3.14```。在预处理阶段不会对这个常量进行处理，进入编译阶段，编译器会在记号表中创建相关的内容。  
  
我们从以下几个角度来说明第二种定义方式更加合适：

- 报错信息输出。在编译阶段，如果PI出现的地方存在错误，编译器将给出报错信息。如果定义为第一种形式，并且预处理器会将PI移除，编译器报错信息中只会出现3.14，而不会出现PI（如果不移除自然也会有，但谁能百分百的确定呢）。如果定义为第二种形式，编译器报错信息就会顺利出现PI。
- 使用记号式调试器调试程序。调试过程将会使用编译器创建的记号表，第一种定义方式，同样，如果预处理器将PI移除，调试器将无法跟踪PI，因为记号表中压根就没有。第二种定义方式显然如我们的意。
- 作用域不同（封装性不同）。如果我们设计的class需要一个专属常量，同时让它的作用域限制在class中。如果以第二种方式，我们只需要将它设计为成员，并且加以const修饰，就能完成封装和作用域限定。我们没有办法用第一种方式来做到这两点，#define并不重视作用域，一旦宏被定义，在其后的编译过程中都有效，所以这意味着#define不仅不能够用来定义class专属常量，也不能够提供任何封装性。
  
上面我们把焦点放在了#define和const常量的对比上面，在“作用域不同（封装性不同）”这里，关于用const设计class专属常量需要展开说明，当然这里的展开说明不会带上#define，但是我们会转向enum。如果我们要让这个const修饰的class专属常量只有一个实体，也就是说不论定义多少对象，这个常量就只有一个实体，我们需要再在const前面加一个static关键字。《Effective C++》针对这个**static const**修饰的专属常量的初值设定时机和各时机情况下编译器可能作出的反映作了详细说明：声明式中设定初值、定义式中设定初值...，感觉有点记忆负担，就直接规范为在类内（in-class）的声明式上不设定初值（in-class初值设定），只在定义处设定初值。

```C++
//时机1：
class A{
private:
    static const int NUM = 5; // 常量声明式，初值设定（in-class方式）
}
const int A::NUM //常量定义式，在以下情况需要：某个编译器内在规则设定为需要；它是专属常量、是static类型、是整数类型且要对它取地址操作。当然这时这里就不能设定初值了。
//时机2：
class A{
private:
    static const int NUM; // 常量声明式
}
const int A::NUM = 5 //常量定义式，初值设定
```  

接下来我们要转向enum了，你可以认为前面在啰嗦其它事情。我们的class现在有一个数组成员arr（见下面代码片段），这个数组成员的大小依赖于我们刚才的那个static const修饰的专属常量。此时此刻我们的编译器可能就会出问题了，如果编译器坚持在编译期间知道数组的大小，并且“不允许static整型常量”完成“in-class初值设定”，那么编译器就不允许这段代码通过编译。

```C++
class A{
private:
    static const int NUM = 5; // in-class初值设定
    int arr[NUM]
}
```

这时就引出了enum，我们该用“enum hack”补偿做法。下面这个代码段能够编译通过。

```C++
class A{
private:
    enum { NUM = 5 };
    int arr[NUM]
}
```

这里enum除了补偿这一需求，它还有自己的特点，它不会让别人获得一个pointer或reference指向你的这个整数常量，而const显然可以。  
重新将焦点拉回#define，它的第二种使用方式是以它来实现一个像函数的宏，这样做虽然不会导致函数调用的额外开销，但是书写实在太麻烦，而且存在一些细节性的问题（宏实参为前置++）。一劳永逸的解决办法就是把这个函数改为inline实现，这样做不会导致函数调用的额外开销，也让书写更加简单，更重要的是可以对它进行封装和作用域限定。

```C++
#define CALL_WITH_MAX(a,b) f((a) > (b)? (a) : (b))//实现宏

inline void callWithMax(const int a,const int b)//inline实现
{
    f(a > b? a : b);
}
```
