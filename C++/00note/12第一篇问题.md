[toc]

#### [1、在 main 执行之前和之后执行的代码可能是什么？](https://mp.weixin.qq.com/s?__biz=Mzg2MDU0ODM3MA==&mid=2247485655&idx=1&sn=257b86c8e88133f57cd94750bdfbd7c1&chksm=ce25f4aaf9527dbc23d1f6b6094d26da329c0515d8d6bcbd0179ab73acc76bfef0ce31ed553d&scene=178&cur_album_id=1728595536544366595#rd)

- **main 函数执行之前，主要就是初始化系统相关资源**

  - 设置栈指针
  - 初始化静态 static 变量和 global 全局变量，即.data 段的内容
  - 将未初始化部分的全局变量赋初值：数值型 short，int，long 等为 0，bool 为 FALSE，指针为 NULL 等等，即.bss 段的内容
  - 全局对象初始化，在 main 之前调用构造函数，这是可能会执行前的一些代码
  - 将 main 函数的参数 argc，argv 等传递给 main 函数，然后才真正运行 main 函数

- **main 函数执行之后**
  - 全局对象的析构函数会在 main 函数之后执行；
  - 可以用 atexit 注册一个函数，它会在 main 之后执行;

> [附录：为什么要区分.bss 和.data 段？](https://blog.csdn.net/Ivan804638781/article/details/110209548)
>
> - **.data 段**
>   存放已初始化的全局变量。在编译器编译的时候，会给已初始化的数据分配内存空间，数据保存在目标文件中。
> - **.bss 段**
>   （bss 是英文 Block Started by Symbol 的简称。）存放未初始化的全局变量。在编译器编译的时候，不会给该段的数据分配空间，只是记录数据所需的空间大小。程序执行的时候再分配内存并将内存清零。
> - **为什么要分.data 段和.bss 段？**
>   在程序编译的时候，不会给.bss 段中的数据分配空间，只是记录数据所需空间的大小。在程序执行的时候，才会给.bss 段中的数据分配内存。通过这种方式，可以节省一部分内存空间，进一步**缩减可执行程序的大小。**

#### [2、结构体内存对齐问题？]()

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中 size 最大的成员对齐（若有 double 成员，按 8 字节对齐。）

#### [3、指针和引用的区别]()

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- **指针可以有多级，引用只有一级**
- **指针可以为空，引用不能为 NULL 且在定义时必须初始化**
- **指针在初始化后可以改变指向，而引用在初始化之后不可再改变**
- **sizeof 指针得到的是本指针的大小，sizeof 引用得到的是引用所指向变量的大小**
- **当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以**
- 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。
- 引用在声明时必须初始化为另一变量，一旦出现必须为 typename refname &varname 形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。
- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。
- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

```C++{.line-numbers}

void test(int *p)
{
　　int a=1;
　　p=&a;
　　cout<<p<<" "<<*p<<endl;
}

int main(void)
{
    int *p=NULL;
    test(p);
    if(p==NULL)
    cout<<"指针p为NULL"<<endl;
    return 0;
}
//运行结果为：
//0x22ff44 1
//指针p为NULL



void testPTR(int* p) {
    int a = 12;
    p = &a;
}

void testREFF(int& p) {
    int a = 12;
    p = a;
}
void main()
{
    int a = 10;
    int* b = &a;
    testPTR(b);//改变指针指向，但是没改变指针的所指的内容
    cout << a << endl;// 10
    cout << *b << endl;// 10

    a = 10;
    testREFF(a);
    cout << a << endl;//12
}
```

#### [4、堆和栈的区别]()

- **申请方式不同**：栈由系统自动分配；堆是自己申请和释放的。
- **申请大小限制不同**：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过 ulimit -a 查看，由 ulimit -s 修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- **申请效率不同**：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。

> [附录：谈谈内存分配中的堆和栈的区别？为什么要有堆区和栈区呢？](https://blog.csdn.net/Ivan804638781/article/details/110209718)
> （1）管理方式不同：
> 栈直接由编译器管理（产生和消除），堆由程序员管理，程序员管理其的产生和消除
> （2）空间大小不同：
> 栈占用的空间较小，而堆占用的空间较大
> （3）能否产生碎片不同：
> 栈不会产生碎片，但是堆会产生，会有内存泄露的问题
> （4）生长方向不同：
> 栈是向下压栈，堆是向上存放数据
> （5）分配方式不同：
> 栈是在程序员申请之后，由系统分配的没有经过初始化的变量，只有动态分配方式。而堆是由程序员自己实例化，创建的已经过初始化的变量，分配方式类似于链表，动态分配和静态分配都可以
> （6）分配效率不同：
> 栈是由内存分配的，系统专门为其准备寄存器，同时有专门的出栈和入栈指令，因而效率比较高。而堆空间则是 C 库分配的，可能会存在碎片的原因导致内存不连续，因而效率比较低

#### [5、区别以下指针类型？]()

```C++{.line-numbers}
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- `int *p[10]`表示指针数组，强调数组概念，是一个数组变量，数组大小为 10，数组内每个元素都是指向 int 类型的指针变量。
- `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 int 类型的数组，这个数组大小是 10。
- `int *p(int)`是函数声明，函数名是 p，参数是 int 类型的，返回值是 int \*类型的。
- `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有 int 类型参数，并且返回值是 int 类型的。

#### [6、基类的虚函数表存放在内存的什么区，虚表指针 vptr 的初始化时间]()

- 首先整理一下**虚函数表\***的特征：
  - **虚函数表**是全局共享的元素，即全局仅有一个，在编译时就构造完成
  - **虚函数表**类似一个数组，类对象中存储 vptr 指针，指向**虚函数表**，即虚函数表不是函数，不是程序代码，不可能存储在代码段
  - **虚函数**表存储**虚函数**的地址,即**虚函数表**的元素是指向类成员函数的指针,而类中**虚函数**的个数在编译时期可以确定，即**虚函数表**的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储**虚函数表**，所以不在堆中
- 根据以上特征，**虚函数表**类似于类中静态成员变量，静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：
  - **虚函数表** vtable 在 Linux/Unix 中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将**虚函数表**存放在常量段存在一些差别
  - 由于**虚表**指针 vptr 跟**虚函数**密不可分，对于有**虚函数**或者继承于拥有**虚函数**的基类，对该类进行实例化时，在构造函数执行时会对**虚表**指针进行初始化，并且存在对象内存布局的最前面。
- 一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区
- C++中**虚函数表**位于只读数据段（.rodata），也就是 C++内存模型中的常量区；而**虚函数**则位于代码段（.text），也就是 C++内存模型中的代码区。

> [附录：C++中虚函数、虚继承内存模型](https://zhuanlan.zhihu.com/p/41309205)

#### [7、new / delete 与 malloc / free 的异同]()

- 相同点
  - 都可用于内存的动态申请和释放
- 不同点

  - 前者是 C++运算符，后者是 C/C++语言标准库函数
  - new 自动计算要分配的空间大小，malloc 需要手工计算
  - new 是类型安全的，malloc 不是。例如：

    ```c++{.line-numbers}
    int *p = new float[2]; //编译错误
    int *p = (int*)malloc(2 * sizeof(double));//编译无错误
    ```

- new 调用名为 operator new 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为 operator delete 的标准库函数释放该对象所用内存。后者均没有相关调用
- 后者需要库文件支持，前者不用
- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象

#### [8、new 和 delete 是如何实现的？]()

- new 的实现过程是：首先调用名为 operator new 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针

- delete 的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为 operator delete 的标准库函数释放该对象所用内存

#### [9、malloc 和 new 的区别？]()

- malloc 和 free 是标准库函数，支持覆盖；new 和 delete 是运算符，并且支持重载。
- malloc 仅仅分配内存空间，free 仅仅回收空间，不具备调用构造函数和析构函数功能，用 malloc 分配空间存储类的对象存在风险；new 和 delete 除了分配回收功能外，还会调用构造函数和析构函数。
- malloc 和 free 返回的是 void 类型指针（必须进行类型转换），new 和 delete 返回的是具体类型指针。
- **delete 和 delete[]区别？**
  - delete 只会调用一次析构函数。
  - delete[]会调用数组中每个元素的析构函数。

#### [10、宏定义和函数有何区别？]()

- 宏在编译前完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏定义不要在最后加分号。

#### [11、宏定义和 typedef 区别？]()

- 宏主要用于定义常量及书写复杂的内容；typedef 主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef 是编译的一部分。
- 宏不检查类型；typedef 会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef 是语句，要加分号标识结束。
- 注意对指针的操作，`typedef char * p_char`和 `#define p_char char *`区别巨大。

#### [12、变量声明和定义区别？]()

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量 extern），但只能在一处定义。

#### [13、哪几种情况必须用到初始化成员列表？]()

- 需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)
  - 如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。
- **初始化一个 const 成员。**
- **初始化一个 reference 成员。**
  - 当类成员中含有一个 const 对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。
- 子类初始化父类的私有成员
  - 子类初始化父类的私有成员，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数

> [附录：C++必须使用【初始化列表】初始化数据成员的三种情况](https://blog.csdn.net/sinat_20265495/article/details/53670644)

#### [28、拷贝初始化和直接初始化]()

- 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

  ```C++{.line-numbers}
  string str1("I am a string");//语句 1 直接初始化
  string str2(str1);//语句 2 直接初始化，str1 是已经存在的对象，直接调用构造函数对 str2 进行初始化
  string str3 = "I am a string";//语句 3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造 str3
  string str4 = str1;//语句 4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
  ```

- 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句 1 和语句 3 等价）。但是需要辨别两种情况。

- 当拷贝构造函数为 private 时：语句 3 和语句 4 在编译时会报错

- 使用 explicit 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

> [附录 1：C++的直接初始化与复制初始化的区别](https://blog.csdn.net/qq936836/article/details/83450218).
> [附录 2：C++的直接初始化与复制初始化](https://sqrt-1.me/?p=241)

#### [29、初始化和赋值的区别]()

- 对于简单类型来说，初始化和赋值没什么区别

- 对于类和复杂数据类型来说，这两者的区别就大了，举例如下：

#### [30、extern"C"的用法]()

- 为了能够正确的在 C++代码中调用 C 语言的代码：在程序中加上 extern "C"后，相当于告诉编译器这部分代码是 C 语言写的，因此要按照 C 语言进行编译，而不是 C++；

- 哪些情况下使用 extern "C"：

  - （1）C++代码中调用 C 语言代码；
  - （2）在 C++中的头文件中使用；
  - （3）在多个人协同开发时，可能有人擅长 C 语言，而有人擅长 C++；

- 举个例子，C++中调用 C 代码：

  ```C++{.line-numbers}
  #ifndef __MY_HANDLE_H__
  #define __MY_HANDLE_H__

  extern "C"{
  typedef unsigned int result_t;
  typedef void* my_handle_t;

  my_handle_t create_handle(const char* name);
  result_t operate_on_handle(my_handle_t handle);
  void close_handle(my_handle_t handle);
  }
  ```

- 综上，总结出使用方法，在 C 语言的头文件中，对其外部函数只能指定为 extern 类型，C 语言中不支持 extern "C"声明，在.c 文件中包含了 extern "C"时会出现编译语法错误。所以使用 extern "C"全部都放在于 cpp 程序相关文件或其头文件中。

- 总结出如下形式：

  - （1）C++调用 C 函数

    ```c++{.line-numbers}
    //xx.h
    extern int add(...)

    //xx.c
    int add(){

    }

    //xx.cpp
    extern "C" {
        #include "xx.h"
    }
    ```

  - （2）C 调用 C++函数

    ```C++{.line-numbers}
    //xx.h
    extern "C"{
        int add();
    }
    //xx.cpp
    int add(){

    }
    //xx.c
    extern int add();
    ```

> [附录：关于 extern "C"（详细剖析）](https://www.cnblogs.com/TenosDoIt/p/3163621.html)  
> [附录：extern "C"：实现 C++和 C 的混合编程](http://c.biancheng.net/view/8064.html)

#### [31、模板函数和模板类的特例化]()

- 引入原因
  - 编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化
- 定义
  - 对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

1. **模板函数特例化**
   必须为原函数模板的每个模板参数都提供实参，且使用关键字 template 后跟一个空尖括号对<>，表明为原模板的所有模板参数提供实参，举例如下：

   ```C++{.line-numbers}
   template<typename T> //模板函数
   int compare(const T &v1,const T &v2)
   {
       if(v1 > v2) return -1;
       if(v2 > v1) return 1;
       return 0;
   }
   //模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
   template<>
   int compare(const char* const &v1,const char* const &v2)
   {
       return strcmp(p1,p2);
   }
   ```

   **本质**
   特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是 compare(3,5)，则调用普通的模板，若为 compare(“hi”,”haha”)则调用特例化版本（因为这个 cosnt char\*相对于 T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。
   **注意**
   模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。

2. **类模板特例化**
   原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用 template<>表示是一个特例化版本，例如：

   ```C++{.line-numbers}
    template<>
    class hash<sales_data>
    {
        size_t operator()(sales_data& s);
        //里面所有T都换成特例化类型版本sales_data
        //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
    };
   ```

   **类模板的部分特例化**
   不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)
   **特例化类中的部分成员**
   可以特例化类中的部分成员函数而不是整个类，举个例子：

   ```C++{.lin-numbers}
    template<typename T>
    class Foo
    {
        void Bar();
        void Barst(T a)();
    };

    template<>
    void Foo<int>::Bar()
    {
        //进行int类型的特例化处理
        cout << "我是int型特例化" << endl;
    }

    Foo<string> fs;
    Foo<int> fi;//使用特例化
    fs.Bar();//使用的是普通模板，即Foo<string>::Bar()
    fi.Bar();//特例化版本，执行Foo<int>::Bar()
    //Foo<string>::Bar()和Foo<int>::Bar()功能不同
   ```

> [附录：类和函数模板特例](https://blog.csdn.net/wang664626482/article/details/52372789)
