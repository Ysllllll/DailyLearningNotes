参考：

- [变量的声明、定义、赋值和初始化有什么区别？](https://www.zhihu.com/question/27639400)
- [内存分配和初始化是在编译时和运行时分别进行的吗？](https://cloud.tencent.com/developer/ask/221057)

在编写代码的过程中，我们通过关键字和运算符来指导一个变量的声明、定义、初始化和赋值。但是深入下去，它们在编译时或运行时有什么具体的动作呢？

#### 一、编程角度

| 行为   | 说明                                                                                                                         |
| ------ | ---------------------------------------------------------------------------------------------------------------------------- |
| 声明   | 告知编译器，已经存在一个位置和大小均知道的变量，这个行为是不分配内存空间的。                                                 |
| 定义   | 在内存中确定变量的位置、大小，为变量分配内存空间。在C语言中，一般声明就包含了定义                                            |
| 初始化 | 定义的同时给出变量的值，叫初始化。                                                                                           |
| 赋值   | 是对于已定义好的变量，重新给出其值，赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作，修改存储空间内的数据。 |

#### 二、编译角度、运行角度

变量初始化取决于变量的种类，全局或静态变量在编译时初始化，而自动变量在运行时管理。

##### 全局变量

- 在编译时，所有全局变量的值都是已知的。这些值由编译器写入目标文件的特定部分。
- 在链接时，收集所有目标文件并确定每个变量的存储位置。这允许知道每个变量的地址，以防这些地址中的一个被分配给另一个变量。结果，生成可执行文件，其包含每个部分（文本，数据，rodata等）的内容的描述。在data或rodata部分中，写入所有初始化全局变量的值。
- 在运行时，加载程序读取不同部分的描述并询问OS内存。然后，它会将所有部分的内容复制到各自的内存位置。这是使用在编译或链接时确定的值初始化变量的方式。唯一的例外是初始化为零（或未初始化）的变量。它们位于特殊部分（通常称为bss）。要减小可执行文件的大小，这些零值不会写入可执行文件中。相反，在执行之前main()，运行时过程将memset为零部分的所有内容。

其实全局变量的初始化可以划分为两个阶段（静态初始化执行先于动态初始化）：

- 静态初始化（static initialization）：静态初始化指的是用常量来对变量进行初始化，主要包括 zero initialization 和 const initialization，静态初始化在程序加载的过程中完成，对简单类型(内建类型，POD等)来说，从具体实现上看，zero initialization 的变量会被保存在 bss 段，const initialization 的变量则放在 data 段内，程序加载即可完成初始化，这和 c 语言里的全局变量初始化基本是一致的。
- 动态初始化（dynamic initialization）：动态初始化主要是指需要经过函数调用才能完成的初始化，比如说：`const int i = get_size()`，或者是复杂类型（类）的初始化（需要调用构造函数）等。这些变量的初始化会在 main 函数执行前由运行时调用相应的代码从而得以进行(函数内的 static 变量除外)。

##### 自动变量

自动变量完全不同。在程序运行之前，人们不知道这些变量的位置，唯一的方法是通过机器指令计算它们的值。

因此编译器首先确定这些变量是否位于寄存器或存储器中，并且在进入该函数时，第一条指令将为局部变量保留堆栈空间并初始化它们的值。这是通过常规机器指令完成的。

如果值是另一个变量的地址（比如 `y =&x`），

- 如果 `x` 是本地（自动）变量，则通过写入 `y` 堆栈指针寄存器的内容和给定的偏移量的总和来计算地址。由编译器确定
- 如果 `x` 是全局变量或静态变量，在链接时，一旦知道全局变量的地址，链接器就会修改编译器生成的指令，以便在用于表示的寄存器或堆栈位置中写入正确的地址 `y`。
