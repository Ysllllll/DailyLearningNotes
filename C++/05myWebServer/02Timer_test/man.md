分为 timer 和 timer manage 两个结构体，作用如其名。

在 timer manage 中有一个优先队列 priority_queue 用于存放 timer。

那么向 timer manage 中添加定时器就有两种方式：

- 添加一个已经有的 timer
- 在添加的过程中构造一个 timer 然后添加进入队列中，此时需要返回一个指向该 timer 的指针传递给用户，因为后期可能该 timer 所记录的信息会被改写，此时就需要修改 timer 的超时时间。

也就是说用户可以修改 timer 中的信息，但是如何同步更新这个 timer 在优先队列中的位置呢？

优先队列的一个特点是：每次的 push 和 pop 操作，队列都会动态的调整，以达到我们预期的方式来存储。

---

一个定时器有三种状态：

- 正常状态：未被删除、未超时（有效 valid，且可被更新 update）
- 删除状态（无效，可被 update 以期重用）
- 超时状态（无效，转变为删除状态）

---

    void changeInfo(TimerNodeInfo info);

我们没有实现这个函数，这也就表明了一个定时器对应的信息不可被更改。

如果不这样，就会导致 timer 不被区分，此时可以做一个 timer 定时器池，将处于 delete 状态的定时器，清空（或不清空）信息放入定时器池以待重用。

导致 timer 不被区分造成的影响是，或者说定时器池的影响是，如果刚好有某个信息需要定时器计时，此时将在定时器中填写新信息。如果我们后续再更新（update）这个 timer 以期恢复旧的信息就会失败，因为旧信息已经被覆盖，此时就需要重新构造旧信息，这也要求旧信息必须在定时器之外被保存下来。这样就丢失了延迟删除带来的好处了。所以我们重用的不能是某一个定时器，而是某一个信息

另外一个方面信息的清除操作也只能在定时器被从队列中删除才执行

---

这一块的理解同样可以用人和房间来类别，一个定时器代表一个人，队列代表房间内外区域，房间内的人都是正常状态，就算存在超时的在调用 isValid 函数时也会被赶出房间外；房间外的人都是一定处于 delete 状态的人，但是他们不一定全部都超时才被 delete，有些是主动 delete 的

更新（update）操作，先判断是否在房间外，也就是是否处于 delete 状态，如果是则需要重新设置 delete 状态，然后更新时间，这里不需要判断是否超时是否 valid

有效判断（isValid）操作，如果处于房间外就返回 false，如果处于房间内就需要判断其是否超时，若超时就将其赶出门外，即设定其为 delete 状态，不更新时间

---

## bug

优先队列无法随机访问，所以如果我们对队列中的某一个定时器 update，它的时间被修改，但是优先队列不会自动调整，所以存在 bug

直接举例：

```bash
[16000 12000 10000 5000 1000]
t1->update(20000);
[16000 12000 10000 5000 21000]
```

这样会导致后续的 timer 必须要等到 t1 timer 被删除才能一次性被删除。当然这也符合对于被置为 deleted 的时间节点，会延迟到它：1.超时；2.它前面的节点都被删除。它才会被删除。

一个点被置为 deleted,它最迟会在 TIMER_TIME_OUT 时间后被删除。
这样做有两个好处：
(1) 第一个好处是不需要遍历优先队列，省时。
(2) 第二个好处是给超时时间一个容忍的时间，就是设定的超时时间是删除的下限(并不是一到超时时间就立即删除)，如果监听的请求在超时后的下一次请求中又一次出现了，就不用再重新申请 RequestData 节点了，这样可以继续重复利用前面的 RequestData，减少了一次 delete 和一次 new 的时间。

---

    ```bash
    g++ main.cc Timer.cc  -lpthread -o main
    ./main
    ```
